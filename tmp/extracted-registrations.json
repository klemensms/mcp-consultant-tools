{
  "tools": {
    "powerplatform": [
      {
        "name": "get-entity-metadata",
        "code": "server.tool(\n  \"get-entity-metadata\",\n  \"Get metadata about a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const metadata = await service.getEntityMetadata(entityName);\n      \n      // Format the metadata as a string for text display\n      const metadataStr = JSON.stringify(metadata, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Entity metadata for '${entityName}':\\n\\n${metadataStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity metadata: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-attributes",
        "code": "server.tool(\n  \"get-entity-attributes\",\n  \"Get attributes/fields of a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const attributes = await service.getEntityAttributes(entityName);\n      \n      // Format the attributes as a string for text display\n      const attributesStr = JSON.stringify(attributes, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Attributes for entity '${entityName}':\\n\\n${attributesStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity attributes:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity attributes: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-attribute",
        "code": "server.tool(\n  \"get-entity-attribute\",\n  \"Get a specific attribute/field of a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    attributeName: z.string().describe(\"The logical name of the attribute\")\n  },\n  async ({ entityName, attributeName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const attribute = await service.getEntityAttribute(entityName, attributeName);\n      \n      // Format the attribute as a string for text display\n      const attributeStr = JSON.stringify(attribute, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Attribute '${attributeName}' for entity '${entityName}':\\n\\n${attributeStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity attribute:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity attribute: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-relationships",
        "code": "server.tool(\n  \"get-entity-relationships\",\n  \"Get relationships (one-to-many and many-to-many) for a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const relationships = await service.getEntityRelationships(entityName);\n      \n      // Format the relationships as a string for text display\n      const relationshipsStr = JSON.stringify(relationships, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Relationships for entity '${entityName}':\\n\\n${relationshipsStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity relationships:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity relationships: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-global-option-set",
        "code": "server.tool(\n  \"get-global-option-set\",\n  \"Get a global option set definition by name\",\n  {\n    optionSetName: z.string().describe(\"The name of the global option set\"),\n  },\n  async ({ optionSetName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const optionSet = await service.getGlobalOptionSet(optionSetName);\n      \n      // Format the option set as a string for text display\n      const optionSetStr = JSON.stringify(optionSet, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Global option set '${optionSetName}':\\n\\n${optionSetStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting global option set:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get global option set: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-record",
        "code": "server.tool(\n  \"get-record\",\n  \"Get a specific record by entity name (plural) and ID\",\n  {\n    entityNamePlural: z.string().describe(\"The plural name of the entity (e.g., 'accounts', 'contacts')\"),\n    recordId: z.string().describe(\"The GUID of the record\"),\n  },\n  async ({ entityNamePlural, recordId }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const record = await service.getRecord(entityNamePlural, recordId);\n      \n      // Format the record as a string for text display\n      const recordStr = JSON.stringify(record, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Record from '${entityNamePlural}' with ID '${recordId}':\\n\\n${recordStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get record: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-records",
        "code": "server.tool(\n  \"query-records\",\n  \"Query records using an OData filter expression\",\n  {\n    entityNamePlural: z.string().describe(\"The plural name of the entity (e.g., 'accounts', 'contacts')\"),\n    filter: z.string().describe(\"OData filter expression (e.g., \\\"name eq 'test'\\\" or \\\"createdon gt 2023-01-01\\\")\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of records to retrieve (default: 50)\"),\n  },\n  async ({ entityNamePlural, filter, maxRecords }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const records = await service.queryRecords(entityNamePlural, filter, maxRecords || 50);\n      \n      // Format the records as a string for text display\n      const recordsStr = JSON.stringify(records, null, 2);\n      const recordCount = records.value?.length || 0;\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Retrieved ${recordCount} records from '${entityNamePlural}' with filter '${filter}':\\n\\n${recordsStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error querying records:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to query records: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-record",
        "code": "server.tool(\n  \"create-record\",\n  \"Create a new record in Dataverse. Requires POWERPLATFORM_ENABLE_CREATE=true.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    data: z\n      .record(z.any())\n      .describe(\n        \"Record data as JSON object. Field names must match logical names (e.g., {'name': 'Acme Corp', 'telephone1': '555-1234'}). \" +\n        \"For lookup fields, use '@odata.bind' syntax: {'parentaccountid@odata.bind': '/accounts(guid)'}. \" +\n        \"For option sets, use integer values.\"\n      ),\n  },\n  async ({ entityNamePlural, data }) => {\n    try {\n      checkCreateEnabled();\n      const service = getPowerPlatformService();\n      const result = await service.createRecord(entityNamePlural, data);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record created successfully in ${entityNamePlural}\\n\\n` +\n              `**Record ID:** ${result.id || result[Object.keys(result).find(k => k.endsWith('id')) || ''] || 'N/A'}\\n\\n` +\n              `**Created Record:**\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to create record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-record",
        "code": "server.tool(\n  \"update-record\",\n  \"Update an existing record in Dataverse. Requires POWERPLATFORM_ENABLE_UPDATE=true.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    recordId: z\n      .string()\n      .describe(\"The GUID of the record to update\"),\n    data: z\n      .record(z.any())\n      .describe(\n        \"Partial record data to update (only fields being changed). \" +\n        \"Field names must match logical names. \" +\n        \"Use '@odata.bind' syntax for lookups, integer values for option sets.\"\n      ),\n  },\n  async ({ entityNamePlural, recordId, data }) => {\n    try {\n      checkUpdateEnabled();\n      const service = getPowerPlatformService();\n      const result = await service.updateRecord(entityNamePlural, recordId, data);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record updated successfully in ${entityNamePlural}\\n\\n` +\n              `**Record ID:** ${recordId}\\n\\n` +\n              `**Updated Record:**\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to update record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-record",
        "code": "server.tool(\n  \"delete-record\",\n  \"Delete a record from Dataverse. Requires POWERPLATFORM_ENABLE_DELETE=true. WARNING: This operation is permanent and cannot be undone.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    recordId: z\n      .string()\n      .describe(\"The GUID of the record to delete\"),\n    confirm: z\n      .boolean()\n      .optional()\n      .describe(\"Confirmation flag - must be true to proceed with deletion (safety check)\"),\n  },\n  async ({ entityNamePlural, recordId, confirm }) => {\n    try {\n      checkDeleteEnabled();\n\n      // Require explicit confirmation for deletion\n      if (confirm !== true) {\n        return {\n          content: [\n            {\n              type: \"text\",\n              text: `âš ï¸  Delete operation requires explicit confirmation.\\n\\n` +\n                `You are about to delete record **${recordId}** from **${entityNamePlural}**.\\n\\n` +\n                `This operation is **permanent** and **cannot be undone**.\\n\\n` +\n                `To proceed, call this tool again with \\`confirm: true\\`.`,\n            },\n          ],\n        };\n      }\n\n      const service = getPowerPlatformService();\n      await service.deleteRecord(entityNamePlural, recordId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record deleted successfully\\n\\n` +\n              `**Entity:** ${entityNamePlural}\\n` +\n              `**Record ID:** ${recordId}\\n\\n` +\n              `âš ï¸  This operation is permanent.`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to delete record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-assemblies",
        "code": "server.tool(\n  \"get-plugin-assemblies\",\n  \"Get a list of all plugin assemblies in the environment\",\n  {\n    includeManaged: z.boolean().optional().describe(\"Include managed assemblies (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of assemblies to return (default: 100)\"),\n  },\n  async ({ includeManaged, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblies(includeManaged || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} plugin assemblies:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin assemblies:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin assemblies: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-assembly-complete",
        "code": "server.tool(\n  \"get-plugin-assembly-complete\",\n  \"Get comprehensive information about a plugin assembly including all types, steps, images, and validation\",\n  {\n    assemblyName: z.string().describe(\"The name of the plugin assembly\"),\n    includeDisabled: z.boolean().optional().describe(\"Include disabled steps (default: false)\"),\n  },\n  async ({ assemblyName, includeDisabled }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblyComplete(assemblyName, includeDisabled || false);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin assembly '${assemblyName}' complete information:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin assembly:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin assembly: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-plugin-pipeline",
        "code": "server.tool(\n  \"get-entity-plugin-pipeline\",\n  \"Get all plugins that execute on a specific entity, organized by message and execution order\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    messageFilter: z.string().optional().describe(\"Filter by message name (e.g., 'Create', 'Update', 'Delete')\"),\n    includeDisabled: z.boolean().optional().describe(\"Include disabled steps (default: false)\"),\n  },\n  async ({ entityName, messageFilter, includeDisabled }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getEntityPluginPipeline(entityName, messageFilter, includeDisabled || false);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin pipeline for entity '${entityName}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity plugin pipeline:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity plugin pipeline: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-trace-logs",
        "code": "server.tool(\n  \"get-plugin-trace-logs\",\n  \"Query plugin trace logs with filtering and exception parsing\",\n  {\n    entityName: z.string().optional().describe(\"Filter by entity logical name\"),\n    messageName: z.string().optional().describe(\"Filter by message name (e.g., 'Update')\"),\n    correlationId: z.string().optional().describe(\"Filter by correlation ID\"),\n    pluginStepId: z.string().optional().describe(\"Filter by specific step ID\"),\n    exceptionOnly: z.boolean().optional().describe(\"Only return logs with exceptions (default: false)\"),\n    hoursBack: z.number().optional().describe(\"How many hours back to search (default: 24)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of logs to return (default: 50)\"),\n  },\n  async ({ entityName, messageName, correlationId, pluginStepId, exceptionOnly, hoursBack, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginTraceLogs({\n        entityName,\n        messageName,\n        correlationId,\n        pluginStepId,\n        exceptionOnly: exceptionOnly || false,\n        hoursBack: hoursBack || 24,\n        maxRecords: maxRecords || 50\n      });\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin trace logs (found ${result.totalCount}):\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin trace logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin trace logs: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flows",
        "code": "server.tool(\n  \"get-flows\",\n  \"Get a list of all Power Automate cloud flows in the environment\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated flows (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of flows to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlows(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} Power Automate flows:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flows:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flows: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flow-definition",
        "code": "server.tool(\n  \"get-flow-definition\",\n  \"Get the complete definition of a specific Power Automate flow including its logic\",\n  {\n    flowId: z.string().describe(\"The GUID of the flow (workflowid)\"),\n  },\n  async ({ flowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlowDefinition(flowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Flow definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flow definition:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flow definition: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flow-runs",
        "code": "server.tool(\n  \"get-flow-runs\",\n  \"Get the run history for a specific Power Automate flow with success/failure status\",\n  {\n    flowId: z.string().describe(\"The GUID of the flow (workflowid)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of runs to return (default: 100)\"),\n  },\n  async ({ flowId, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlowRuns(flowId, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      // Calculate success/failure stats\n      const stats = result.runs.reduce((acc: any, run: any) => {\n        if (run.status === 'Succeeded') acc.succeeded++;\n        else if (run.status === 'Failed' || run.status === 'Faulted' || run.status === 'TimedOut') acc.failed++;\n        else if (run.status === 'Running' || run.status === 'Waiting') acc.inProgress++;\n        else acc.other++;\n        return acc;\n      }, { succeeded: 0, failed: 0, inProgress: 0, other: 0 });\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} flow runs for flow ${flowId}:\\n\\nStats:\\n- Succeeded: ${stats.succeeded}\\n- Failed: ${stats.failed}\\n- In Progress: ${stats.inProgress}\\n- Other: ${stats.other}\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flow runs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flow runs: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-workflows",
        "code": "server.tool(\n  \"get-workflows\",\n  \"Get a list of all classic Dynamics workflows in the environment\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated workflows (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of workflows to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflows(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} classic Dynamics workflows:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting workflows:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get workflows: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-workflow-definition",
        "code": "server.tool(\n  \"get-workflow-definition\",\n  \"Get the complete definition of a specific classic Dynamics workflow including its XAML\",\n  {\n    workflowId: z.string().describe(\"The GUID of the workflow (workflowid)\"),\n  },\n  async ({ workflowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflowDefinition(workflowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Workflow definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting workflow definition:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get workflow definition: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-business-rules",
        "code": "server.tool(\n  \"get-business-rules\",\n  \"Get a list of all business rules in the environment (read-only for troubleshooting)\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated business rules (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of business rules to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRules(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} business rules:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting business rules:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get business rules: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-business-rule",
        "code": "server.tool(\n  \"get-business-rule\",\n  \"Get the complete definition of a specific business rule including its XAML (read-only for troubleshooting)\",\n  {\n    workflowId: z.string().describe(\"The GUID of the business rule (workflowid)\"),\n  },\n  async ({ workflowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRule(workflowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Business rule definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting business rule:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get business rule: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-entity-icon",
        "code": "server.tool(\n  \"update-entity-icon\",\n  \"Update entity icon using Fluent UI System Icons from Microsoft's official icon library. Creates a web resource and sets it as the entity icon. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"The logical name of the entity (e.g., 'sic_strikeaction')\"),\n    iconFileName: z.string().describe(\"Fluent UI icon file name (e.g., 'people_community_24_filled.svg'). Browse icons at: https://github.com/microsoft/fluentui-system-icons\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add the web resource to (optional, uses POWERPLATFORM_DEFAULT_SOLUTION if not specified)\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const result = await service.updateEntityIcon(\n        params.entityLogicalName,\n        params.iconFileName,\n        params.solutionUniqueName\n      );\n\n      const message = `âœ… Successfully updated entity icon\n\n**Entity:** ${result.entityLogicalName} (${result.entitySchemaName})\n**Icon:** ${result.iconFileName}\n**Web Resource:** ${result.webResourceName}\n**Web Resource ID:** ${result.webResourceId}\n**Icon Vector Name:** ${result.iconVectorName}\n\nâœ¨ **Published:** The icon has been automatically published and should now be visible in the UI.\n\nðŸ’¡ TIP: Browse available Fluent UI icons at https://github.com/microsoft/fluentui-system-icons`;\n\n      return {\n        content: [{ type: \"text\", text: message }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating entity icon:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Failed to update entity icon: ${error.message}\\n\\nðŸ’¡ Make sure the icon file name is valid (e.g., 'people_community_24_filled.svg'). Browse available icons at https://github.com/microsoft/fluentui-system-icons`\n        }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "publish-customizations",
        "code": "server.tool(\n  \"publish-customizations\",\n  \"Publish all pending customizations in Dynamics 365. This makes all unpublished changes active. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {},\n  async () => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.publishAllCustomizations();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Successfully published all customizations. All pending changes are now active.\"\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error publishing customizations:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to publish customizations: ${error.message}`\n          }\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-solutions",
        "code": "server.tool(\n  \"get-solutions\",\n  \"Get all visible solutions in the environment\",\n  {},\n  async () => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getSolutions();\n\n      const solutions = result.value || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${solutions.length} solution(s):\\n\\n` +\n                  solutions.map((s: any) =>\n                    `- ${s.friendlyname} (${s.uniquename})\\n  Version: ${s.version}\\n  ID: ${s.solutionid}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting solutions:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get solutions: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "azure-devops": [
      {
        "name": "get-wikis",
        "code": "server.tool(\n  \"get-wikis\",\n  \"Get all wikis in an Azure DevOps project\",\n  {\n    project: z.string().describe(\"The project name\"),\n  },\n  async ({ project }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWikis(project);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wikis in project '${project}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting wikis:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get wikis: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "search-wiki-pages",
        "code": "server.tool(\n  \"search-wiki-pages\",\n  \"Search wiki pages across Azure DevOps projects\",\n  {\n    searchText: z.string().describe(\"The text to search for\"),\n    project: z.string().optional().describe(\"Optional project filter\"),\n    maxResults: z.number().optional().describe(\"Maximum number of results (default: 25)\"),\n  },\n  async ({ searchText, project, maxResults }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.searchWikiPages(searchText, project, maxResults);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wiki search results for '${searchText}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching wiki pages:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to search wiki pages: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-wiki-page",
        "code": "server.tool(\n  \"get-wiki-page\",\n  \"Get a specific wiki page with content from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier (ID or name)\"),\n    pagePath: z.string().describe(\"The path to the page (e.g., '/Setup/Authentication')\"),\n    includeContent: z.boolean().optional().describe(\"Include page content (default: true)\"),\n  },\n  async ({ project, wikiId, pagePath, includeContent }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWikiPage(project, wikiId, pagePath, includeContent ?? true);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get wiki page: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-wiki-page",
        "code": "server.tool(\n  \"create-wiki-page\",\n  \"Create a new wiki page in Azure DevOps (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path for the new page (e.g., '/Setup/NewGuide')\"),\n    content: z.string().describe(\"The markdown content for the page\"),\n  },\n  async ({ project, wikiId, pagePath, content }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.createWikiPage(project, wikiId, pagePath, content);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Created wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create wiki page: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-wiki-page",
        "code": "server.tool(\n  \"update-wiki-page\",\n  \"Update an existing wiki page in Azure DevOps (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path to the page\"),\n    content: z.string().describe(\"The updated markdown content\"),\n    version: z.string().optional().describe(\"The ETag/version for optimistic concurrency\"),\n  },\n  async ({ project, wikiId, pagePath, content, version }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.updateWikiPage(project, wikiId, pagePath, content, version);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Updated wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to update wiki page: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "azuredevops-str-replace-wiki-page",
        "code": "server.tool(\n  \"azuredevops-str-replace-wiki-page\",\n  \"Replace a specific string in an Azure DevOps wiki page without rewriting entire content. More efficient than update-wiki-page for small changes. (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier (ID or name)\"),\n    pagePath: z.string().describe(\"The path to the wiki page (e.g., '/SharePoint-Online/04-DEV-Configuration')\"),\n    old_str: z.string().describe(\"The exact string to replace (must be unique unless replace_all is true)\"),\n    new_str: z.string().describe(\"The replacement string\"),\n    replace_all: z.boolean().optional().describe(\"If true, replace all occurrences. If false (default), old_str must be unique in the page.\"),\n    description: z.string().optional().describe(\"Optional description of the change (for audit logging)\")\n  },\n  async ({ project, wikiId, pagePath, old_str, new_str, replace_all, description }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.strReplaceWikiPage(\n        project,\n        wikiId,\n        pagePath,\n        old_str,\n        new_str,\n        replace_all ?? false,\n        description\n      );\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Successfully replaced \"${old_str}\" with \"${new_str}\" in wiki page '${pagePath}' (${result.occurrences} occurrence(s)):\\n\\n${resultStr}\\n\\nDiff:\\n${result.diff}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error replacing text in wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to replace text in wiki page: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-work-item",
        "code": "server.tool(\n  \"get-work-item\",\n  \"Get a work item by ID with full details from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWorkItem(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-work-items",
        "code": "server.tool(\n  \"query-work-items\",\n  \"Query work items using WIQL (Work Item Query Language) in Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wiql: z.string().describe(\"The WIQL query string (e.g., \\\"SELECT [System.Id], [System.Title] FROM WorkItems WHERE [System.State] = 'Active'\\\")\"),\n    maxResults: z.number().optional().describe(\"Maximum number of results (default: 200)\"),\n  },\n  async ({ project, wiql, maxResults }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.queryWorkItems(project, wiql, maxResults);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Work items query results:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error querying work items:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to query work items: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-work-item-comments",
        "code": "server.tool(\n  \"get-work-item-comments\",\n  \"Get comments/discussion for a work item in Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWorkItemComments(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Comments for work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting work item comments:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get work item comments: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "add-work-item-comment",
        "code": "server.tool(\n  \"add-work-item-comment\",\n  \"Add a comment to a work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n    commentText: z.string().describe(\"The comment text (supports markdown)\"),\n  },\n  async ({ project, workItemId, commentText }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.addWorkItemComment(project, workItemId, commentText);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Added comment to work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error adding work item comment:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to add work item comment: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-work-item",
        "code": "server.tool(\n  \"update-work-item\",\n  \"Update a work item in Azure DevOps using JSON Patch operations (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n    patchOperations: z.array(z.object({\n      op: z.string().describe(\"The operation type (e.g., 'add', 'replace', 'remove')\"),\n      path: z.string().describe(\"The field path (e.g., '/fields/System.State')\"),\n      value: z.any().optional().describe(\"The value to set (not required for 'remove' operation)\")\n    })).describe(\"Array of JSON Patch operations\"),\n  },\n  async ({ project, workItemId, patchOperations }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.updateWorkItem(project, workItemId, patchOperations);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Updated work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to update work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-work-item",
        "code": "server.tool(\n  \"create-work-item\",\n  \"Create a new work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemType: z.string().describe(\"The work item type (e.g., 'Bug', 'Task', 'User Story')\"),\n    fields: z.record(z.any()).describe(\"Object with field values (e.g., {\\\"System.Title\\\": \\\"Bug title\\\", \\\"System.Description\\\": \\\"Details\\\"})\"),\n  },\n  async ({ project, workItemType, fields }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.createWorkItem(project, workItemType, fields);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Created work item:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-work-item",
        "code": "server.tool(\n  \"delete-work-item\",\n  \"Delete a work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_DELETE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.deleteWorkItem(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Deleted work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to delete work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "figma": [
      {
        "name": "get-figma-data",
        "code": "server.tool(\n  \"get-figma-data\",\n  \"Get comprehensive Figma design data including layout, text, styles, and components. \" +\n  \"Fetches from Figma API and transforms into simplified, AI-friendly format. \" +\n  \"Can fetch entire files or specific nodes. Automatically deduplicates styles.\",\n  {\n    fileKey: z.string().describe(\n      \"Figma file key (alphanumeric string from URL). \" +\n      \"Example: From 'https://figma.com/file/ABC123/MyFile', use 'ABC123'\"\n    ),\n    nodeId: z.string().optional().describe(\n      \"Optional specific node ID(s) to fetch. Format: '1234:5678' or multiple '1:10;2:20'. \" +\n      \"If omitted, fetches entire file.\"\n    ),\n    depth: z.number().optional().describe(\n      \"Optional tree traversal depth limit. Useful for large files. \" +\n      \"Example: depth=3 stops after 3 levels of children.\"\n    ),\n  },\n  async ({ fileKey, nodeId, depth }) => {\n    try {\n      const service = getFigmaService();\n      const result = await service.getFigmaData(fileKey, nodeId, depth);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2)\n        }],\n        isError: false,\n      };\n    } catch (error: any) {\n      console.error(\"Error fetching Figma data:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to fetch Figma data: ${error.message}\\n\\n` +\n                `Troubleshooting:\\n` +\n                `1. Verify FIGMA_API_KEY or FIGMA_OAUTH_TOKEN is set\\n` +\n                `2. Check file key is correct (from Figma URL)\\n` +\n                `3. Ensure you have access to the file in Figma\\n` +\n                `4. For OAuth, check token hasn't expired`\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "download-figma-images",
        "code": "server.tool(\n  \"download-figma-images\",\n  \"Download and process images from Figma designs (Coming in v2)\",\n  {\n    fileKey: z.string().describe(\"Figma file key\"),\n    localPath: z.string().describe(\"Local path to save images\"),\n  },\n  async ({ fileKey, localPath }) => {\n    return {\n      content: [{\n        type: \"text\",\n        text: \"Image download functionality is planned for v2. \" +\n              \"This will include:\\n\" +\n              \"- Download PNG/SVG exports\\n\" +\n              \"- Crop images with Figma transforms\\n\" +\n              \"- Generate CSS dimension variables\\n\" +\n              \"- Support for image fills and rendered nodes\\n\\n\" +\n              \"For now, use get-figma-data to retrieve design metadata.\"\n      }],\n      isError: false,\n    };\n  }\n);"
      }
    ],
    "application-insights": [
      {
        "name": "appinsights-list-resources",
        "code": "server.tool(\n  \"appinsights-list-resources\",\n  \"List all configured Application Insights resources (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getApplicationInsightsService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(resources, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Application Insights resources:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to list Application Insights resources: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-metadata",
        "code": "server.tool(\n  \"appinsights-get-metadata\",\n  \"Get schema metadata (tables and columns) for an Application Insights resource\",\n  {\n    resourceId: z.string().describe(\"Resource ID (use appinsights-list-resources to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const metadata = await service.getMetadata(resourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(metadata, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Application Insights metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get metadata: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-execute-query",
        "code": "server.tool(\n  \"appinsights-execute-query\",\n  \"Execute a KQL (Kusto Query Language) query against Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    query: z.string().describe(\"KQL query string\"),\n    timespan: z.string().optional().describe(\"Time range (e.g., 'PT1H' for 1 hour, 'P1D' for 1 day, 'PT12H' for 12 hours)\"),\n  },\n  async ({ resourceId, query, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.executeQuery(resourceId, query, timespan);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error executing Application Insights query:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to execute query: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-exceptions",
        "code": "server.tool(\n  \"appinsights-get-exceptions\",\n  \"Get recent exceptions from Application Insights with timestamps, types, and messages\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getRecentExceptions(\n        resourceId,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Application Insights exceptions:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get exceptions: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-slow-requests",
        "code": "server.tool(\n  \"appinsights-get-slow-requests\",\n  \"Get slow HTTP requests (above duration threshold) from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    durationThresholdMs: z.number().optional().describe(\"Duration threshold in milliseconds (default: 5000)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, durationThresholdMs, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getSlowRequests(\n        resourceId,\n        durationThresholdMs || 5000,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting slow requests:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get slow requests: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-operation-performance",
        "code": "server.tool(\n  \"appinsights-get-operation-performance\",\n  \"Get performance summary by operation (request count, avg duration, percentiles)\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getOperationPerformance(\n        resourceId,\n        timespan || 'PT1H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting operation performance:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get operation performance: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-failed-dependencies",
        "code": "server.tool(\n  \"appinsights-get-failed-dependencies\",\n  \"Get failed dependency calls (external APIs, databases, etc.) from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getFailedDependencies(\n        resourceId,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting failed dependencies:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get failed dependencies: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-traces",
        "code": "server.tool(\n  \"appinsights-get-traces\",\n  \"Get diagnostic traces/logs from Application Insights filtered by severity level\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    severityLevel: z.number().optional().describe(\"Minimum severity level (0=Verbose, 1=Info, 2=Warning, 3=Error, 4=Critical) (default: 2)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, severityLevel, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getTracesBySeverity(\n        resourceId,\n        severityLevel ?? 2,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting traces:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get traces: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-availability",
        "code": "server.tool(\n  \"appinsights-get-availability\",\n  \"Get availability test results and uptime statistics from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT24H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getAvailabilityResults(\n        resourceId,\n        timespan || 'PT24H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting availability results:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get availability results: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-custom-events",
        "code": "server.tool(\n  \"appinsights-get-custom-events\",\n  \"Get custom application events from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    eventName: z.string().optional().describe(\"Filter by specific event name\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, eventName, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getCustomEvents(\n        resourceId,\n        eventName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting custom events:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get custom events: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "log-analytics": [
      {
        "name": "loganalytics-list-workspaces",
        "code": "server.tool(\n  \"loganalytics-list-workspaces\",\n  \"List all configured Log Analytics workspaces (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getLogAnalyticsService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(resources, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Log Analytics workspaces:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to list workspaces: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-metadata",
        "code": "server.tool(\n  \"loganalytics-get-metadata\",\n  \"Get schema metadata (tables and columns) for a Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID (use loganalytics-list-workspaces to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const metadata = await service.getMetadata(resourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(metadata, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Log Analytics metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get metadata: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-execute-query",
        "code": "server.tool(\n  \"loganalytics-execute-query\",\n  \"Execute a custom KQL query against Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    query: z.string().describe(\"KQL query string\"),\n    timespan: z.string().optional().describe(\"Time range (e.g., 'PT1H', 'P1D')\"),\n  },\n  async ({ resourceId, query, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.executeQuery(resourceId, query, timespan);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error executing Log Analytics query:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to execute query: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-recent-events",
        "code": "server.tool(\n  \"loganalytics-get-recent-events\",\n  \"Get recent events from a specific Log Analytics table\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    tableName: z.string().describe(\"Table name (e.g., 'FunctionAppLogs', 'traces', 'requests')\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getRecentEvents(\n        resourceId,\n        tableName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting recent events:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get recent events: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-search-logs",
        "code": "server.tool(\n  \"loganalytics-search-logs\",\n  \"Search logs by text content across tables or a specific table\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    searchText: z.string().describe(\"Text to search for\"),\n    tableName: z.string().optional().describe(\"Table name to search in (optional, searches all if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, searchText, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.searchLogs(\n        resourceId,\n        searchText,\n        tableName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to search logs: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-logs",
        "code": "server.tool(\n  \"loganalytics-get-function-logs\",\n  \"Get Azure Function logs from FunctionAppLogs table with optional filtering\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    severityLevel: z.number().optional().describe(\"Minimum severity level (0=Verbose, 1=Info, 2=Warning, 3=Error, 4=Critical)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, severityLevel, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionLogs(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        severityLevel,\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function logs: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-errors",
        "code": "server.tool(\n  \"loganalytics-get-function-errors\",\n  \"Get Azure Function error logs with exception details\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionErrors(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function errors:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function errors: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-stats",
        "code": "server.tool(\n  \"loganalytics-get-function-stats\",\n  \"Get execution statistics for Azure Functions (count, success rate, errors)\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name (optional, returns stats for all functions if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionStats(\n        resourceId,\n        functionName,\n        timespan || 'PT1H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function stats:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function stats: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-invocations",
        "code": "server.tool(\n  \"loganalytics-get-function-invocations\",\n  \"Get Azure Function invocation history from requests/traces tables\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionInvocations(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function invocations:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function invocations: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "azure-sql": [
      {
        "name": "sql-list-servers",
        "code": "server.tool(\n  \"sql-list-servers\",\n  \"List all configured SQL servers with active/inactive status\",\n  {},\n  async () => {\n    try {\n      const sqlService = getAzureSqlService();\n      const servers = await sqlService.listServers();\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(servers, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing servers: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-databases",
        "code": "server.tool(\n  \"sql-list-databases\",\n  \"List databases on a SQL server (configured or discovered)\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n  },\n  async ({ serverId }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const databases = await sqlService.listDatabases(serverId);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(databases, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing databases: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-test-connection",
        "code": "server.tool(\n  \"sql-test-connection\",\n  \"Test SQL Server connectivity and return connection information\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const result = await sqlService.testConnection(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error testing connection: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-tables",
        "code": "server.tool(\n  \"sql-list-tables\",\n  \"List all user tables in the database with row counts and sizes\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const tables = await sqlService.listTables(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(tables, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing tables: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-views",
        "code": "server.tool(\n  \"sql-list-views\",\n  \"List all views in the database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const views = await sqlService.listViews(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(views, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing views: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-stored-procedures",
        "code": "server.tool(\n  \"sql-list-stored-procedures\",\n  \"List all stored procedures in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const procedures = await sqlService.listStoredProcedures(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(procedures, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing stored procedures: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-triggers",
        "code": "server.tool(\n  \"sql-list-triggers\",\n  \"List all database triggers in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const triggers = await sqlService.listTriggers(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(triggers, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing triggers: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-functions",
        "code": "server.tool(\n  \"sql-list-functions\",\n  \"List all user-defined functions in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const functions = await sqlService.listFunctions(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(functions, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing functions: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-get-table-schema",
        "code": "server.tool(\n  \"sql-get-table-schema\",\n  \"Get detailed schema information for a table including columns, indexes, and foreign keys\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    tableName: z.string().describe(\"Table name (e.g., 'Users')\"),\n  },\n  async ({ serverId, database, schemaName, tableName }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const schema = await sqlService.getTableSchema(serverId, database, schemaName, tableName);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(schema, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error getting table schema: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-get-object-definition",
        "code": "server.tool(\n  \"sql-get-object-definition\",\n  \"Get the SQL definition for a view, stored procedure, function, or trigger\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    objectName: z.string().describe(\"Object name\"),\n    objectType: z.enum(['VIEW', 'PROCEDURE', 'FUNCTION', 'TRIGGER']).describe(\"Object type\"),\n  },\n  async ({ serverId, database, schemaName, objectName, objectType }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const definition = await sqlService.getObjectDefinition(serverId, database, schemaName, objectName, objectType);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(definition, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error getting object definition: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-execute-query",
        "code": "server.tool(\n  \"sql-execute-query\",\n  \"Execute a SELECT query against the Azure SQL Database (read-only, with result limits)\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    query: z.string().describe(\"SELECT query to execute (e.g., 'SELECT TOP 10 * FROM dbo.Users WHERE IsActive = 1')\"),\n  },\n  async ({ serverId, database, query }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const result = await sqlService.executeSelectQuery(serverId, database, query);\n\n      let text = JSON.stringify(result, null, 2);\n\n      if (result.truncated) {\n        text += `\\n\\nâš ï¸ WARNING: Results truncated to ${result.rowCount} rows. Add WHERE clause to filter results.`;\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text,\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error executing query: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      }
    ],
    "github-enterprise": [
      {
        "name": "ghe-list-repos",
        "code": "server.tool(\n  \"ghe-list-repos\",\n  \"List all configured GitHub Enterprise repositories (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const repos = service.getAllRepos();\n\n      const reposWithUrls = repos.map(r => ({\n        ...r,\n        url: `${GHE_CONFIG.baseUrl}/${r.owner}/${r.repo}`\n      }));\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Configured GitHub Enterprise Repositories\\n\\n` +\n            `**Total:** ${repos.length} repositories\\n` +\n            `**Active:** ${repos.filter(r => r.active).length}\\n\\n` +\n            JSON.stringify(reposWithUrls, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing GitHub Enterprise repositories:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list repositories: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Verify GHE_URL is set correctly\\n` +\n            `2. Verify GHE_PAT or GitHub App credentials are set\\n` +\n            `3. Verify GHE_REPOS is configured as JSON array\\n` +\n            `4. Check repository access permissions`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-branches",
        "code": "server.tool(\n  \"ghe-list-branches\",\n  \"List all branches for a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration (e.g., 'plugin-core')\"),\n    protectedOnly: z.boolean().optional().describe(\"Filter by protection status (true for protected branches only)\"),\n  },\n  async ({ repoId, protectedOnly }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const branches = await service.listBranches(repoId, protectedOnly);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branches for Repository: ${repoId}\\n\\n` +\n            `**Total:** ${branches.length} branches\\n\\n` +\n            formatBranchListAsMarkdown(branches)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing branches:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list branches: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-default-branch",
        "code": "server.tool(\n  \"ghe-get-default-branch\",\n  \"Auto-detect the default branch for a repository (handles typos, provides alternatives)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    userSpecified: z.string().optional().describe(\"User-specified branch name (overrides auto-detection)\"),\n  },\n  async ({ repoId, userSpecified }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.getDefaultBranch(repoId, userSpecified);\n\n      let output = `# Default Branch for Repository: ${repoId}\\n\\n`;\n      output += `**Selected Branch:** \\`${result.branch}\\`  \\n`;\n      output += `**Reason:** ${result.reason}  \\n`;\n      output += `**Confidence:** ${result.confidence}  \\n\\n`;\n\n      if (result.alternatives && result.alternatives.length > 0) {\n        output += `**Alternative Branches:**\\n`;\n        result.alternatives.slice(0, 5).forEach(alt => {\n          output += `- \\`${alt}\\`\\n`;\n        });\n        if (result.alternatives.length > 5) {\n          output += `- ... and ${result.alternatives.length - 5} more\\n`;\n        }\n      }\n\n      if (result.message) {\n        output += `\\n**Note:** ${result.message}\\n`;\n      }\n\n      return {\n        content: [{\n          type: \"text\",\n          text: output\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting default branch:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get default branch: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-file",
        "code": "server.tool(\n  \"ghe-get-file\",\n  \"Get file content from a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path (e.g., 'src/Plugins/ContactPlugin.cs')\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n  },\n  async ({ repoId, path, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const file = await service.getFile(repoId, path, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# File: ${path}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${file.branch}\\`  \\n` +\n            `**Size:** ${file.size} bytes  \\n` +\n            `**SHA:** \\`${file.sha}\\`  \\n\\n` +\n            `## Content\\n\\n\\`\\`\\`\\n${file.decodedContent}\\n\\`\\`\\``\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get file: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Verify file path is correct\\n` +\n            `2. Verify branch exists (or let auto-detection find it)\\n` +\n            `3. Check if file size exceeds GHE_MAX_FILE_SIZE (default: 1MB)`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-code",
        "code": "server.tool(\n  \"ghe-search-code\",\n  \"Search code across GitHub Enterprise repositories\",\n  {\n    query: z.string().describe(\"Search query (e.g., 'class ContactPlugin')\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository\"),\n    path: z.string().optional().describe(\"Filter by file path pattern\"),\n    extension: z.string().optional().describe(\"Filter by file extension (e.g., 'cs', 'js')\"),\n  },\n  async ({ query, repoId, path, extension }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchCode(query, repoId, path, extension);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatCodeSearchResultsAsMarkdown(results)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching code:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search code: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Simplify search query if too complex\\n` +\n            `2. Check rate limits if search fails\\n` +\n            `3. Verify repository access permissions`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-files",
        "code": "server.tool(\n  \"ghe-list-files\",\n  \"List files in a directory of a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().optional().describe(\"Directory path (default: root)\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n  },\n  async ({ repoId, path, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.listFiles(repoId, path, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Directory: ${path || '/'}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${result.branch}\\`  \\n\\n` +\n            formatDirectoryContentsAsMarkdown(result.contents)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing files:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list files: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-clear-cache",
        "code": "server.tool(\n  \"ghe-clear-cache\",\n  \"Clear cached GitHub Enterprise API responses (useful after pushing code updates)\",\n  {\n    pattern: z.string().optional().describe(\"Clear only cache entries matching this pattern (e.g., 'ContactPlugin.cs')\"),\n    repoId: z.string().optional().describe(\"Clear cache for specific repository only\"),\n  },\n  async ({ pattern, repoId }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const cleared = service.clearCache(pattern, repoId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… Cleared ${cleared} cache entries` +\n            (pattern ? ` matching pattern '${pattern}'` : '') +\n            (repoId ? ` for repository '${repoId}'` : '')\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error clearing cache:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to clear cache: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commits",
        "code": "server.tool(\n  \"ghe-get-commits\",\n  \"Get commit history for a branch in a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    since: z.string().optional().describe(\"ISO 8601 date (e.g., '2025-01-01T00:00:00Z')\"),\n    until: z.string().optional().describe(\"ISO 8601 date\"),\n    author: z.string().optional().describe(\"Filter by author\"),\n    path: z.string().optional().describe(\"Filter by file path\"),\n    limit: z.number().optional().describe(\"Max commits (default: 50)\"),\n  },\n  async ({ repoId, branch, since, until, author, path, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commits = await service.getCommits(repoId, branch, since, until, author, path, limit || 50);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit History\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Count:** ${commits.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(commits)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commits:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commits: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commit-details",
        "code": "server.tool(\n  \"ghe-get-commit-details\",\n  \"Get detailed information about a specific commit in a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    sha: z.string().describe(\"Commit SHA\"),\n  },\n  async ({ repoId, sha }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commit = await service.getCommitDetails(repoId, sha);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatCommitDetailsAsMarkdown(commit)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commit details:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commit details: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-commits",
        "code": "server.tool(\n  \"ghe-search-commits\",\n  \"Search commits by message or hash (supports work item references like '#1234')\",\n  {\n    query: z.string().describe(\"Search query (e.g., '#1234', 'fix bug')\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository\"),\n    author: z.string().optional().describe(\"Filter by author\"),\n    since: z.string().optional().describe(\"ISO 8601 date\"),\n    until: z.string().optional().describe(\"ISO 8601 date\"),\n  },\n  async ({ query, repoId, author, since, until }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchCommits(query, repoId, author, since, until);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit Search Results\\n\\n` +\n            `**Query:** ${query}  \\n` +\n            `**Total Results:** ${results.total_count}  \\n` +\n            `**Showing:** ${results.items.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(results.items)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching commits:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search commits: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commit-diff",
        "code": "server.tool(\n  \"ghe-get-commit-diff\",\n  \"Get detailed diff for a commit in unified format\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    sha: z.string().describe(\"Commit SHA\"),\n    format: z.enum(['diff', 'patch']).optional().describe(\"Format: 'diff' or 'patch' (default: 'diff')\"),\n  },\n  async ({ repoId, sha, format }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const diff = await service.getCommitDiff(repoId, sha, format || 'diff');\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit Diff: ${sha}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Format:** ${format || 'diff'}  \\n\\n` +\n            `\\`\\`\\`diff\\n${diff}\\n\\`\\`\\``\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commit diff:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commit diff: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-compare-branches",
        "code": "server.tool(\n  \"ghe-compare-branches\",\n  \"Compare two branches and show differences\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    base: z.string().describe(\"Base branch name\"),\n    head: z.string().describe(\"Head branch name\"),\n  },\n  async ({ repoId, base, head }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const comparison = await service.compareBranches(repoId, base, head);\n\n      const insights = analyzeBranchComparison(comparison);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branch Comparison: ${base} â† ${head}\\n\\n` +\n            `**Repository:** ${repoId}  \\n\\n` +\n            `## Summary\\n\\n` +\n            insights.join('\\n') + '\\n\\n' +\n            `## Commits (${comparison.commits.length})\\n\\n` +\n            formatCommitHistoryAsMarkdown(comparison.commits.slice(0, 10))\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error comparing branches:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to compare branches: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-branch-details",
        "code": "server.tool(\n  \"ghe-get-branch-details\",\n  \"Get detailed information about a specific branch\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branch: z.string().describe(\"Branch name\"),\n  },\n  async ({ repoId, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const branchInfo = await service.getBranchDetails(repoId, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branch Details: ${branch}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Protected:** ${branchInfo.protected ? 'ðŸ”’ Yes' : 'No'}  \\n` +\n            `**Last Commit:** \\`${branchInfo.commit.sha.substring(0, 7)}\\`  \\n` +\n            `**Commit Message:** ${branchInfo.commit.commit.message.split('\\n')[0]}  \\n` +\n            `**Author:** ${branchInfo.commit.commit.author.name}  \\n` +\n            `**Date:** ${new Date(branchInfo.commit.commit.author.date).toLocaleString()}  \\n\\n` +\n            JSON.stringify(branchInfo, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting branch details:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get branch details: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-pull-requests",
        "code": "server.tool(\n  \"ghe-list-pull-requests\",\n  \"List pull requests for a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    state: z.enum(['open', 'closed', 'all']).optional().describe(\"PR state (default: 'open')\"),\n    base: z.string().optional().describe(\"Filter by base branch\"),\n    head: z.string().optional().describe(\"Filter by head branch\"),\n    sort: z.enum(['created', 'updated', 'popularity']).optional().describe(\"Sort order (default: 'created')\"),\n    limit: z.number().optional().describe(\"Max results (default: 30)\"),\n  },\n  async ({ repoId, state, base, head, sort, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const prs = await service.listPullRequests(repoId, state || 'open', base, head, sort || 'created', limit || 30);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Pull Requests\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**State:** ${state || 'open'}  \\n` +\n            `**Count:** ${prs.length}\\n\\n` +\n            formatPullRequestsAsMarkdown(prs)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing pull requests:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list pull requests: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-pull-request",
        "code": "server.tool(\n  \"ghe-get-pull-request\",\n  \"Get detailed information about a specific pull request\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    prNumber: z.number().describe(\"Pull request number\"),\n  },\n  async ({ repoId, prNumber }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const pr = await service.getPullRequest(repoId, prNumber);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatPullRequestDetailsAsMarkdown(pr)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting pull request:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get pull request: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-pr-files",
        "code": "server.tool(\n  \"ghe-get-pr-files\",\n  \"Get files changed in a pull request\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    prNumber: z.number().describe(\"Pull request number\"),\n  },\n  async ({ repoId, prNumber }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const files = await service.getPullRequestFiles(repoId, prNumber);\n\n      const header = '| File | Status | +/- | Changes |';\n      const separator = '|------|--------|-----|---------|';\n\n      const rows = files.map(f => {\n        const status = f.status === 'added' ? 'ðŸ†• Added' :\n                       f.status === 'modified' ? 'ðŸ“ Modified' :\n                       f.status === 'removed' ? 'ðŸ—‘ï¸ Removed' :\n                       f.status === 'renamed' ? 'ðŸ“‹ Renamed' : f.status;\n\n        return `| \\`${f.filename}\\` | ${status} | +${f.additions}/-${f.deletions} | ${f.changes} |`;\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Pull Request #${prNumber} - Files Changed\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Total Files:** ${files.length}\\n\\n` +\n            [header, separator, ...rows].join('\\n')\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting PR files:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get PR files: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-directory-structure",
        "code": "server.tool(\n  \"ghe-get-directory-structure\",\n  \"Get recursive directory tree structure\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().optional().describe(\"Directory path (default: root)\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    depth: z.number().optional().describe(\"Recursion depth limit (default: 3)\"),\n  },\n  async ({ repoId, path, branch, depth }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.getDirectoryStructure(repoId, path, branch, depth || 3);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Directory Structure: ${path || '/'}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${result.branch}\\`  \\n` +\n            `**Max Depth:** ${depth || 3}\\n\\n` +\n            '```\\n' + formatFileTreeAsMarkdown(result.tree) + '\\n```'\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting directory structure:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get directory structure: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-file-history",
        "code": "server.tool(\n  \"ghe-get-file-history\",\n  \"Get commit history for a specific file\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    limit: z.number().optional().describe(\"Max commits (default: 50)\"),\n  },\n  async ({ repoId, path, branch, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commits = await service.getFileHistory(repoId, path, branch, limit || 50);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# File History: ${path}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Commits:** ${commits.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(commits)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting file history:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get file history: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-create-branch",
        "code": "server.tool(\n  \"ghe-create-branch\",\n  \"Create a new branch (requires GHE_ENABLE_CREATE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branchName: z.string().describe(\"New branch name\"),\n    fromBranch: z.string().optional().describe(\"Source branch (default: auto-detected)\"),\n  },\n  async ({ repoId, branchName, fromBranch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.createBranch(repoId, branchName, fromBranch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… Branch '${branchName}' created successfully\\n\\n` +\n            JSON.stringify(result, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating branch:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to create branch: ${error.message}\\n\\n` +\n            `Note: Branch creation requires GHE_ENABLE_CREATE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-update-file",
        "code": "server.tool(\n  \"ghe-update-file\",\n  \"Update file content (requires GHE_ENABLE_WRITE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    content: z.string().describe(\"New file content\"),\n    message: z.string().describe(\"Commit message\"),\n    branch: z.string().describe(\"Branch name\"),\n    sha: z.string().describe(\"Current file SHA (for conflict detection)\"),\n  },\n  async ({ repoId, path, content, message, branch, sha }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.updateFile(repoId, path, content, message, branch, sha);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… File '${path}' updated successfully\\n\\n` +\n            `**Commit SHA:** \\`${result.commit.sha}\\`  \\n` +\n            `**Branch:** \\`${branch}\\`  \\n` +\n            `**Message:** ${message}`\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to update file: ${error.message}\\n\\n` +\n            `Note: File updates require GHE_ENABLE_WRITE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-create-file",
        "code": "server.tool(\n  \"ghe-create-file\",\n  \"Create a new file (requires GHE_ENABLE_CREATE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    content: z.string().describe(\"File content\"),\n    message: z.string().describe(\"Commit message\"),\n    branch: z.string().describe(\"Branch name\"),\n  },\n  async ({ repoId, path, content, message, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.createFile(repoId, path, content, message, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… File '${path}' created successfully\\n\\n` +\n            `**Commit SHA:** \\`${result.commit.sha}\\`  \\n` +\n            `**Branch:** \\`${branch}\\`  \\n` +\n            `**Message:** ${message}`\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to create file: ${error.message}\\n\\n` +\n            `Note: File creation requires GHE_ENABLE_CREATE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-repos",
        "code": "server.tool(\n  \"ghe-search-repos\",\n  \"Search repositories by name or description across GitHub Enterprise\",\n  {\n    query: z.string().describe(\"Search query\"),\n    owner: z.string().optional().describe(\"Filter by organization/owner\"),\n  },\n  async ({ query, owner }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchRepositories(query, owner);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Repository Search Results\\n\\n` +\n            `**Query:** ${query}  \\n` +\n            `**Total Results:** ${results.total_count}  \\n` +\n            `**Showing:** ${results.items.length}\\n\\n` +\n            JSON.stringify(results.items, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching repositories:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search repositories: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      }
    ],
    "service-bus": [
      {
        "name": "servicebus-list-namespaces",
        "code": "server.tool(\n  \"servicebus-list-namespaces\",\n  \"List all configured Service Bus namespaces (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getServiceBusService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(resources, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Service Bus namespaces:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list namespaces: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-test-connection",
        "code": "server.tool(\n  \"servicebus-test-connection\",\n  \"Test connectivity to a Service Bus namespace and verify permissions (Data Receiver + Reader roles)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID (use servicebus-list-namespaces to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const result = await service.testConnection(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error testing Service Bus connection:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to test connection: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-list-queues",
        "code": "server.tool(\n  \"servicebus-list-queues\",\n  \"List all queues in a Service Bus namespace with message counts and session info (cached for 5 minutes)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const queues = await service.listQueues(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(queues, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Service Bus queues:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list queues: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-peek-messages",
        "code": "server.tool(\n  \"servicebus-peek-messages\",\n  \"Peek messages in a queue without removing them (read-only, max 100 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to peek (default: 10, max: 100)\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n  },\n  async ({ resourceId, queueName, maxMessages, sessionId }) => {\n    try {\n      const service = getServiceBusService();\n      const messages = await service.peekMessages(resourceId, queueName, maxMessages || 10, sessionId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(messages, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error peeking messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to peek messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-peek-deadletter",
        "code": "server.tool(\n  \"servicebus-peek-deadletter\",\n  \"Peek dead letter queue messages with failure reasons (read-only, max 100 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to peek (default: 10, max: 100)\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n  },\n  async ({ resourceId, queueName, maxMessages, sessionId }) => {\n    try {\n      const service = getServiceBusService();\n      const messages = await service.peekDeadLetterMessages(resourceId, queueName, maxMessages || 10, sessionId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(messages, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error peeking dead letter messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to peek dead letter messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-get-queue-properties",
        "code": "server.tool(\n  \"servicebus-get-queue-properties\",\n  \"Get detailed queue properties, metrics, and configuration including session info\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n  },\n  async ({ resourceId, queueName }) => {\n    try {\n      const service = getServiceBusService();\n      const properties = await service.getQueueProperties(resourceId, queueName);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(properties, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting queue properties:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get queue properties: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-search-messages",
        "code": "server.tool(\n  \"servicebus-search-messages\",\n  \"Search messages by content or properties (loads into memory, max 500 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    bodyContains: z.string().optional().describe(\"Search for text in message body (case-insensitive)\"),\n    correlationId: z.string().optional().describe(\"Filter by correlation ID\"),\n    messageId: z.string().optional().describe(\"Filter by message ID\"),\n    propertyKey: z.string().optional().describe(\"Application property key to filter by\"),\n    propertyValue: z.any().optional().describe(\"Application property value to match\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to search (default: 50, max: 500)\"),\n  },\n  async ({ resourceId, queueName, bodyContains, correlationId, messageId, propertyKey, propertyValue, sessionId, maxMessages }) => {\n    try {\n      const service = getServiceBusService();\n      const result = await service.searchMessages(\n        resourceId,\n        queueName,\n        { bodyContains, correlationId, messageId, propertyKey, propertyValue, sessionId },\n        maxMessages || 50\n      );\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-get-namespace-properties",
        "code": "server.tool(\n  \"servicebus-get-namespace-properties\",\n  \"Get namespace-level properties and quotas (tier, max message size)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const properties = await service.getNamespaceProperties(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(properties, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting namespace properties:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get namespace properties: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      }
    ]
  },
  "prompts": {
    "powerplatform": [
      {
        "name": "entity-overview",
        "code": "server.prompt(\n  \"entity-overview\", \n  \"Get an overview of a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\")\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get entity metadata and key attributes\n      const [metadata, attributes] = await Promise.all([\n        service.getEntityMetadata(entityName),\n        service.getEntityAttributes(entityName)\n      ]);\n      \n      // Format entity details\n      const entityDetails = `- Display Name: ${metadata.DisplayName?.UserLocalizedLabel?.Label || entityName}\\n` +\n        `- Schema Name: ${metadata.SchemaName}\\n` +\n        `- Description: ${metadata.Description?.UserLocalizedLabel?.Label || 'No description'}\\n` +\n        `- Primary Key: ${metadata.PrimaryIdAttribute}\\n` +\n        `- Primary Name: ${metadata.PrimaryNameAttribute}`;\n        \n      // Get key attributes\n      const keyAttributes = attributes.value\n        .map((attr: any) => {\n          const attrType = attr[\"@odata.type\"] || attr.odata?.type || \"Unknown type\";\n          return `- ${attr.LogicalName}: ${attrType}`;\n        })\n        .join('\\n');\n        \n      // Get relationships summary\n      const relationships = await service.getEntityRelationships(entityName);\n      const oneToManyCount = relationships.oneToMany.value.length;\n      const manyToManyCount = relationships.manyToMany.value.length;\n      \n      const relationshipsSummary = `- One-to-Many Relationships: ${oneToManyCount}\\n` +\n                                  `- Many-to-Many Relationships: ${manyToManyCount}`;\n      \n      let promptContent = powerPlatformPrompts.ENTITY_OVERVIEW(entityName);\n      promptContent = promptContent\n        .replace('{{entity_details}}', entityDetails)\n        .replace('{{key_attributes}}', keyAttributes)\n        .replace('{{relationships}}', relationshipsSummary);\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling entity-overview prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "attribute-details",
        "code": "server.prompt(\n  \"attribute-details\",\n  \"Get detailed information about a specific entity attribute/field\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    attributeName: z.string().describe(\"The logical name of the attribute\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const { entityName, attributeName } = args;\n      \n      // Get attribute details\n      const attribute = await service.getEntityAttribute(entityName, attributeName);\n      \n      // Format attribute details\n      const attrDetails = `- Display Name: ${attribute.DisplayName?.UserLocalizedLabel?.Label || attributeName}\\n` +\n        `- Description: ${attribute.Description?.UserLocalizedLabel?.Label || 'No description'}\\n` +\n        `- Type: ${attribute.AttributeType}\\n` +\n        `- Format: ${attribute.Format || 'N/A'}\\n` +\n        `- Is Required: ${attribute.RequiredLevel?.Value || 'No'}\\n` +\n        `- Is Searchable: ${attribute.IsValidForAdvancedFind || false}`;\n        \n      let promptContent = powerPlatformPrompts.ATTRIBUTE_DETAILS(entityName, attributeName);\n      promptContent = promptContent\n        .replace('{{attribute_details}}', attrDetails)\n        .replace('{{data_type}}', attribute.AttributeType)\n        .replace('{{required}}', attribute.RequiredLevel?.Value || 'No')\n        .replace('{{max_length}}', attribute.MaxLength || 'N/A');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling attribute-details prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-template",
        "code": "server.prompt(\n  \"query-template\",\n  \"Get a template for querying a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get entity metadata to determine plural name\n      const metadata = await service.getEntityMetadata(entityName);\n      const entityNamePlural = metadata.EntitySetName;\n      \n      // Get a few important fields for the select example\n      const attributes = await service.getEntityAttributes(entityName);\n      const selectFields = attributes.value\n        .filter((attr: any) => attr.IsValidForRead === true && !attr.AttributeOf)\n        .slice(0, 5) // Just take first 5 for example\n        .map((attr: any) => attr.LogicalName)\n        .join(',');\n        \n      let promptContent = powerPlatformPrompts.QUERY_TEMPLATE(entityNamePlural);\n      promptContent = promptContent\n        .replace('{{selected_fields}}', selectFields)\n        .replace('{{filter_conditions}}', `${metadata.PrimaryNameAttribute} eq 'Example'`)\n        .replace('{{order_by}}', `${metadata.PrimaryNameAttribute} asc`)\n        .replace('{{max_records}}', '50');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling query-template prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "relationship-map",
        "code": "server.prompt(\n  \"relationship-map\",\n  \"Get a list of relationships for a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get relationships\n      const relationships = await service.getEntityRelationships(entityName);\n      \n      // Format one-to-many relationships where this entity is primary\n      const oneToManyPrimary = relationships.oneToMany.value\n        .filter((rel: any) => rel.ReferencingEntity !== entityName)\n        .map((rel: any) => `- ${rel.SchemaName}: ${entityName} (1) â†’ ${rel.ReferencingEntity} (N)`)\n        .join('\\n');\n        \n      // Format one-to-many relationships where this entity is related\n      const oneToManyRelated = relationships.oneToMany.value\n        .filter((rel: any) => rel.ReferencingEntity === entityName)\n        .map((rel: any) => `- ${rel.SchemaName}: ${rel.ReferencedEntity} (1) â†’ ${entityName} (N)`)\n        .join('\\n');\n        \n      // Format many-to-many relationships\n      const manyToMany = relationships.manyToMany.value\n        .map((rel: any) => {\n          const otherEntity = rel.Entity1LogicalName === entityName ? rel.Entity2LogicalName : rel.Entity1LogicalName;\n          return `- ${rel.SchemaName}: ${entityName} (N) â†” ${otherEntity} (N)`;\n        })\n        .join('\\n');\n      \n      let promptContent = powerPlatformPrompts.RELATIONSHIP_MAP(entityName);\n      promptContent = promptContent\n        .replace('{{one_to_many_primary}}', oneToManyPrimary || 'None found')\n        .replace('{{one_to_many_related}}', oneToManyRelated || 'None found')\n        .replace('{{many_to_many}}', manyToMany || 'None found');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling relationship-map prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "plugin-deployment-report",
        "code": "server.prompt(\n  \"plugin-deployment-report\",\n  \"Generate a comprehensive deployment report for a plugin assembly\",\n  {\n    assemblyName: z.string().describe(\"The name of the plugin assembly\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblyComplete(args.assemblyName, false);\n\n      // Build markdown report\n      let report = `# Plugin Deployment Report: ${result.assembly.name}\\n\\n`;\n\n      report += `## Assembly Information\\n`;\n      report += `- **Version**: ${result.assembly.version}\\n`;\n      report += `- **Isolation Mode**: ${result.assembly.isolationmode === 2 ? 'Sandbox' : 'None'}\\n`;\n      report += `- **Source**: ${result.assembly.sourcetype === 0 ? 'Database' : result.assembly.sourcetype === 1 ? 'Disk' : 'GAC'}\\n`;\n      report += `- **Last Modified**: ${result.assembly.modifiedon} by ${result.assembly.modifiedby?.fullname || 'Unknown'}\\n`;\n      report += `- **Managed**: ${result.assembly.ismanaged ? 'Yes' : 'No'}\\n\\n`;\n\n      report += `## Plugin Types (${result.pluginTypes.length} total)\\n`;\n      result.pluginTypes.forEach((type: any, idx: number) => {\n        report += `${idx + 1}. ${type.typename}\\n`;\n      });\n      report += `\\n`;\n\n      report += `## Registered Steps (${result.steps.length} total)\\n\\n`;\n      result.steps.forEach((step: any) => {\n        const stageName = step.stage === 10 ? 'PreValidation' : step.stage === 20 ? 'PreOperation' : 'PostOperation';\n        const modeName = step.mode === 0 ? 'Sync' : 'Async';\n        const status = step.statuscode === 1 ? 'âœ“ Enabled' : 'âœ— Disabled';\n\n        report += `### ${step.sdkmessageid?.name || 'Unknown'} - ${step.sdkmessagefilterid?.primaryobjecttypecode || 'None'} (${stageName}, ${modeName}, Rank ${step.rank})\\n`;\n        report += `- **Plugin**: ${step.plugintypeid?.typename || 'Unknown'}\\n`;\n        report += `- **Status**: ${status}\\n`;\n        report += `- **Filtering Attributes**: ${step.filteringattributes || '(none - runs on all changes)'}\\n`;\n        report += `- **Deployment**: ${step.supporteddeployment === 0 ? 'Server Only' : step.supporteddeployment === 1 ? 'Offline Only' : 'Both'}\\n`;\n\n        if (step.images.length > 0) {\n          report += `- **Images**:\\n`;\n          step.images.forEach((img: any) => {\n            const imageType = img.imagetype === 0 ? 'PreImage' : img.imagetype === 1 ? 'PostImage' : 'Both';\n            report += `  - ${img.name} (${imageType}) â†’ Attributes: ${img.attributes || '(all)'}\\n`;\n          });\n        } else {\n          report += `- **Images**: None\\n`;\n        }\n        report += `\\n`;\n      });\n\n      report += `## Validation Results\\n\\n`;\n      if (result.validation.hasDisabledSteps) {\n        report += `âš  Some steps are disabled\\n`;\n      } else {\n        report += `âœ“ All steps are enabled\\n`;\n      }\n\n      if (result.validation.stepsWithoutFilteringAttributes.length > 0) {\n        report += `âš  Warning: ${result.validation.stepsWithoutFilteringAttributes.length} Update/Delete steps without filtering attributes:\\n`;\n        result.validation.stepsWithoutFilteringAttributes.forEach((name: string) => {\n          report += `  - ${name}\\n`;\n        });\n      } else {\n        report += `âœ“ All Update/Delete steps have filtering attributes\\n`;\n      }\n\n      if (result.validation.stepsWithoutImages.length > 0) {\n        report += `âš  Warning: ${result.validation.stepsWithoutImages.length} Update/Delete steps without images:\\n`;\n        result.validation.stepsWithoutImages.forEach((name: string) => {\n          report += `  - ${name}\\n`;\n        });\n      }\n\n      if (result.validation.potentialIssues.length > 0) {\n        report += `\\n### Potential Issues\\n`;\n        result.validation.potentialIssues.forEach((issue: string) => {\n          report += `- ${issue}\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating plugin deployment report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "entity-plugin-pipeline-report",
        "code": "server.prompt(\n  \"entity-plugin-pipeline-report\",\n  \"Generate a visual execution pipeline showing all plugins for an entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    messageFilter: z.string().optional().describe(\"Optional filter by message name\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getEntityPluginPipeline(args.entityName, args.messageFilter, false);\n\n      // Build markdown report\n      let report = `# Plugin Pipeline: ${result.entity} Entity\\n\\n`;\n\n      if (result.steps.length === 0) {\n        report += `No plugins registered for this entity.\\n`;\n      } else {\n        // Group by message\n        result.messages.forEach((msg: any) => {\n          report += `## ${msg.messageName} Message\\n\\n`;\n\n          // PreValidation stage\n          if (msg.stages.preValidation.length > 0) {\n            report += `### Stage 1: PreValidation (Synchronous)\\n`;\n            msg.stages.preValidation.forEach((step: any, idx: number) => {\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          // PreOperation stage\n          if (msg.stages.preOperation.length > 0) {\n            report += `### Stage 2: PreOperation (Synchronous)\\n`;\n            msg.stages.preOperation.forEach((step: any, idx: number) => {\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          // PostOperation stage\n          if (msg.stages.postOperation.length > 0) {\n            report += `### Stage 3: PostOperation\\n`;\n            msg.stages.postOperation.forEach((step: any, idx: number) => {\n              const mode = step.modeName === 'Asynchronous' ? ' (Async)' : ' (Sync)';\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}${mode}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          report += `---\\n\\n`;\n        });\n\n        report += `## Execution Order\\n\\n`;\n        report += `Plugins execute in this order:\\n`;\n        result.executionOrder.forEach((name: string, idx: number) => {\n          report += `${idx + 1}. ${name}\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating entity plugin pipeline report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "flows-report",
        "code": "server.prompt(\n  \"flows-report\",\n  \"Generate a comprehensive report of all Power Automate flows in the environment\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated flows (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlows(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Power Automate Flows Report\\n\\n`;\n      report += `**Total Flows**: ${result.totalCount}\\n\\n`;\n\n      if (result.flows.length === 0) {\n        report += `No flows found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeFlows = result.flows.filter((f: any) => f.state === 'Activated');\n        const draftFlows = result.flows.filter((f: any) => f.state === 'Draft');\n        const suspendedFlows = result.flows.filter((f: any) => f.state === 'Suspended');\n\n        if (activeFlows.length > 0) {\n          report += `## Active Flows (${activeFlows.length})\\n\\n`;\n          activeFlows.forEach((flow: any) => {\n            report += `### ${flow.name}\\n`;\n            report += `- **ID**: ${flow.workflowid}\\n`;\n            report += `- **Description**: ${flow.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${flow.primaryEntity || 'None'}\\n`;\n            report += `- **Owner**: ${flow.owner}\\n`;\n            report += `- **Modified**: ${flow.modifiedOn} by ${flow.modifiedBy}\\n`;\n            report += `- **Managed**: ${flow.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftFlows.length > 0) {\n          report += `## Draft Flows (${draftFlows.length})\\n\\n`;\n          draftFlows.forEach((flow: any) => {\n            report += `- **${flow.name}** (${flow.workflowid})\\n`;\n            report += `  - Owner: ${flow.owner}, Modified: ${flow.modifiedOn}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedFlows.length > 0) {\n          report += `## Suspended Flows (${suspendedFlows.length})\\n\\n`;\n          suspendedFlows.forEach((flow: any) => {\n            report += `- **${flow.name}** (${flow.workflowid})\\n`;\n            report += `  - Owner: ${flow.owner}, Modified: ${flow.modifiedOn}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating flows report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "workflows-report",
        "code": "server.prompt(\n  \"workflows-report\",\n  \"Generate a comprehensive report of all classic Dynamics workflows in the environment\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated workflows (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflows(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Classic Dynamics Workflows Report\\n\\n`;\n      report += `**Total Workflows**: ${result.totalCount}\\n\\n`;\n\n      if (result.workflows.length === 0) {\n        report += `No classic workflows found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeWorkflows = result.workflows.filter((w: any) => w.state === 'Activated');\n        const draftWorkflows = result.workflows.filter((w: any) => w.state === 'Draft');\n        const suspendedWorkflows = result.workflows.filter((w: any) => w.state === 'Suspended');\n\n        if (activeWorkflows.length > 0) {\n          report += `## Active Workflows (${activeWorkflows.length})\\n\\n`;\n          activeWorkflows.forEach((workflow: any) => {\n            report += `### ${workflow.name}\\n`;\n            report += `- **ID**: ${workflow.workflowid}\\n`;\n            report += `- **Description**: ${workflow.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${workflow.primaryEntity || 'None'}\\n`;\n            report += `- **Mode**: ${workflow.mode}\\n`;\n            report += `- **Triggers**:\\n`;\n            if (workflow.triggerOnCreate) report += `  - Create\\n`;\n            if (workflow.triggerOnDelete) report += `  - Delete\\n`;\n            if (workflow.isOnDemand) report += `  - On Demand\\n`;\n            report += `- **Owner**: ${workflow.owner}\\n`;\n            report += `- **Modified**: ${workflow.modifiedOn} by ${workflow.modifiedBy}\\n`;\n            report += `- **Managed**: ${workflow.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftWorkflows.length > 0) {\n          report += `## Draft Workflows (${draftWorkflows.length})\\n\\n`;\n          draftWorkflows.forEach((workflow: any) => {\n            report += `- **${workflow.name}** (${workflow.workflowid})\\n`;\n            report += `  - Entity: ${workflow.primaryEntity}, Owner: ${workflow.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedWorkflows.length > 0) {\n          report += `## Suspended Workflows (${suspendedWorkflows.length})\\n\\n`;\n          suspendedWorkflows.forEach((workflow: any) => {\n            report += `- **${workflow.name}** (${workflow.workflowid})\\n`;\n            report += `  - Entity: ${workflow.primaryEntity}, Owner: ${workflow.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating workflows report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "business-rules-report",
        "code": "server.prompt(\n  \"business-rules-report\",\n  \"Generate a comprehensive report of all business rules in the environment (read-only for troubleshooting)\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated business rules (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRules(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Business Rules Report\\n\\n`;\n      report += `**Total Business Rules**: ${result.totalCount}\\n\\n`;\n\n      if (result.businessRules.length === 0) {\n        report += `No business rules found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeRules = result.businessRules.filter((r: any) => r.state === 'Activated');\n        const draftRules = result.businessRules.filter((r: any) => r.state === 'Draft');\n        const suspendedRules = result.businessRules.filter((r: any) => r.state === 'Suspended');\n\n        if (activeRules.length > 0) {\n          report += `## Active Business Rules (${activeRules.length})\\n\\n`;\n          activeRules.forEach((rule: any) => {\n            report += `### ${rule.name}\\n`;\n            report += `- **ID**: ${rule.workflowid}\\n`;\n            report += `- **Description**: ${rule.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${rule.primaryEntity || 'None'}\\n`;\n            report += `- **Owner**: ${rule.owner}\\n`;\n            report += `- **Modified**: ${rule.modifiedOn} by ${rule.modifiedBy}\\n`;\n            report += `- **Managed**: ${rule.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftRules.length > 0) {\n          report += `## Draft Business Rules (${draftRules.length})\\n\\n`;\n          draftRules.forEach((rule: any) => {\n            report += `- **${rule.name}** (${rule.workflowid})\\n`;\n            report += `  - Entity: ${rule.primaryEntity}, Owner: ${rule.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedRules.length > 0) {\n          report += `## Suspended Business Rules (${suspendedRules.length})\\n\\n`;\n          suspendedRules.forEach((rule: any) => {\n            report += `- **${rule.name}** (${rule.workflowid})\\n`;\n            report += `  - Entity: ${rule.primaryEntity}, Owner: ${rule.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      report += `\\n---\\n\\n`;\n      report += `*Note: Business rules are read-only in this MCP server. Use the PowerPlatform UI to create or modify business rules.*\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating business rules report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      }
    ],
    "azure-devops": [
      {
        "name": "wiki-search-results",
        "code": "server.prompt(\n  \"wiki-search-results\",\n  \"Search Azure DevOps wiki pages and get formatted results with content snippets\",\n  {\n    searchText: z.string().describe(\"The text to search for\"),\n    project: z.string().optional().describe(\"Optional project filter\"),\n    maxResults: z.string().optional().describe(\"Maximum number of results (default: 25)\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { searchText, project, maxResults } = args;\n      const maxResultsNum = maxResults ? parseInt(maxResults, 10) : undefined;\n      const result = await service.searchWikiPages(searchText, project, maxResultsNum);\n\n      let report = `# Wiki Search Results: \"${searchText}\"\\n\\n`;\n      report += `**Project:** ${project || 'All allowed projects'}\\n`;\n      report += `**Total Results:** ${result.totalCount}\\n\\n`;\n\n      if (result.results && result.results.length > 0) {\n        report += `## Results\\n\\n`;\n        result.results.forEach((item: any, index: number) => {\n          report += `### ${index + 1}. ${item.fileName}\\n`;\n          report += `- **Path:** ${item.path}\\n`;\n          report += `- **Wiki:** ${item.wikiName}\\n`;\n          report += `- **Project:** ${item.project}\\n`;\n          if (item.highlights && item.highlights.length > 0) {\n            report += `- **Highlights:**\\n`;\n            item.highlights.forEach((highlight: string) => {\n              // Remove HTML tags for cleaner display\n              const cleanHighlight = highlight.replace(/<[^>]*>/g, '');\n              report += `  - ${cleanHighlight}\\n`;\n            });\n          }\n          report += `\\n`;\n        });\n      } else {\n        report += `No results found for \"${searchText}\".\\n`;\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating wiki search results:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "wiki-page-content",
        "code": "server.prompt(\n  \"wiki-page-content\",\n  \"Get a formatted wiki page with navigation context from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path to the page\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, wikiId, pagePath } = args;\n      const result = await service.getWikiPage(project, wikiId, pagePath, true);\n\n      let report = `# Wiki Page: ${pagePath}\\n\\n`;\n      report += `**Project:** ${project}\\n`;\n      report += `**Wiki:** ${wikiId}\\n`;\n      report += `**Git Path:** ${result.gitItemPath || 'N/A'}\\n\\n`;\n\n      if (result.subPages && result.subPages.length > 0) {\n        report += `## Sub-pages\\n`;\n        result.subPages.forEach((subPage: any) => {\n          report += `- ${subPage.path}\\n`;\n        });\n        report += `\\n`;\n      }\n\n      report += `## Content\\n\\n`;\n      report += result.content || '*No content available*';\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating wiki page content:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "work-item-summary",
        "code": "server.prompt(\n  \"work-item-summary\",\n  \"Get a comprehensive summary of a work item with comments from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.string().describe(\"The work item ID\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, workItemId } = args;\n      const workItemIdNum = parseInt(workItemId, 10);\n\n      // Get work item and comments in parallel\n      const [workItem, comments] = await Promise.all([\n        service.getWorkItem(project, workItemIdNum),\n        service.getWorkItemComments(project, workItemIdNum)\n      ]);\n\n      const fields = workItem.fields || {};\n\n      let report = `# Work Item #${workItemId}: ${fields['System.Title'] || 'Untitled'}\\n\\n`;\n\n      report += `## Details\\n`;\n      report += `- **Type:** ${fields['System.WorkItemType'] || 'N/A'}\\n`;\n      report += `- **State:** ${fields['System.State'] || 'N/A'}\\n`;\n      report += `- **Assigned To:** ${fields['System.AssignedTo']?.displayName || 'Unassigned'}\\n`;\n      report += `- **Created By:** ${fields['System.CreatedBy']?.displayName || 'N/A'}\\n`;\n      report += `- **Created Date:** ${fields['System.CreatedDate'] || 'N/A'}\\n`;\n      report += `- **Changed Date:** ${fields['System.ChangedDate'] || 'N/A'}\\n`;\n      report += `- **Area Path:** ${fields['System.AreaPath'] || 'N/A'}\\n`;\n      report += `- **Iteration Path:** ${fields['System.IterationPath'] || 'N/A'}\\n`;\n      if (fields['System.Tags']) {\n        report += `- **Tags:** ${fields['System.Tags']}\\n`;\n      }\n      report += `\\n`;\n\n      if (fields['System.Description']) {\n        report += `## Description\\n${fields['System.Description']}\\n\\n`;\n      }\n\n      if (fields['Microsoft.VSTS.TCM.ReproSteps']) {\n        report += `## Repro Steps\\n${fields['Microsoft.VSTS.TCM.ReproSteps']}\\n\\n`;\n      }\n\n      if (workItem.relations && workItem.relations.length > 0) {\n        report += `## Related Items\\n`;\n        workItem.relations.forEach((relation: any) => {\n          report += `- ${relation.rel}: ${relation.url}\\n`;\n        });\n        report += `\\n`;\n      }\n\n      if (comments.comments && comments.comments.length > 0) {\n        report += `## Comments (${comments.totalCount})\\n\\n`;\n        comments.comments.forEach((comment: any) => {\n          report += `### ${comment.createdBy} - ${new Date(comment.createdDate).toLocaleString()}\\n`;\n          report += `${comment.text}\\n\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating work item summary:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "work-items-query-report",
        "code": "server.prompt(\n  \"work-items-query-report\",\n  \"Execute a WIQL query and get formatted results grouped by state/type\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wiql: z.string().describe(\"The WIQL query string\"),\n    maxResults: z.string().optional().describe(\"Maximum number of results (default: 200)\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, wiql, maxResults } = args;\n      const maxResultsNum = maxResults ? parseInt(maxResults, 10) : undefined;\n      const result = await service.queryWorkItems(project, wiql, maxResultsNum);\n\n      let report = `# Work Items Query Results\\n\\n`;\n      report += `**Project:** ${project}\\n`;\n      report += `**Total Results:** ${result.totalCount}\\n\\n`;\n\n      if (result.workItems && result.workItems.length > 0) {\n        // Group by state\n        const groupedByState = new Map<string, any[]>();\n        result.workItems.forEach((item: any) => {\n          const state = item.fields['System.State'] || 'Unknown';\n          if (!groupedByState.has(state)) {\n            groupedByState.set(state, []);\n          }\n          groupedByState.get(state)!.push(item);\n        });\n\n        // Sort states: Active, Resolved, Closed, others\n        const stateOrder = ['Active', 'New', 'Resolved', 'Closed'];\n        const sortedStates = Array.from(groupedByState.keys()).sort((a, b) => {\n          const aIndex = stateOrder.indexOf(a);\n          const bIndex = stateOrder.indexOf(b);\n          if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);\n          if (aIndex === -1) return 1;\n          if (bIndex === -1) return -1;\n          return aIndex - bIndex;\n        });\n\n        sortedStates.forEach(state => {\n          const items = groupedByState.get(state)!;\n          report += `## ${state} (${items.length})\\n\\n`;\n          items.forEach((item: any) => {\n            const fields = item.fields;\n            report += `- **#${item.id}**: ${fields['System.Title'] || 'Untitled'}\\n`;\n            report += `  - Type: ${fields['System.WorkItemType'] || 'N/A'}`;\n            report += `, Assigned: ${fields['System.AssignedTo']?.displayName || 'Unassigned'}\\n`;\n          });\n          report += `\\n`;\n        });\n      } else {\n        report += `No work items found matching the query.\\n`;\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating work items query report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      }
    ],
    "application-insights": [
      {
        "name": "appinsights-exception-summary",
        "code": "server.prompt(\n  \"appinsights-exception-summary\",\n  \"Generate a comprehensive exception summary report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get recent exceptions\n      const exceptionsResult = await service.getRecentExceptions(resourceId, timespanValue, 50);\n\n      // Get exception type frequency\n      const exceptionTypesResult = await service.executeQuery(\n        resourceId,\n        `\n          exceptions\n          | where timestamp > ago(${timespanValue.replace(/^P(T)?/, '')})\n          | summarize Count=count() by type\n          | order by Count desc\n        `.trim(),\n        timespanValue\n      );\n\n      // Format results\n      const exceptionsList = formatTableAsMarkdown(exceptionsResult.tables[0]);\n      const exceptionTypes = formatTableAsMarkdown(exceptionTypesResult.tables[0]);\n      const insights = analyzeExceptions(exceptionsResult.tables[0]);\n\n      const report = `# Application Insights Exception Summary Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Recent Exceptions\\n\\n${exceptionsList}\\n\\n` +\n        `## Exception Types (Frequency)\\n\\n${exceptionTypes}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Review the most frequent exception types to identify systemic issues\\n` +\n        `- Investigate exceptions in critical operations first\\n` +\n        `- Check for patterns in timestamps (e.g., deployment times, peak traffic)\\n` +\n        `- Use operation_Id to correlate exceptions with requests and dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating exception summary:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate exception summary: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-performance-report",
        "code": "server.prompt(\n  \"appinsights-performance-report\",\n  \"Generate a comprehensive performance analysis report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get operation performance\n      const performanceResult = await service.getOperationPerformance(resourceId, timespanValue);\n\n      // Get slow requests\n      const slowRequestsResult = await service.getSlowRequests(resourceId, 5000, timespanValue, 20);\n\n      // Format results\n      const performanceTable = formatTableAsMarkdown(performanceResult.tables[0]);\n      const slowRequestsTable = formatTableAsMarkdown(slowRequestsResult.tables[0]);\n      const insights = analyzePerformance(performanceResult.tables[0]);\n\n      const report = `# Application Insights Performance Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Operation Performance Summary\\n\\n${performanceTable}\\n\\n` +\n        `## Slowest Requests (>5s)\\n\\n${slowRequestsTable}\\n\\n` +\n        `## Performance Recommendations\\n\\n` +\n        `- Focus optimization efforts on operations with high P95/P99 duration\\n` +\n        `- Investigate operations with high failure counts\\n` +\n        `- Monitor operations with high request counts for scalability issues\\n` +\n        `- Use operation_Id to trace slow requests through dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating performance report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate performance report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-dependency-health",
        "code": "server.prompt(\n  \"appinsights-dependency-health\",\n  \"Generate a dependency health report showing external service issues\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get failed dependencies\n      const failedDepsResult = await service.getFailedDependencies(resourceId, timespanValue, 50);\n\n      // Get dependency success rates\n      const successRatesResult = await service.executeQuery(\n        resourceId,\n        `\n          dependencies\n          | where timestamp > ago(${timespanValue.replace(/^P(T)?/, '')})\n          | summarize Total=count(), Failed=countif(success == false), AvgDuration=avg(duration) by target, type\n          | extend SuccessRate=round(100.0 * (Total - Failed) / Total, 2)\n          | order by SuccessRate asc\n        `.trim(),\n        timespanValue\n      );\n\n      // Format results\n      const failedDepsTable = formatTableAsMarkdown(failedDepsResult.tables[0]);\n      const successRatesTable = formatTableAsMarkdown(successRatesResult.tables[0]);\n      const insights = analyzeDependencies(failedDepsResult.tables[0]);\n\n      const report = `# Application Insights Dependency Health Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Failed Dependencies\\n\\n${failedDepsTable}\\n\\n` +\n        `## Dependency Success Rates\\n\\n${successRatesTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Investigate dependencies with success rates below 99%\\n` +\n        `- Check if external service degradation matches known incidents\\n` +\n        `- Review timeout configurations for slow dependencies\\n` +\n        `- Consider implementing circuit breakers for unreliable dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating dependency health report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate dependency health report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-availability-report",
        "code": "server.prompt(\n  \"appinsights-availability-report\",\n  \"Generate an availability and uptime report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT24H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT24H';\n\n      // Get availability results\n      const availabilityResult = await service.getAvailabilityResults(resourceId, timespanValue);\n\n      // Format results\n      const availabilityTable = formatTableAsMarkdown(availabilityResult.tables[0]);\n\n      const report = `# Application Insights Availability Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Availability Test Results\\n\\n${availabilityTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Investigate any tests with success rates below 99.9%\\n` +\n        `- Review failed tests for patterns (geographic, time-based)\\n` +\n        `- Consider adding availability tests for critical endpoints if missing\\n` +\n        `- Set up alerts for availability degradation`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating availability report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate availability report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-troubleshooting-guide",
        "code": "server.prompt(\n  \"appinsights-troubleshooting-guide\",\n  \"Generate a comprehensive troubleshooting guide combining exceptions, performance, and dependencies\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get data from multiple sources\n      const exceptionsResult = await service.getRecentExceptions(resourceId, timespanValue, 20);\n      const slowRequestsResult = await service.getSlowRequests(resourceId, 5000, timespanValue, 20);\n      const failedDepsResult = await service.getFailedDependencies(resourceId, timespanValue, 20);\n      const tracesResult = await service.getTracesBySeverity(resourceId, 3, timespanValue, 30); // Error level\n\n      // Format results\n      const exceptionsTable = formatTableAsMarkdown(exceptionsResult.tables[0]);\n      const slowRequestsTable = formatTableAsMarkdown(slowRequestsResult.tables[0]);\n      const failedDepsTable = formatTableAsMarkdown(failedDepsResult.tables[0]);\n      const tracesTable = formatTableAsMarkdown(tracesResult.tables[0]);\n\n      const report = `# Application Insights Troubleshooting Guide\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## 1. Recent Errors and Exceptions\\n\\n${exceptionsTable}\\n\\n` +\n        `## 2. Performance Issues\\n\\n${slowRequestsTable}\\n\\n` +\n        `## 3. Dependency Failures\\n\\n${failedDepsTable}\\n\\n` +\n        `## 4. Diagnostic Logs (Errors)\\n\\n${tracesTable}\\n\\n` +\n        `## 5. Investigation Steps\\n\\n` +\n        `1. **Identify the pattern**: Check if errors are isolated or widespread\\n` +\n        `2. **Correlate events**: Use operation_Id to trace requests across services\\n` +\n        `3. **Check timeline**: Look for correlation with deployments or external events\\n` +\n        `4. **Review dependencies**: Verify external service health\\n` +\n        `5. **Analyze traces**: Review detailed logs for error context\\n\\n` +\n        `## 6. Common Patterns and Root Causes\\n\\n` +\n        `- **High exception rate + dependency failures**: External service degradation\\n` +\n        `- **Slow requests + high dependency duration**: Network or external API latency\\n` +\n        `- **Exceptions in specific operations**: Code defect or invalid input\\n` +\n        `- **Timeouts**: Insufficient resources or inefficient queries`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating troubleshooting guide:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate troubleshooting guide: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "log-analytics": [
      {
        "name": "loganalytics-workspace-summary",
        "code": "server.prompt(\n  \"loganalytics-workspace-summary\",\n  \"Generate a comprehensive health summary for a Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get recent errors from FunctionAppLogs\n      const errorsResult = await service.getFunctionErrors(resourceId, undefined, timespanValue, 50);\n      const statsResult = await service.getFunctionStats(resourceId, undefined, timespanValue);\n\n      // Format results\n      const errorsTable = errorsResult.tables[0] ? formatLATableAsMarkdown(errorsResult.tables[0]) : '*No errors*';\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n\n      // Analyze\n      const errorsAnalysis = analyzeFunctionErrors(errorsResult.tables[0]);\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Log Analytics Workspace Health Summary\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Function Statistics\\n\\n${statsTable}\\n\\n` +\n        `### Key Insights\\n${statsAnalysis}\\n\\n` +\n        `## Recent Errors\\n\\n${errorsTable}\\n\\n` +\n        `### Error Analysis\\n${errorsAnalysis}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        generateRecommendations({\n          errorCount: errorsResult.tables[0]?.rows.length || 0,\n        }).join('\\n');\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating workspace summary:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate workspace summary: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-function-troubleshooting",
        "code": "server.prompt(\n  \"loganalytics-function-troubleshooting\",\n  \"Generate a comprehensive troubleshooting guide for an Azure Function\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().describe(\"Function name to analyze\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get comprehensive data\n      const logsResult = await service.getFunctionLogs(resourceId, functionName, timespanValue, undefined, 100);\n      const errorsResult = await service.getFunctionErrors(resourceId, functionName, timespanValue, 50);\n      const statsResult = await service.getFunctionStats(resourceId, functionName, timespanValue);\n      const invocationsResult = await service.getFunctionInvocations(resourceId, functionName, timespanValue, 50);\n\n      // Format results\n      const logsTable = logsResult.tables[0] ? formatLATableAsMarkdown(logsResult.tables[0]) : '*No logs*';\n      const errorsTable = errorsResult.tables[0] ? formatLATableAsMarkdown(errorsResult.tables[0]) : '*No errors*';\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n      const invocationsTable = invocationsResult.tables[0] ? formatLATableAsMarkdown(invocationsResult.tables[0]) : '*No invocations*';\n\n      // Analyze\n      const logsAnalysis = analyzeFunctionLogs(logsResult.tables[0]);\n      const errorsAnalysis = analyzeFunctionErrors(errorsResult.tables[0]);\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Azure Function Troubleshooting Guide\\n\\n` +\n        `**Function**: ${functionName}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Executive Summary\\n\\n${statsTable}\\n\\n` +\n        `### Statistics Insights\\n${statsAnalysis}\\n\\n` +\n        `## Error Analysis\\n\\n${errorsTable}\\n\\n` +\n        `### Error Insights\\n${errorsAnalysis}\\n\\n` +\n        `## Recent Logs\\n\\n${logsTable}\\n\\n` +\n        `### Log Insights\\n${logsAnalysis}\\n\\n` +\n        `## Recent Invocations\\n\\n${invocationsTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        generateRecommendations({\n          errorCount: errorsResult.tables[0]?.rows.length || 0,\n        }).join('\\n');\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating function troubleshooting guide:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate troubleshooting guide: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-function-performance-report",
        "code": "server.prompt(\n  \"loganalytics-function-performance-report\",\n  \"Generate a performance analysis report for Azure Functions\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name (optional, analyzes all if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get performance data\n      const statsResult = await service.getFunctionStats(resourceId, functionName, timespanValue);\n      const invocationsResult = await service.getFunctionInvocations(resourceId, functionName, timespanValue, 100);\n\n      // Format results\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n      const invocationsTable = invocationsResult.tables[0] ? formatLATableAsMarkdown(invocationsResult.tables[0]) : '*No invocations*';\n\n      // Analyze\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Azure Function Performance Report\\n\\n` +\n        `**Function**: ${functionName || 'All Functions'}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Execution Statistics\\n\\n${statsTable}\\n\\n` +\n        `### Performance Insights\\n${statsAnalysis}\\n\\n` +\n        `## Recent Invocations\\n\\n${invocationsTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Monitor success rates and investigate functions below 95%\\n` +\n        `- Review invocation patterns for optimization opportunities\\n` +\n        `- Consider implementing retry logic for transient failures\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating performance report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate performance report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-logs-report",
        "code": "server.prompt(\n  \"loganalytics-logs-report\",\n  \"Generate a formatted logs report with insights and analysis\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    tableName: z.string().describe(\"Table name to query\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.string().optional().describe(\"Maximum number of logs (default: 100)\"),\n  },\n  async ({ resourceId, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n      const limitValue = limit ? parseInt(limit, 10) : 100;\n\n      // Get logs\n      const logsResult = await service.getRecentEvents(resourceId, tableName, timespanValue, limitValue);\n\n      // Format results\n      const logsTable = logsResult.tables[0] ? formatLATableAsMarkdown(logsResult.tables[0]) : '*No logs*';\n\n      // Analyze\n      const analysis = analyzeLogs(logsResult.tables[0], tableName);\n\n      const report = `# Log Analytics Report\\n\\n` +\n        `**Table**: ${tableName}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Limit**: ${limitValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Log Entries\\n\\n${logsTable}\\n\\n` +\n        `### Analysis\\n${analysis}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Review log patterns for anomalies\\n` +\n        `- Investigate any error or warning entries\\n` +\n        `- Consider adjusting log retention policies\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating logs report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate logs report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "azure-sql": [
      {
        "name": "sql-database-overview",
        "code": "server.prompt(\n  \"sql-database-overview\",\n  \"Get a comprehensive overview of the Azure SQL Database schema\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    const sqlService = getAzureSqlService();\n\n    const [tables, views, procedures, triggers, functions] = await Promise.all([\n      sqlService.listTables(serverId, database),\n      sqlService.listViews(serverId, database),\n      sqlService.listStoredProcedures(serverId, database),\n      sqlService.listTriggers(serverId, database),\n      sqlService.listFunctions(serverId, database),\n    ]);\n\n    const formattedOverview = formatDatabaseOverview(tables, views, procedures, triggers, functions);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: formattedOverview,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "sql-table-details",
        "code": "server.prompt(\n  \"sql-table-details\",\n  \"Get detailed report for a specific table with columns, indexes, and relationships\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    tableName: z.string().describe(\"Table name\"),\n  },\n  async ({ serverId, database, schemaName, tableName }) => {\n    const sqlService = getAzureSqlService();\n    const schema = await sqlService.getTableSchema(serverId, database, schemaName, tableName);\n\n    let template = formatTableSchemaAsMarkdown(schema);\n    template += `\\n\\n### Sample Query\\n\\n\\`\\`\\`sql\\nSELECT TOP 100 * FROM ${schemaName}.${tableName}\\n\\`\\`\\``;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: template,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "sql-query-results",
        "code": "server.prompt(\n  \"sql-query-results\",\n  \"Execute a query and return formatted results with column headers\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    query: z.string().describe(\"SELECT query to execute\"),\n  },\n  async ({ serverId, database, query }) => {\n    const sqlService = getAzureSqlService();\n    const result = await sqlService.executeSelectQuery(serverId, database, query);\n\n    let template = `## Query Results\\n\\n`;\n    template += `**Query:**\\n\\`\\`\\`sql\\n${query}\\n\\`\\`\\`\\n\\n`;\n    template += `**Results:**\\n${formatSqlResultsAsMarkdown(result)}\\n\\n`;\n    template += `**Row Count:** ${result.rowCount}`;\n\n    if (result.truncated) {\n      template += ` (truncated)`;\n    }\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: template,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ],
    "github-enterprise": [
      {
        "name": "ghe-repo-overview",
        "code": "server.prompt(\n  \"ghe-repo-overview\",\n  \"Get a comprehensive repository overview with branch analysis and recent commits\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n  },\n  async ({ repoId }) => {\n    const service = getGitHubEnterpriseService();\n\n    const repo = service.getRepoById(repoId);\n    const [branches, defaultBranchInfo] = await Promise.all([\n      service.listBranches(repoId),\n      service.getDefaultBranch(repoId),\n    ]);\n\n    const recentCommits = await service.getCommits(repoId, defaultBranchInfo.branch, undefined, undefined, undefined, undefined, 10);\n\n    const output = formatRepositoryOverviewAsMarkdown(\n      {\n        owner: repo.owner,\n        repo: repo.repo,\n        url: `${service['config'].baseUrl}/${repo.owner}/${repo.repo}`,\n        defaultBranch: defaultBranchInfo.branch,\n        description: repo.description,\n        active: repo.active,\n      },\n      branches,\n      recentCommits\n    );\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-code-search-report",
        "code": "server.prompt(\n  \"ghe-code-search-report\",\n  \"Search code across repositories and get formatted results with analysis\",\n  {\n    query: z.string().describe(\"Search query\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository ID\"),\n    extension: z.string().optional().describe(\"Filter by file extension (e.g., 'cs', 'js')\"),\n  },\n  async ({ query, repoId, extension }) => {\n    const service = getGitHubEnterpriseService();\n    const results = await service.searchCode(query, repoId, undefined, extension);\n\n    const output = formatCodeSearchResultsAsMarkdown(results);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-branch-comparison-report",
        "code": "server.prompt(\n  \"ghe-branch-comparison-report\",\n  \"Compare branches and generate deployment-ready summary with checklist\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    base: z.string().describe(\"Base branch (e.g., 'main')\"),\n    head: z.string().describe(\"Head branch to compare (e.g., 'release/9.0')\"),\n  },\n  async ({ repoId, base, head }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    const comparison = await service.compareBranches(repoId, base, head);\n    const insights = analyzeBranchComparison(comparison);\n    const checklist = generateDeploymentChecklist(comparison);\n\n    let output = `# Branch Comparison: ${base} â† ${head}\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Comparing:** \\`${base}\\` (base) â† \\`${head}\\` (head)\\n\\n`;\n\n    output += `## Summary\\n\\n`;\n    output += insights.join('\\n') + '\\n\\n';\n\n    if (comparison.commits && comparison.commits.length > 0) {\n      output += `## Commits to Deploy\\n\\n`;\n      output += formatCommitHistoryAsMarkdown(comparison.commits) + '\\n\\n';\n    }\n\n    if (comparison.files && comparison.files.length > 0) {\n      output += `## Files Changed (${comparison.files.length})\\n\\n`;\n      const header = '| File | Status | +/- | Changes |';\n      const separator = '|------|--------|-----|---------|';\n      const rows = comparison.files.slice(0, 20).map((f: any) => {\n        const status = f.status === 'added' ? 'ðŸ†• Added' :\n                       f.status === 'modified' ? 'ðŸ“ Modified' :\n                       f.status === 'removed' ? 'ðŸ—‘ï¸ Removed' :\n                       f.status === 'renamed' ? 'ðŸ“‹ Renamed' : f.status;\n        return `| \\`${f.filename}\\` | ${status} | +${f.additions}/-${f.deletions} | ${f.changes} |`;\n      });\n      output += [header, separator, ...rows].join('\\n');\n\n      if (comparison.files.length > 20) {\n        output += `\\n\\n*Showing 20 of ${comparison.files.length} files*`;\n      }\n      output += '\\n\\n';\n    }\n\n    output += `## Deployment Checklist\\n\\n`;\n    output += checklist.join('\\n');\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-troubleshooting-guide",
        "code": "server.prompt(\n  \"ghe-troubleshooting-guide\",\n  \"Generate comprehensive bug troubleshooting report with source code analysis\",\n  {\n    repoId: z.string().describe(\"Repository ID to investigate\"),\n    searchQuery: z.string().describe(\"Search query (e.g., plugin name, entity name, or code pattern)\"),\n    branch: z.string().optional().describe(\"Branch to search (default: auto-detected)\"),\n  },\n  async ({ repoId, searchQuery, branch }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    // Search for code\n    const codeResults = await service.searchCode(searchQuery, repoId);\n\n    // Search commits for references\n    const commitResults = await service.searchCommits(repoId, searchQuery);\n\n    let output = `# Bug Troubleshooting Report\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Search Query:** \\`${searchQuery}\\`\\n\\n`;\n\n    output += `## Source Code Analysis\\n\\n`;\n\n    if (codeResults.total_count > 0) {\n      output += `Found **${codeResults.total_count} code matches** across ${codeResults.items.length} files:\\n\\n`;\n      output += formatCodeSearchResultsAsMarkdown(codeResults) + '\\n\\n';\n    } else {\n      output += `*No code matches found for query: \"${searchQuery}\"*\\n\\n`;\n    }\n\n    output += `## Related Commits\\n\\n`;\n\n    if (commitResults.length > 0) {\n      output += `Found **${commitResults.length} commits** referencing \"${searchQuery}\":\\n\\n`;\n      output += formatCommitHistoryAsMarkdown(commitResults.slice(0, 10)) + '\\n\\n';\n\n      if (commitResults.length > 10) {\n        output += `*Showing 10 of ${commitResults.length} commits*\\n\\n`;\n      }\n    } else {\n      output += `*No commits found referencing \"${searchQuery}\"*\\n\\n`;\n    }\n\n    output += `## Recommendations\\n\\n`;\n    output += `1. **Review Code Matches**: Check the code search results above for relevant implementations\\n`;\n    output += `2. **Analyze Recent Changes**: Review commit history for recent modifications\\n`;\n    output += `3. **Check Branch**: Current search is on branch \\`${branch || 'auto-detected'}\\`\\n`;\n    output += `4. **Cross-Reference**: Use ADO work items or PowerPlatform plugin names to correlate issues\\n`;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-deployment-report",
        "code": "server.prompt(\n  \"ghe-deployment-report\",\n  \"Generate deployment-ready report with code changes, testing checklist, and rollback plan\",\n  {\n    repoId: z.string().describe(\"Repository ID\"),\n    fromBranch: z.string().optional().describe(\"Source branch (default: main)\"),\n    toBranch: z.string().optional().describe(\"Target branch (default: auto-detected)\"),\n  },\n  async ({ repoId, fromBranch = \"main\", toBranch }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    // Auto-detect target branch if not specified\n    const targetBranch = toBranch || (await service.getDefaultBranch(repoId)).branch;\n\n    // Get branch comparison\n    const comparison = await service.compareBranches(repoId, fromBranch, targetBranch);\n    const insights = analyzeBranchComparison(comparison);\n    const checklist = generateDeploymentChecklist(comparison);\n\n    let output = `# Deployment Report: ${targetBranch} â†’ ${fromBranch}\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Source:** \\`${targetBranch}\\`\\n`;\n    output += `**Target:** \\`${fromBranch}\\` (Production)\\n`;\n    output += `**Date:** ${new Date().toISOString().split('T')[0]}\\n\\n`;\n\n    output += `## Executive Summary\\n\\n`;\n    output += insights.join('\\n') + '\\n\\n';\n\n    output += `## Changes by Component\\n\\n`;\n\n    if (comparison.files && comparison.files.length > 0) {\n      // Group files by directory/component\n      const filesByDir: Record<string, any[]> = {};\n      comparison.files.forEach((f: any) => {\n        const dir = f.filename.split('/')[0] || 'root';\n        if (!filesByDir[dir]) filesByDir[dir] = [];\n        filesByDir[dir].push(f);\n      });\n\n      Object.entries(filesByDir).forEach(([dir, files]) => {\n        output += `### ${dir}/ (${files.length} files)\\n\\n`;\n        const rows = files.slice(0, 10).map((f: any) =>\n          `- \\`${f.filename}\\` (+${f.additions}, -${f.deletions})`\n        );\n        output += rows.join('\\n') + '\\n\\n';\n\n        if (files.length > 10) {\n          output += `*...and ${files.length - 10} more files*\\n\\n`;\n        }\n      });\n    }\n\n    output += `## Deployment Steps\\n\\n`;\n    output += `### 1. Pre-Deployment Verification\\n`;\n    output += `\\`\\`\\`bash\\n# Review changes\\ngit diff ${fromBranch}...${targetBranch}\\n\\n# Run tests\\nnpm test  # or: dotnet test\\n\\`\\`\\`\\n\\n`;\n\n    output += `### 2. Merge to Production\\n`;\n    output += `\\`\\`\\`bash\\ngit checkout ${fromBranch}\\ngit merge ${targetBranch} --no-ff\\ngit push origin ${fromBranch}\\n\\`\\`\\`\\n\\n`;\n\n    output += `### 3. Post-Deployment Verification\\n`;\n    output += `- [ ] Smoke tests passing\\n`;\n    output += `- [ ] No errors in logs (first 15 minutes)\\n`;\n    output += `- [ ] Verify key functionality works\\n\\n`;\n\n    output += `## Rollback Plan\\n\\n`;\n    output += `If issues occur after deployment:\\n\\n`;\n    output += `\\`\\`\\`bash\\n# Option 1: Revert merge commit\\ngit revert -m 1 HEAD\\ngit push origin ${fromBranch}\\n\\n`;\n    output += `# Option 2: Reset to previous commit (if not pushed)\\ngit reset --hard HEAD~1\\n\\`\\`\\`\\n\\n`;\n\n    output += `## Testing Checklist\\n\\n`;\n    output += checklist.join('\\n');\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ],
    "service-bus": [
      {
        "name": "servicebus-namespace-overview",
        "code": "server.prompt(\n  \"servicebus-namespace-overview\",\n  \"Generate comprehensive overview of Service Bus namespace with all queues and health metrics\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Get namespace properties\n    const namespaceProps = await service.getNamespaceProperties(resourceId);\n\n    // Get all queues\n    const queues = await service.listQueues(resourceId);\n\n    // Format as markdown\n    const output = formatNamespaceOverviewAsMarkdown({\n      namespace: resource.namespace,\n      tier: namespaceProps.tier,\n      queues,\n    });\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-queue-health",
        "code": "server.prompt(\n  \"servicebus-queue-health\",\n  \"Generate detailed health report for a specific queue with recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n  },\n  async ({ resourceId, queueName }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Get queue info (runtime metrics)\n    const queueInfo = await service.getQueueProperties(resourceId, queueName);\n\n    // Get queue config (configuration properties)\n    const queueConfig = await service.getQueueConfigProperties(resourceId, queueName);\n\n    // Get health status\n    const health = getQueueHealthStatus(queueInfo);\n\n    // Peek recent messages\n    const messages = await service.peekMessages(resourceId, queueName, 10);\n\n    // Peek dead letter messages\n    const deadLetterMessages = await service.peekDeadLetterMessages(resourceId, queueName, 10);\n\n    let output = `# Queue Health Report: ${queueName}\\n\\n`;\n    output += `**Namespace:** ${resource.namespace}\\n`;\n    output += `**Date:** ${new Date().toISOString()}\\n\\n`;\n\n    output += `## Health Status\\n\\n`;\n    output += `${health.icon} **${health.status.toUpperCase()}**\\n\\n`;\n    output += `**Reason:** ${health.reason}\\n\\n`;\n\n    output += `## Queue Metrics\\n\\n`;\n    output += `| Metric | Value |\\n`;\n    output += `|--------|-------|\\n`;\n    output += `| Active Messages | ${queueInfo.activeMessageCount || 0} |\\n`;\n    output += `| Dead Letter Messages | ${queueInfo.deadLetterMessageCount || 0} |\\n`;\n    output += `| Scheduled Messages | ${queueInfo.scheduledMessageCount || 0} |\\n`;\n    output += `| Size (bytes) | ${queueInfo.sizeInBytes?.toLocaleString() || 0} |\\n`;\n    output += `| Max Size (MB) | ${queueConfig.maxSizeInMegabytes || 0} |\\n\\n`;\n\n    output += `## Configuration\\n\\n`;\n    output += `| Setting | Value |\\n`;\n    output += `|---------|-------|\\n`;\n    output += `| Lock Duration | ${queueConfig.lockDuration || 'N/A'} |\\n`;\n    output += `| Max Delivery Count | ${queueConfig.maxDeliveryCount || 0} |\\n`;\n    output += `| Duplicate Detection | ${queueConfig.requiresDuplicateDetection ? 'Yes' : 'No'} |\\n`;\n    output += `| Sessions Enabled | ${queueInfo.requiresSession ? 'Yes' : 'No'} |\\n`;\n    output += `| Partitioning Enabled | ${queueConfig.enablePartitioning ? 'Yes' : 'No'} |\\n\\n`;\n\n    output += `## Recommendations\\n\\n`;\n    if (health.status === 'critical') {\n      output += `âš ï¸ **CRITICAL**: Immediate action required\\n`;\n      output += `- Investigate dead letter messages immediately\\n`;\n      output += `- Check consumer health and processing capacity\\n`;\n      output += `- Consider scaling out consumers\\n\\n`;\n    } else if (health.status === 'warning') {\n      output += `âš ï¸ **WARNING**: Monitor closely\\n`;\n      output += `- Review message processing times\\n`;\n      output += `- Check for processing bottlenecks\\n`;\n      output += `- Monitor dead letter queue growth\\n\\n`;\n    } else {\n      output += `âœ… Queue is healthy\\n`;\n      output += `- Continue regular monitoring\\n`;\n      output += `- Maintain current processing capacity\\n\\n`;\n    }\n\n    if (messages.length > 0) {\n      output += `## Recent Messages (${messages.length})\\n\\n`;\n      output += formatMessagesAsMarkdown(messages, false);\n    }\n\n    if (deadLetterMessages.length > 0) {\n      output += `\\n## Dead Letter Messages (${deadLetterMessages.length})\\n\\n`;\n      output += formatMessagesAsMarkdown(deadLetterMessages, false);\n    }\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-deadletter-analysis",
        "code": "server.prompt(\n  \"servicebus-deadletter-analysis\",\n  \"Analyze dead letter queue with pattern detection and actionable recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.string().optional().describe(\"Maximum messages to analyze (default: 50)\"),\n  },\n  async ({ resourceId, queueName, maxMessages }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Parse maxMessages to number\n    const maxMsgs = maxMessages ? parseInt(maxMessages, 10) : 50;\n\n    // Peek dead letter messages\n    const deadLetterMessages = await service.peekDeadLetterMessages(\n      resourceId,\n      queueName,\n      maxMsgs\n    );\n\n    if (deadLetterMessages.length === 0) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Dead Letter Queue Analysis: ${queueName}\\n\\nâœ… **No dead letter messages found**\\n\\nThe dead letter queue is empty. This indicates healthy message processing.`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Analyze dead letter messages\n    const { markdown } = formatDeadLetterAnalysisAsMarkdown(deadLetterMessages);\n\n    let output = `# Dead Letter Queue Analysis: ${queueName}\\n\\n`;\n    output += `**Namespace:** ${resource.namespace}\\n`;\n    output += `**Date:** ${new Date().toISOString()}\\n`;\n    output += `**Messages Analyzed:** ${deadLetterMessages.length}\\n\\n`;\n    output += markdown;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-message-inspection",
        "code": "server.prompt(\n  \"servicebus-message-inspection\",\n  \"Inspect a single message in detail with cross-service troubleshooting recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    messageId: z.string().optional().describe(\"Message ID to inspect (if not provided, inspects first message)\"),\n    isDeadLetter: z.string().optional().describe(\"Inspect dead letter queue (default: false)\"),\n  },\n  async ({ resourceId, queueName, messageId, isDeadLetter }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Parse isDeadLetter to boolean\n    const isDLQ = isDeadLetter === 'true';\n\n    // Peek messages\n    const messages = isDLQ\n      ? await service.peekDeadLetterMessages(resourceId, queueName, 100)\n      : await service.peekMessages(resourceId, queueName, 100);\n\n    if (messages.length === 0) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Message Inspection: ${queueName}\\n\\n**No messages found** in ${isDLQ ? 'dead letter queue' : 'queue'}.`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Find specific message or use first\n    const message = messageId\n      ? messages.find((m) => m.messageId === messageId)\n      : messages[0];\n\n    if (!message) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Message Inspection: ${queueName}\\n\\n**Message not found** with ID: ${messageId}\\n\\nAvailable message IDs:\\n${messages.slice(0, 10).map((m) => `- ${m.messageId}`).join('\\n')}`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Format message inspection\n    const output = formatMessageInspectionAsMarkdown(message, isDLQ);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `# Message Inspection: ${queueName}\\n\\n**Namespace:** ${resource.namespace}\\n**Queue:** ${queueName}\\n**Date:** ${new Date().toISOString()}\\n\\n${output}`,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ]
  }
}