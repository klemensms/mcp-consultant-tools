{
  "tools": {
    "powerplatform": [
      {
        "name": "get-entity-metadata",
        "code": "server.tool(\n  \"get-entity-metadata\",\n  \"Get metadata about a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const metadata = await service.getEntityMetadata(entityName);\n      \n      // Format the metadata as a string for text display\n      const metadataStr = JSON.stringify(metadata, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Entity metadata for '${entityName}':\\n\\n${metadataStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity metadata: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-attributes",
        "code": "server.tool(\n  \"get-entity-attributes\",\n  \"Get attributes/fields of a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const attributes = await service.getEntityAttributes(entityName);\n      \n      // Format the attributes as a string for text display\n      const attributesStr = JSON.stringify(attributes, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Attributes for entity '${entityName}':\\n\\n${attributesStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity attributes:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity attributes: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-attribute",
        "code": "server.tool(\n  \"get-entity-attribute\",\n  \"Get a specific attribute/field of a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    attributeName: z.string().describe(\"The logical name of the attribute\")\n  },\n  async ({ entityName, attributeName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const attribute = await service.getEntityAttribute(entityName, attributeName);\n      \n      // Format the attribute as a string for text display\n      const attributeStr = JSON.stringify(attribute, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Attribute '${attributeName}' for entity '${entityName}':\\n\\n${attributeStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity attribute:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity attribute: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-relationships",
        "code": "server.tool(\n  \"get-entity-relationships\",\n  \"Get relationships (one-to-many and many-to-many) for a PowerPlatform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async ({ entityName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const relationships = await service.getEntityRelationships(entityName);\n      \n      // Format the relationships as a string for text display\n      const relationshipsStr = JSON.stringify(relationships, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Relationships for entity '${entityName}':\\n\\n${relationshipsStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity relationships:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity relationships: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-global-option-set",
        "code": "server.tool(\n  \"get-global-option-set\",\n  \"Get a global option set definition by name\",\n  {\n    optionSetName: z.string().describe(\"The name of the global option set\"),\n  },\n  async ({ optionSetName }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const optionSet = await service.getGlobalOptionSet(optionSetName);\n      \n      // Format the option set as a string for text display\n      const optionSetStr = JSON.stringify(optionSet, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Global option set '${optionSetName}':\\n\\n${optionSetStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting global option set:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get global option set: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-record",
        "code": "server.tool(\n  \"get-record\",\n  \"Get a specific record by entity name (plural) and ID\",\n  {\n    entityNamePlural: z.string().describe(\"The plural name of the entity (e.g., 'accounts', 'contacts')\"),\n    recordId: z.string().describe(\"The GUID of the record\"),\n  },\n  async ({ entityNamePlural, recordId }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const record = await service.getRecord(entityNamePlural, recordId);\n      \n      // Format the record as a string for text display\n      const recordStr = JSON.stringify(record, null, 2);\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Record from '${entityNamePlural}' with ID '${recordId}':\\n\\n${recordStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get record: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-records",
        "code": "server.tool(\n  \"query-records\",\n  \"Query records using an OData filter expression\",\n  {\n    entityNamePlural: z.string().describe(\"The plural name of the entity (e.g., 'accounts', 'contacts')\"),\n    filter: z.string().describe(\"OData filter expression (e.g., \\\"name eq 'test'\\\" or \\\"createdon gt 2023-01-01\\\")\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of records to retrieve (default: 50)\"),\n  },\n  async ({ entityNamePlural, filter, maxRecords }) => {\n    try {\n      // Get or initialize PowerPlatformService\n      const service = getPowerPlatformService();\n      const records = await service.queryRecords(entityNamePlural, filter, maxRecords || 50);\n      \n      // Format the records as a string for text display\n      const recordsStr = JSON.stringify(records, null, 2);\n      const recordCount = records.value?.length || 0;\n      \n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Retrieved ${recordCount} records from '${entityNamePlural}' with filter '${filter}':\\n\\n${recordsStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error querying records:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to query records: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-record",
        "code": "server.tool(\n  \"create-record\",\n  \"Create a new record in Dataverse. Requires POWERPLATFORM_ENABLE_CREATE=true.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    data: z\n      .record(z.any())\n      .describe(\n        \"Record data as JSON object. Field names must match logical names (e.g., {'name': 'Acme Corp', 'telephone1': '555-1234'}). \" +\n        \"For lookup fields, use '@odata.bind' syntax: {'parentaccountid@odata.bind': '/accounts(guid)'}. \" +\n        \"For option sets, use integer values.\"\n      ),\n  },\n  async ({ entityNamePlural, data }) => {\n    try {\n      checkCreateEnabled();\n      const service = getPowerPlatformService();\n      const result = await service.createRecord(entityNamePlural, data);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record created successfully in ${entityNamePlural}\\n\\n` +\n              `**Record ID:** ${result.id || result[Object.keys(result).find(k => k.endsWith('id')) || ''] || 'N/A'}\\n\\n` +\n              `**Created Record:**\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to create record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-record",
        "code": "server.tool(\n  \"update-record\",\n  \"Update an existing record in Dataverse. Requires POWERPLATFORM_ENABLE_UPDATE=true.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    recordId: z\n      .string()\n      .describe(\"The GUID of the record to update\"),\n    data: z\n      .record(z.any())\n      .describe(\n        \"Partial record data to update (only fields being changed). \" +\n        \"Field names must match logical names. \" +\n        \"Use '@odata.bind' syntax for lookups, integer values for option sets.\"\n      ),\n  },\n  async ({ entityNamePlural, recordId, data }) => {\n    try {\n      checkUpdateEnabled();\n      const service = getPowerPlatformService();\n      const result = await service.updateRecord(entityNamePlural, recordId, data);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record updated successfully in ${entityNamePlural}\\n\\n` +\n              `**Record ID:** ${recordId}\\n\\n` +\n              `**Updated Record:**\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to update record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-record",
        "code": "server.tool(\n  \"delete-record\",\n  \"Delete a record from Dataverse. Requires POWERPLATFORM_ENABLE_DELETE=true. WARNING: This operation is permanent and cannot be undone.\",\n  {\n    entityNamePlural: z\n      .string()\n      .describe(\"The plural name of the entity (e.g., 'accounts', 'contacts', 'sic_applications')\"),\n    recordId: z\n      .string()\n      .describe(\"The GUID of the record to delete\"),\n    confirm: z\n      .boolean()\n      .optional()\n      .describe(\"Confirmation flag - must be true to proceed with deletion (safety check)\"),\n  },\n  async ({ entityNamePlural, recordId, confirm }) => {\n    try {\n      checkDeleteEnabled();\n\n      // Require explicit confirmation for deletion\n      if (confirm !== true) {\n        return {\n          content: [\n            {\n              type: \"text\",\n              text: `âš ï¸  Delete operation requires explicit confirmation.\\n\\n` +\n                `You are about to delete record **${recordId}** from **${entityNamePlural}**.\\n\\n` +\n                `This operation is **permanent** and **cannot be undone**.\\n\\n` +\n                `To proceed, call this tool again with \\`confirm: true\\`.`,\n            },\n          ],\n        };\n      }\n\n      const service = getPowerPlatformService();\n      await service.deleteRecord(entityNamePlural, recordId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Record deleted successfully\\n\\n` +\n              `**Entity:** ${entityNamePlural}\\n` +\n              `**Record ID:** ${recordId}\\n\\n` +\n              `âš ï¸  This operation is permanent.`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting record:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âŒ Failed to delete record: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-assemblies",
        "code": "server.tool(\n  \"get-plugin-assemblies\",\n  \"Get a list of all plugin assemblies in the environment\",\n  {\n    includeManaged: z.boolean().optional().describe(\"Include managed assemblies (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of assemblies to return (default: 100)\"),\n  },\n  async ({ includeManaged, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblies(includeManaged || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} plugin assemblies:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin assemblies:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin assemblies: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-assembly-complete",
        "code": "server.tool(\n  \"get-plugin-assembly-complete\",\n  \"Get comprehensive information about a plugin assembly including all types, steps, images, and validation\",\n  {\n    assemblyName: z.string().describe(\"The name of the plugin assembly\"),\n    includeDisabled: z.boolean().optional().describe(\"Include disabled steps (default: false)\"),\n  },\n  async ({ assemblyName, includeDisabled }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblyComplete(assemblyName, includeDisabled || false);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin assembly '${assemblyName}' complete information:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin assembly:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin assembly: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-plugin-pipeline",
        "code": "server.tool(\n  \"get-entity-plugin-pipeline\",\n  \"Get all plugins that execute on a specific entity, organized by message and execution order\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    messageFilter: z.string().optional().describe(\"Filter by message name (e.g., 'Create', 'Update', 'Delete')\"),\n    includeDisabled: z.boolean().optional().describe(\"Include disabled steps (default: false)\"),\n  },\n  async ({ entityName, messageFilter, includeDisabled }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getEntityPluginPipeline(entityName, messageFilter, includeDisabled || false);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin pipeline for entity '${entityName}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity plugin pipeline:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get entity plugin pipeline: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-plugin-trace-logs",
        "code": "server.tool(\n  \"get-plugin-trace-logs\",\n  \"Query plugin trace logs with filtering and exception parsing\",\n  {\n    entityName: z.string().optional().describe(\"Filter by entity logical name\"),\n    messageName: z.string().optional().describe(\"Filter by message name (e.g., 'Update')\"),\n    correlationId: z.string().optional().describe(\"Filter by correlation ID\"),\n    pluginStepId: z.string().optional().describe(\"Filter by specific step ID\"),\n    exceptionOnly: z.boolean().optional().describe(\"Only return logs with exceptions (default: false)\"),\n    hoursBack: z.number().optional().describe(\"How many hours back to search (default: 24)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of logs to return (default: 50)\"),\n  },\n  async ({ entityName, messageName, correlationId, pluginStepId, exceptionOnly, hoursBack, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginTraceLogs({\n        entityName,\n        messageName,\n        correlationId,\n        pluginStepId,\n        exceptionOnly: exceptionOnly || false,\n        hoursBack: hoursBack || 24,\n        maxRecords: maxRecords || 50\n      });\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Plugin trace logs (found ${result.totalCount}):\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting plugin trace logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get plugin trace logs: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flows",
        "code": "server.tool(\n  \"get-flows\",\n  \"Get a list of all Power Automate cloud flows in the environment\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated flows (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of flows to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlows(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} Power Automate flows:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flows:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flows: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flow-definition",
        "code": "server.tool(\n  \"get-flow-definition\",\n  \"Get the complete definition of a specific Power Automate flow including its logic\",\n  {\n    flowId: z.string().describe(\"The GUID of the flow (workflowid)\"),\n  },\n  async ({ flowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlowDefinition(flowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Flow definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flow definition:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flow definition: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-flow-runs",
        "code": "server.tool(\n  \"get-flow-runs\",\n  \"Get the run history for a specific Power Automate flow with success/failure status\",\n  {\n    flowId: z.string().describe(\"The GUID of the flow (workflowid)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of runs to return (default: 100)\"),\n  },\n  async ({ flowId, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlowRuns(flowId, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      // Calculate success/failure stats\n      const stats = result.runs.reduce((acc: any, run: any) => {\n        if (run.status === 'Succeeded') acc.succeeded++;\n        else if (run.status === 'Failed' || run.status === 'Faulted' || run.status === 'TimedOut') acc.failed++;\n        else if (run.status === 'Running' || run.status === 'Waiting') acc.inProgress++;\n        else acc.other++;\n        return acc;\n      }, { succeeded: 0, failed: 0, inProgress: 0, other: 0 });\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} flow runs for flow ${flowId}:\\n\\nStats:\\n- Succeeded: ${stats.succeeded}\\n- Failed: ${stats.failed}\\n- In Progress: ${stats.inProgress}\\n- Other: ${stats.other}\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting flow runs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get flow runs: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-workflows",
        "code": "server.tool(\n  \"get-workflows\",\n  \"Get a list of all classic Dynamics workflows in the environment\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated workflows (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of workflows to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflows(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} classic Dynamics workflows:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting workflows:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get workflows: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-workflow-definition",
        "code": "server.tool(\n  \"get-workflow-definition\",\n  \"Get the complete definition of a specific classic Dynamics workflow including its XAML\",\n  {\n    workflowId: z.string().describe(\"The GUID of the workflow (workflowid)\"),\n  },\n  async ({ workflowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflowDefinition(workflowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Workflow definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting workflow definition:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get workflow definition: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-business-rules",
        "code": "server.tool(\n  \"get-business-rules\",\n  \"Get a list of all business rules in the environment (read-only for troubleshooting)\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return activated business rules (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of business rules to return (default: 100)\"),\n  },\n  async ({ activeOnly, maxRecords }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRules(activeOnly || false, maxRecords || 100);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${result.totalCount} business rules:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting business rules:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get business rules: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-business-rule",
        "code": "server.tool(\n  \"get-business-rule\",\n  \"Get the complete definition of a specific business rule including its XAML (read-only for troubleshooting)\",\n  {\n    workflowId: z.string().describe(\"The GUID of the business rule (workflowid)\"),\n  },\n  async ({ workflowId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRule(workflowId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Business rule definition for '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting business rule:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get business rule: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-apps",
        "code": "server.tool(\n  \"get-apps\",\n  \"Get all model-driven apps in the PowerPlatform environment\",\n  {\n    activeOnly: z.boolean().optional().describe(\"Only return active apps (default: false)\"),\n    maxRecords: z.number().optional().describe(\"Maximum number of apps to return (default: 100)\"),\n    includeUnpublished: z.boolean().optional().describe(\"Include unpublished/draft apps (default: true)\"),\n    solutionUniqueName: z.string().optional().describe(\"Filter apps by solution unique name (e.g., 'MCPTestCore')\"),\n  },\n  async ({ activeOnly, maxRecords, includeUnpublished, solutionUniqueName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getApps(\n        activeOnly || false,\n        maxRecords || 100,\n        includeUnpublished !== undefined ? includeUnpublished : true,\n        solutionUniqueName\n      );\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Model-Driven Apps (found ${result.totalCount}):\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting apps:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get apps: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-app",
        "code": "server.tool(\n  \"get-app\",\n  \"Get detailed information about a specific model-driven app\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async ({ appId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getApp(appId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Model-Driven App '${result.name}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting app:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get app: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-app-components",
        "code": "server.tool(\n  \"get-app-components\",\n  \"Get all components (entities, forms, views, sitemaps) in a model-driven app\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async ({ appId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getAppComponents(appId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `App Components (found ${result.totalCount}):\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting app components:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get app components: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-app-sitemap",
        "code": "server.tool(\n  \"get-app-sitemap\",\n  \"Get the sitemap (navigation) configuration for a model-driven app\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async ({ appId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getAppSitemap(appId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `App Sitemap:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting app sitemap:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get app sitemap: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "add-entities-to-app",
        "code": "server.tool(\n  \"add-entities-to-app\",\n  \"Add entities to a model-driven app (automatically adds them to navigation)\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n    entityNames: z.array(z.string()).describe(\"Array of entity logical names to add (e.g., ['account', 'contact'])\"),\n  },\n  async ({ appId, entityNames }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.addEntitiesToApp(appId, entityNames);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Entities added successfully:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error adding entities to app:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to add entities to app: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "validate-app",
        "code": "server.tool(\n  \"validate-app\",\n  \"Validate a model-driven app before publishing (checks for missing components and configuration issues)\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async ({ appId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.validateApp(appId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `App validation result:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error validating app:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to validate app: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "publish-app",
        "code": "server.tool(\n  \"publish-app\",\n  \"Publish a model-driven app to make it available to users (automatically validates first)\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async ({ appId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.publishApp(appId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `App published successfully:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error publishing app:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to publish app: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-entity",
        "code": "server.tool(\n  \"create-entity\",\n  \"Create a new custom entity (table) in Dynamics 365 / PowerPlatform. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    schemaName: z.string().describe(\"The schema name of the entity (e.g., 'sic_application')\"),\n    displayName: z.string().describe(\"The display name of the entity (e.g., 'Application')\"),\n    pluralDisplayName: z.string().describe(\"The plural display name (e.g., 'Applications')\"),\n    description: z.string().describe(\"Description of the entity\"),\n    ownershipType: z.enum([\"UserOwned\", \"TeamOwned\", \"OrganizationOwned\"]).describe(\"Ownership type (default: UserOwned)\"),\n    hasActivities: z.boolean().optional().describe(\"Enable activities (default: false)\"),\n    hasNotes: z.boolean().optional().describe(\"Enable notes (default: false)\"),\n    isActivityParty: z.boolean().optional().describe(\"Can be a party in activities (default: false)\"),\n    primaryAttributeSchemaName: z.string().optional().describe(\"Schema name for primary attribute (default: 'name')\"),\n    primaryAttributeDisplayName: z.string().optional().describe(\"Display name for primary attribute (default: 'Name')\"),\n    primaryAttributeMaxLength: z.number().optional().describe(\"Max length for primary attribute (default: 850)\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add entity to (optional, uses POWERPLATFORM_DEFAULT_SOLUTION if not specified)\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      // Construct entity definition\n      const entityDefinition = {\n        \"@odata.type\": \"Microsoft.Dynamics.CRM.EntityMetadata\",\n        SchemaName: params.schemaName,\n        DisplayName: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [\n            {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n              Label: params.displayName,\n              LanguageCode: 1033\n            }\n          ]\n        },\n        DisplayCollectionName: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [\n            {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n              Label: params.pluralDisplayName,\n              LanguageCode: 1033\n            }\n          ]\n        },\n        Description: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [\n            {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n              Label: params.description,\n              LanguageCode: 1033\n            }\n          ]\n        },\n        OwnershipType: params.ownershipType,\n        IsActivity: false,\n        HasActivities: params.hasActivities || false,\n        HasNotes: params.hasNotes || false,\n        IsActivityParty: params.isActivityParty || false,\n        IsDuplicateDetectionEnabled: { Value: false, CanBeChanged: true },\n        IsMailMergeEnabled: { Value: false, CanBeChanged: true },\n        Attributes: [\n          {\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.StringAttributeMetadata\",\n            SchemaName: params.primaryAttributeSchemaName || \"name\",\n            IsPrimaryName: true,\n            RequiredLevel: {\n              Value: \"None\",\n              CanBeChanged: true\n            },\n            MaxLength: params.primaryAttributeMaxLength || 850,\n            FormatName: {\n              Value: \"Text\"\n            },\n            DisplayName: {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n              LocalizedLabels: [\n                {\n                  \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                  Label: params.primaryAttributeDisplayName || \"Name\",\n                  LanguageCode: 1033\n                }\n              ]\n            },\n            Description: {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n              LocalizedLabels: [\n                {\n                  \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                  Label: \"The primary attribute for the entity\",\n                  LanguageCode: 1033\n                }\n              ]\n            }\n          }\n        ],\n        HasFeedback: false\n      };\n\n      const solutionName = params.solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION || undefined;\n      const result = await service.createEntity(entityDefinition, solutionName);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Successfully created entity '${params.schemaName}'.\\n\\n` +\n                  `Details:\\n${JSON.stringify(result, null, 2)}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating entity:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create entity: ${error.message}`\n          }\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-entity",
        "code": "server.tool(\n  \"update-entity\",\n  \"Update an existing custom entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    metadataId: z.string().describe(\"The MetadataId of the entity (GUID)\"),\n    displayName: z.string().optional().describe(\"New display name\"),\n    pluralDisplayName: z.string().optional().describe(\"New plural display name\"),\n    description: z.string().optional().describe(\"New description\"),\n    hasActivities: z.boolean().optional().describe(\"Enable/disable activities\"),\n    hasNotes: z.boolean().optional().describe(\"Enable/disable notes\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution context\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n\n      if (params.displayName) {\n        updates.DisplayName = {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.displayName, LanguageCode: 1033 }]\n        };\n      }\n\n      if (params.pluralDisplayName) {\n        updates.DisplayCollectionName = {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.pluralDisplayName, LanguageCode: 1033 }]\n        };\n      }\n\n      if (params.description) {\n        updates.Description = {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.description, LanguageCode: 1033 }]\n        };\n      }\n\n      if (params.hasActivities !== undefined) updates.HasActivities = params.hasActivities;\n      if (params.hasNotes !== undefined) updates.HasNotes = params.hasNotes;\n\n      await service.updateEntity(params.metadataId, updates, params.solutionUniqueName);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully updated entity (${params.metadataId})\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating entity:\", error);\n      return { content: [{ type: \"text\", text: `Failed to update entity: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "update-entity-icon",
        "code": "server.tool(\n  \"update-entity-icon\",\n  \"Update entity icon using Fluent UI System Icons from Microsoft's official icon library. Creates a web resource and sets it as the entity icon. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"The logical name of the entity (e.g., 'sic_strikeaction')\"),\n    iconFileName: z.string().describe(\"Fluent UI icon file name (e.g., 'people_community_24_filled.svg'). Browse icons at: https://github.com/microsoft/fluentui-system-icons\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add the web resource to (optional, uses POWERPLATFORM_DEFAULT_SOLUTION if not specified)\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const result = await service.updateEntityIcon(\n        params.entityLogicalName,\n        params.iconFileName,\n        params.solutionUniqueName\n      );\n\n      const message = `âœ… Successfully updated entity icon\n\n**Entity:** ${result.entityLogicalName} (${result.entitySchemaName})\n**Icon:** ${result.iconFileName}\n**Web Resource:** ${result.webResourceName}\n**Web Resource ID:** ${result.webResourceId}\n**Icon Vector Name:** ${result.iconVectorName}\n\nâœ¨ **Published:** The icon has been automatically published and should now be visible in the UI.\n\nðŸ’¡ TIP: Browse available Fluent UI icons at https://github.com/microsoft/fluentui-system-icons`;\n\n      return {\n        content: [{ type: \"text\", text: message }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating entity icon:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Failed to update entity icon: ${error.message}\\n\\nðŸ’¡ Make sure the icon file name is valid (e.g., 'people_community_24_filled.svg'). Browse available icons at https://github.com/microsoft/fluentui-system-icons`\n        }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-entity",
        "code": "server.tool(\n  \"delete-entity\",\n  \"Delete a custom entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    metadataId: z.string().describe(\"The MetadataId of the entity to delete (GUID)\")\n  },\n  async ({ metadataId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteEntity(metadataId);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully deleted entity (${metadataId})\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting entity:\", error);\n      return { content: [{ type: \"text\", text: `Failed to delete entity: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "create-attribute",
        "code": "server.tool(\n  \"create-attribute\",\n  \"Create a new attribute (column) on a Dynamics 365 entity. Supports most attribute types. CRITICAL LIMITATIONS: (1) Local option sets are NOT SUPPORTED - all Picklist/MultiSelectPicklist attributes MUST use global option sets. Provide 'optionSetOptions' to auto-create a new global option set, or 'globalOptionSetName' to reference existing. (2) Customer-type attributes (polymorphic lookups) CANNOT be created via SDK - use a standard Lookup to Account or Contact instead, or create manually via Power Apps maker portal. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"The logical name of the entity\"),\n    attributeType: z.enum([\n      \"String\", \"Memo\", \"Integer\", \"Decimal\", \"Money\", \"DateTime\",\n      \"Boolean\", \"Picklist\", \"Lookup\", \"Customer\", \"MultiSelectPicklist\", \"AutoNumber\"\n    ]).describe(\"The type of attribute to create\"),\n    schemaName: z.string().describe(\"The schema name of the attribute (e.g., 'sic_description')\"),\n    displayName: z.string().describe(\"The display name of the attribute\"),\n    description: z.string().optional().describe(\"Description of the attribute\"),\n    isRequired: z.boolean().optional().describe(\"Whether the attribute is required (default: false)\"),\n    // String-specific\n    maxLength: z.number().optional().describe(\"Max length (for String/Memo attributes)\"),\n    // AutoNumber-specific\n    autoNumberFormat: z.string().optional().describe(\n      \"Auto-number format string (for AutoNumber type). \" +\n      \"Use placeholders: {SEQNUM:n} for sequential number (min length n), \" +\n      \"{RANDSTRING:n} for random alphanumeric (length 1-6 only), \" +\n      \"{DATETIMEUTC:format} for UTC timestamp (.NET format). \" +\n      \"Example: 'AUTO-{SEQNUM:5}-{RANDSTRING:4}' produces AUTO-00001-A7K2, AUTO-00002-B9M4, etc.\"\n    ),\n    // Decimal/Money-specific\n    precision: z.number().optional().describe(\"Precision (for Decimal/Money attributes)\"),\n    minValue: z.number().optional().describe(\"Minimum value (for Integer/Decimal/Money attributes)\"),\n    maxValue: z.number().optional().describe(\"Maximum value (for Integer/Decimal/Money attributes)\"),\n    // DateTime-specific\n    dateTimeBehavior: z.enum([\"UserLocal\", \"DateOnly\", \"TimeZoneIndependent\"]).optional().describe(\"DateTime behavior\"),\n    // Picklist-specific\n    globalOptionSetName: z.string().optional().describe(\"Name of existing global option set to use (for Picklist/MultiSelectPicklist). If not provided and optionSetOptions is given, a new global option set will be created automatically.\"),\n    optionSetOptions: z.union([\n      z.array(z.string()),\n      z.array(z.object({\n        value: z.number(),\n        label: z.string()\n      }))\n    ]).optional().describe(\"Options for new global option set. Can be either: 1) Array of strings (values auto-numbered 0,1,2...) RECOMMENDED, or 2) Array of {value, label} objects for custom values. A global option set will be created automatically with the name matching the attribute SchemaName.\"),\n    // Lookup-specific\n    referencedEntity: z.string().optional().describe(\"Referenced entity logical name (for Lookup attributes)\"),\n    relationshipSchemaName: z.string().optional().describe(\"Schema name for the relationship (for Lookup attributes)\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add attribute to\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      // Validate Customer attribute type early with helpful error\n      if (params.attributeType === \"Customer\") {\n        throw new Error(\n          \"Customer-type attributes cannot be created via the PowerPlatform SDK.\\n\\n\" +\n          \"ðŸ”´ MICROSOFT LIMITATION: The Dataverse Web API does not support programmatic creation of Customer (polymorphic lookup) attributes.\\n\\n\" +\n          \"âœ… WORKAROUNDS:\\n\" +\n          \"1. Create manually via Power Apps maker portal (make.powerapps.com)\\n\" +\n          \"2. Use a standard Lookup to a specific entity:\\n\" +\n          \"   - For Account: Set attributeType='Lookup' and referencedEntity='account'\\n\" +\n          \"   - For Contact: Set attributeType='Lookup' and referencedEntity='contact'\\n\" +\n          \"3. Create separate lookup fields:\\n\" +\n          \"   - \" + params.schemaName + \"_account (Lookup to Account)\\n\" +\n          \"   - \" + params.schemaName + \"_contact (Lookup to Contact)\\n\" +\n          \"   - Use business logic to ensure only one is populated\\n\\n\" +\n          \"For more information, see Microsoft's documentation on Customer attributes.\"\n        );\n      }\n\n      // Build base attribute definition\n      const baseDefinition: any = {\n        SchemaName: params.schemaName,\n        RequiredLevel: {\n          Value: params.isRequired ? \"ApplicationRequired\" : \"None\",\n          CanBeChanged: true\n        },\n        DisplayName: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [\n            {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n              Label: params.displayName,\n              LanguageCode: 1033\n            }\n          ]\n        },\n        Description: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [\n            {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n              Label: params.description || \"\",\n              LanguageCode: 1033\n            }\n          ]\n        }\n      };\n\n      let attributeDefinition: any;\n\n      // Build type-specific definition\n      switch (params.attributeType) {\n        case \"String\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.StringAttributeMetadata\",\n            MaxLength: params.maxLength || 100,\n            FormatName: { Value: \"Text\" }\n          };\n          break;\n\n        case \"AutoNumber\":\n          if (!params.autoNumberFormat) {\n            throw new Error(\n              \"AutoNumber attributes require an 'autoNumberFormat' parameter.\\n\\n\" +\n              \"Format placeholders:\\n\" +\n              \"  {SEQNUM:n}         - Sequential number (min length n, grows as needed)\\n\" +\n              \"  {RANDSTRING:n}     - Random alphanumeric string (length 1-6 ONLY)\\n\" +\n              \"  {DATETIMEUTC:fmt}  - UTC timestamp with .NET format\\n\\n\" +\n              \"Examples:\\n\" +\n              \"  'AUTO-{SEQNUM:5}'                              â†’ AUTO-00001, AUTO-00002...\\n\" +\n              \"  'CASE-{SEQNUM:4}-{DATETIMEUTC:yyyyMMdd}'      â†’ CASE-0001-20250115\\n\" +\n              \"  'WID-{SEQNUM:3}-{RANDSTRING:6}'               â†’ WID-001-A7K2M9\\n\\n\" +\n              \"Note: RANDSTRING length must be 1-6 (API limitation)\"\n            );\n          }\n\n          // Validate RANDSTRING lengths (common error - API rejects length > 6)\n          const randstringMatches = params.autoNumberFormat.match(/\\{RANDSTRING:(\\d+)\\}/gi);\n          if (randstringMatches) {\n            for (const match of randstringMatches) {\n              const lengthMatch = match.match(/\\{RANDSTRING:(\\d+)\\}/i);\n              if (lengthMatch) {\n                const length = parseInt(lengthMatch[1]);\n                if (length < 1 || length > 6) {\n                  throw new Error(\n                    `Invalid RANDSTRING length: ${length}\\n\\n` +\n                    \"RANDSTRING must be between 1-6 characters (Dataverse API limitation).\\n\" +\n                    `Found in format: ${params.autoNumberFormat}\\n\\n` +\n                    `Please change {RANDSTRING:${length}} to {RANDSTRING:6} or less.`\n                  );\n                }\n              }\n            }\n          }\n\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.StringAttributeMetadata\",\n            AutoNumberFormat: params.autoNumberFormat,\n            MaxLength: params.maxLength || 100,  // Default to 100, user can override\n            FormatName: { Value: \"Text\" }  // MUST be Text for auto-number\n          };\n          break;\n\n        case \"Memo\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.MemoAttributeMetadata\",\n            MaxLength: params.maxLength || 2000,\n            Format: \"TextArea\"\n          };\n          break;\n\n        case \"Integer\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.IntegerAttributeMetadata\",\n            Format: \"None\",\n            MinValue: params.minValue ?? -2147483648,\n            MaxValue: params.maxValue ?? 2147483647\n          };\n          break;\n\n        case \"Decimal\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.DecimalAttributeMetadata\",\n            Precision: params.precision || 2,\n            MinValue: params.minValue ?? -100000000000,\n            MaxValue: params.maxValue ?? 100000000000\n          };\n          break;\n\n        case \"Money\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.MoneyAttributeMetadata\",\n            Precision: params.precision || 2,\n            MinValue: params.minValue ?? -922337203685477,\n            MaxValue: params.maxValue ?? 922337203685477,\n            PrecisionSource: 2\n          };\n          break;\n\n        case \"DateTime\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.DateTimeAttributeMetadata\",\n            Format: params.dateTimeBehavior === \"DateOnly\" ? \"DateOnly\" : \"DateAndTime\",\n            DateTimeBehavior: {\n              Value: params.dateTimeBehavior || \"UserLocal\"\n            }\n          };\n          break;\n\n        case \"Boolean\":\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.BooleanAttributeMetadata\",\n            DefaultValue: false,\n            OptionSet: {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.BooleanOptionSetMetadata\",\n              TrueOption: {\n                Value: 1,\n                Label: {\n                  \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                  LocalizedLabels: [\n                    {\n                      \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                      Label: \"Yes\",\n                      LanguageCode: 1033\n                    }\n                  ]\n                }\n              },\n              FalseOption: {\n                Value: 0,\n                Label: {\n                  \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                  LocalizedLabels: [\n                    {\n                      \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                      Label: \"No\",\n                      LanguageCode: 1033\n                    }\n                  ]\n                }\n              }\n            }\n          };\n          break;\n\n        case \"Picklist\":\n          // ALWAYS use global option sets\n          if (params.globalOptionSetName) {\n            // Using existing global option set - need to look up its MetadataId first\n            const globalOptionSet = await service.getGlobalOptionSet(params.globalOptionSetName);\n            const metadataId = globalOptionSet.MetadataId;\n\n            attributeDefinition = {\n              ...baseDefinition,\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.PicklistAttributeMetadata\",\n              \"GlobalOptionSet@odata.bind\": `/GlobalOptionSetDefinitions(${metadataId})`\n            };\n          } else if (params.optionSetOptions && params.optionSetOptions.length > 0) {\n            // Create NEW global option set in TWO steps:\n            // Step 1: Create the global option set separately\n            // Step 2: Create the attribute that references it\n\n            const optionSetName = params.schemaName;\n\n            // Normalize options: support both string[] (auto-numbered) and {value, label}[] formats\n            const normalizedOptions = params.optionSetOptions.map((opt, index) => {\n              if (typeof opt === 'string') {\n                // Auto-number from 0\n                return {\n                  Value: index,\n                  Label: {\n                    \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                    LocalizedLabels: [\n                      {\n                        \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                        Label: opt,\n                        LanguageCode: 1033\n                      }\n                    ]\n                  }\n                };\n              } else {\n                // User provided explicit value\n                return {\n                  Value: opt.value,\n                  Label: {\n                    \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                    LocalizedLabels: [\n                      {\n                        \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                        Label: opt.label,\n                        LanguageCode: 1033\n                      }\n                    ]\n                  }\n                };\n              }\n            });\n\n            // Step 1: Create the global option set first\n            const globalOptionSetDefinition = {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.OptionSetMetadata\",\n              Name: optionSetName,\n              DisplayName: baseDefinition.DisplayName,\n              Description: baseDefinition.Description,\n              IsGlobal: true,\n              OptionSetType: \"Picklist\",\n              Options: normalizedOptions\n            };\n\n            // Store this for later - we'll create it before the attribute\n            (baseDefinition as any)._createGlobalOptionSetFirst = globalOptionSetDefinition;\n            (baseDefinition as any)._globalOptionSetNameToLookup = optionSetName;\n\n            // Step 2: Create attribute definition that REFERENCES the global option set\n            // The MetadataId binding will be set after creating the global option set\n            attributeDefinition = {\n              ...baseDefinition,\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.PicklistAttributeMetadata\"\n            };\n          } else {\n            throw new Error(\n              \"For Picklist attributes, you must provide either:\\n\" +\n              \"1. 'globalOptionSetName' to reference an existing global option set, OR\\n\" +\n              \"2. 'optionSetOptions' to create a new global option set automatically\\n\\n\" +\n              \"Note: Local option sets are not supported - all option sets are created as global for consistency and reusability.\"\n            );\n          }\n          break;\n\n        case \"Lookup\":\n          if (!params.referencedEntity) {\n            throw new Error(\"referencedEntity is required for Lookup attributes\");\n          }\n          attributeDefinition = {\n            ...baseDefinition,\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.LookupAttributeMetadata\",\n            Targets: [params.referencedEntity]\n          };\n\n          // For lookups, we also need relationship information\n          if (params.relationshipSchemaName) {\n            (attributeDefinition as any).RelationshipSchemaName = params.relationshipSchemaName;\n          }\n          break;\n\n\n        case \"MultiSelectPicklist\":\n          // ALWAYS use global option sets\n          if (params.globalOptionSetName) {\n            // Using existing global option set - need to look up its MetadataId first\n            const globalOptionSet = await service.getGlobalOptionSet(params.globalOptionSetName);\n            const metadataId = globalOptionSet.MetadataId;\n\n            attributeDefinition = {\n              ...baseDefinition,\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.MultiSelectPicklistAttributeMetadata\",\n              \"GlobalOptionSet@odata.bind\": `/GlobalOptionSetDefinitions(${metadataId})`\n            };\n          } else if (params.optionSetOptions && params.optionSetOptions.length > 0) {\n            // Create NEW global option set in TWO steps:\n            // Step 1: Create the global option set separately\n            // Step 2: Create the attribute that references it\n\n            const optionSetName = params.schemaName;\n\n            // Normalize options: support both string[] (auto-numbered) and {value, label}[] formats\n            const normalizedOptions = params.optionSetOptions.map((opt, index) => {\n              if (typeof opt === 'string') {\n                // Auto-number from 0\n                return {\n                  Value: index,\n                  Label: {\n                    \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                    LocalizedLabels: [\n                      {\n                        \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                        Label: opt,\n                        LanguageCode: 1033\n                      }\n                    ]\n                  }\n                };\n              } else {\n                // User provided explicit value\n                return {\n                  Value: opt.value,\n                  Label: {\n                    \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n                    LocalizedLabels: [\n                      {\n                        \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\",\n                        Label: opt.label,\n                        LanguageCode: 1033\n                      }\n                    ]\n                  }\n                };\n              }\n            });\n\n            // Step 1: Create the global option set first\n            const globalOptionSetDefinition = {\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.OptionSetMetadata\",\n              Name: optionSetName,\n              DisplayName: baseDefinition.DisplayName,\n              Description: baseDefinition.Description,\n              IsGlobal: true,\n              OptionSetType: \"Picklist\",\n              Options: normalizedOptions\n            };\n\n            // Store this for later - we'll create it before the attribute\n            (baseDefinition as any)._createGlobalOptionSetFirst = globalOptionSetDefinition;\n            (baseDefinition as any)._globalOptionSetNameToLookup = optionSetName;\n\n            // Step 2: Create attribute definition that REFERENCES the global option set\n            // The MetadataId binding will be set after creating the global option set\n            attributeDefinition = {\n              ...baseDefinition,\n              \"@odata.type\": \"Microsoft.Dynamics.CRM.MultiSelectPicklistAttributeMetadata\"\n            };\n          } else {\n            throw new Error(\n              \"For MultiSelectPicklist attributes, you must provide either:\\n\" +\n              \"1. 'globalOptionSetName' to reference an existing global option set, OR\\n\" +\n              \"2. 'optionSetOptions' to create a new global option set automatically\\n\\n\" +\n              \"Note: Local option sets are not supported - all option sets are created as global for consistency and reusability.\"\n            );\n          }\n          break;\n\n        default:\n          throw new Error(`Attribute type '${params.attributeType}' is not yet fully implemented. Contact support.`);\n      }\n\n      const solutionName = params.solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION || undefined;\n\n      // Check if we need to create a global option set first (two-step process)\n      if ((attributeDefinition as any)._createGlobalOptionSetFirst) {\n        const globalOptionSetDef = (attributeDefinition as any)._createGlobalOptionSetFirst;\n        const optionSetNameToLookup = (attributeDefinition as any)._globalOptionSetNameToLookup;\n        delete (attributeDefinition as any)._createGlobalOptionSetFirst; // Clean up marker\n        delete (attributeDefinition as any)._globalOptionSetNameToLookup;\n\n        // Step 1: Create the global option set\n        await service.createGlobalOptionSet(globalOptionSetDef, solutionName);\n\n        // Step 1.5: Look up the created global option set to get its MetadataId\n        const createdGlobalOptionSet = await service.getGlobalOptionSet(optionSetNameToLookup);\n        const metadataId = createdGlobalOptionSet.MetadataId;\n\n        // Add the binding to the attribute definition\n        (attributeDefinition as any)[\"GlobalOptionSet@odata.bind\"] = `/GlobalOptionSetDefinitions(${metadataId})`;\n      }\n\n      // Step 2: Create the attribute (which now references the global option set)\n      const result = await service.createAttribute(\n        params.entityLogicalName,\n        attributeDefinition,\n        solutionName\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Successfully created ${params.attributeType} attribute '${params.schemaName}' on entity '${params.entityLogicalName}'.\\n\\n` +\n                  (params.attributeType === \"AutoNumber\" && params.autoNumberFormat ? `Auto-number format: ${params.autoNumberFormat}\\n\\n` : \"\") +\n                  `Details:\\n${JSON.stringify(result, null, 2)}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating attribute:\", error);\n\n      // Provide helpful guidance for common errors\n      let errorMessage = error.message;\n      let helpfulGuidance = \"\";\n\n      // Detect global option set errors\n      if (errorMessage.includes(\"IsGlobal\") || errorMessage.includes(\"0x80048403\")) {\n        helpfulGuidance = \"\\n\\nðŸ”´ ERROR EXPLANATION: An error occurred while creating the global option set.\\n\\n\" +\n          \"âœ… SOLUTION: This tool creates global option sets in a two-step process:\\n\" +\n          \"1. First, it creates the global option set\\n\" +\n          \"2. Then, it creates the attribute that references it\\n\\n\" +\n          \"This error may mean:\\n\" +\n          \"- A global option set with name '\" + params.schemaName + \"' already exists\\n\" +\n          \"- There was an issue with the option set definition\\n\\n\" +\n          \"Try using a different schema name or reference the existing global option set:\\n\" +\n          \"{\\n\" +\n          \"  entityLogicalName: \\\"\" + params.entityLogicalName + \"\\\",\\n\" +\n          \"  attributeType: \\\"\" + params.attributeType + \"\\\",\\n\" +\n          \"  schemaName: \\\"\" + params.schemaName + \"\\\",\\n\" +\n          \"  displayName: \\\"\" + params.displayName + \"\\\",\\n\" +\n          \"  globalOptionSetName: \\\"existing_option_set_name\\\"\\n\" +\n          \"}\";\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create attribute: ${errorMessage}${helpfulGuidance}`\n          }\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-attribute",
        "code": "server.tool(\n  \"update-attribute\",\n  \"Update an existing attribute on an entity. Supports converting String attributes to AutoNumber by setting autoNumberFormat. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\"),\n    attributeLogicalName: z.string().describe(\"Attribute logical name\"),\n    displayName: z.string().optional().describe(\"New display name\"),\n    description: z.string().optional().describe(\"New description\"),\n    requiredLevel: z.enum([\"None\", \"Recommended\", \"ApplicationRequired\"]).optional().describe(\"Required level\"),\n    autoNumberFormat: z.string().optional().describe(\n      \"Auto-number format string to convert String attribute to AutoNumber. \" +\n      \"Use placeholders: {SEQNUM:n} for sequential number (min length n), \" +\n      \"{RANDSTRING:n} for random alphanumeric (length 1-6 only), \" +\n      \"{DATETIMEUTC:format} for UTC timestamp (.NET format). \" +\n      \"Example: 'AUTO-{SEQNUM:5}-{RANDSTRING:4}' produces AUTO-00001-A7K2, AUTO-00002-B9M4, etc.\"\n    ),\n    solutionUniqueName: z.string().optional().describe(\"Solution context\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n\n      if (params.displayName) {\n        updates.DisplayName = {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.displayName, LanguageCode: 1033 }]\n        };\n      }\n\n      if (params.description) {\n        updates.Description = {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.description, LanguageCode: 1033 }]\n        };\n      }\n\n      if (params.requiredLevel) {\n        updates.RequiredLevel = { Value: params.requiredLevel, CanBeChanged: true };\n      }\n\n      // Handle AutoNumber format conversion\n      if (params.autoNumberFormat) {\n        // Validate RANDSTRING lengths (common error - API rejects length > 6)\n        const randstringMatches = params.autoNumberFormat.match(/\\{RANDSTRING:(\\d+)\\}/gi);\n        if (randstringMatches) {\n          for (const match of randstringMatches) {\n            const lengthMatch = match.match(/\\{RANDSTRING:(\\d+)\\}/i);\n            if (lengthMatch) {\n              const length = parseInt(lengthMatch[1]);\n              if (length < 1 || length > 6) {\n                throw new Error(\n                  `Invalid RANDSTRING length: ${length}\\n\\n` +\n                  \"RANDSTRING must be between 1-6 characters (Dataverse API limitation).\\n\" +\n                  `Found in format: ${params.autoNumberFormat}\\n\\n` +\n                  `Please change {RANDSTRING:${length}} to {RANDSTRING:6} or less.`\n                );\n              }\n            }\n          }\n        }\n\n        updates.AutoNumberFormat = params.autoNumberFormat;\n      }\n\n      await service.updateAttribute(params.entityLogicalName, params.attributeLogicalName, updates, params.solutionUniqueName);\n\n      let successMessage = `âœ… Successfully updated attribute '${params.attributeLogicalName}' on entity '${params.entityLogicalName}'`;\n\n      if (params.autoNumberFormat) {\n        successMessage += `\\n\\nðŸ“‹ Auto-number format set to: ${params.autoNumberFormat}`;\n        successMessage += `\\n\\nâš ï¸ NOTE: Converting to AutoNumber is irreversible. The attribute will now auto-generate values based on the format.`;\n      }\n\n      successMessage += `\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`;\n\n      return {\n        content: [{ type: \"text\", text: successMessage }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating attribute:\", error);\n      return { content: [{ type: \"text\", text: `Failed to update attribute: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "delete-attribute",
        "code": "server.tool(\n  \"delete-attribute\",\n  \"Delete an attribute from an entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\"),\n    attributeMetadataId: z.string().describe(\"Attribute MetadataId (GUID)\")\n  },\n  async ({ entityLogicalName, attributeMetadataId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteAttribute(entityLogicalName, attributeMetadataId);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully deleted attribute (${attributeMetadataId}) from entity '${entityLogicalName}'\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting attribute:\", error);\n      return { content: [{ type: \"text\", text: `Failed to delete attribute: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "create-one-to-many-relationship",
        "code": "server.tool(\n  \"create-one-to-many-relationship\",\n  \"Create a one-to-many relationship between two entities. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    referencedEntity: z.string().describe(\"The 'one' side entity (parent)\"),\n    referencingEntity: z.string().describe(\"The 'many' side entity (child)\"),\n    schemaName: z.string().describe(\"Relationship schema name (e.g., 'sic_account_application')\"),\n    lookupAttributeSchemaName: z.string().describe(\"Lookup attribute schema name (e.g., 'sic_accountid')\"),\n    lookupAttributeDisplayName: z.string().describe(\"Lookup attribute display name\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const relationshipDefinition = {\n        \"@odata.type\": \"Microsoft.Dynamics.CRM.OneToManyRelationshipMetadata\",\n        SchemaName: params.schemaName,\n        ReferencedEntity: params.referencedEntity,\n        ReferencingEntity: params.referencingEntity,\n        Lookup: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.LookupAttributeMetadata\",\n          SchemaName: params.lookupAttributeSchemaName,\n          DisplayName: {\n            \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n            LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.lookupAttributeDisplayName, LanguageCode: 1033 }]\n          }\n        }\n      };\n\n      const solution = params.solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.createOneToManyRelationship(relationshipDefinition, solution);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully created 1:N relationship '${params.schemaName}'\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating relationship:\", error);\n      return { content: [{ type: \"text\", text: `Failed to create relationship: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "create-many-to-many-relationship",
        "code": "server.tool(\n  \"create-many-to-many-relationship\",\n  \"Create a many-to-many relationship between two entities. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entity1: z.string().describe(\"First entity logical name\"),\n    entity2: z.string().describe(\"Second entity logical name\"),\n    schemaName: z.string().describe(\"Relationship schema name (e.g., 'sic_account_contact')\"),\n    intersectEntityName: z.string().describe(\"Intersect entity name (e.g., 'sic_account_contact')\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const relationshipDefinition = {\n        \"@odata.type\": \"Microsoft.Dynamics.CRM.ManyToManyRelationshipMetadata\",\n        SchemaName: params.schemaName,\n        Entity1LogicalName: params.entity1,\n        Entity2LogicalName: params.entity2,\n        IntersectEntityName: params.intersectEntityName\n      };\n\n      const solution = params.solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.createManyToManyRelationship(relationshipDefinition, solution);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully created N:N relationship '${params.schemaName}'\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating relationship:\", error);\n      return { content: [{ type: \"text\", text: `Failed to create relationship: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "delete-relationship",
        "code": "server.tool(\n  \"delete-relationship\",\n  \"Delete a relationship. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    metadataId: z.string().describe(\"Relationship MetadataId (GUID)\")\n  },\n  async ({ metadataId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteRelationship(metadataId);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully deleted relationship (${metadataId})\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting relationship:\", error);\n      return { content: [{ type: \"text\", text: `Failed to delete relationship: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "update-relationship",
        "code": "server.tool(\n  \"update-relationship\",\n  \"Update relationship labels. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    metadataId: z.string().describe(\"Relationship MetadataId (GUID)\"),\n    referencedEntityNavigationPropertyName: z.string().optional().describe(\"Navigation property name\"),\n    referencingEntityNavigationPropertyName: z.string().optional().describe(\"Navigation property name\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n      if (params.referencedEntityNavigationPropertyName) updates.ReferencedEntityNavigationPropertyName = params.referencedEntityNavigationPropertyName;\n      if (params.referencingEntityNavigationPropertyName) updates.ReferencingEntityNavigationPropertyName = params.referencingEntityNavigationPropertyName;\n\n      await service.updateRelationship(params.metadataId, updates);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully updated relationship (${params.metadataId})\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating relationship:\", error);\n      return { content: [{ type: \"text\", text: `Failed to update relationship: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "get-relationship-details",
        "code": "server.tool(\n  \"get-relationship-details\",\n  \"Get detailed metadata about a relationship\",\n  {\n    metadataId: z.string().describe(\"Relationship MetadataId (GUID)\")\n  },\n  async ({ metadataId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const relationship = await service.getRelationshipDetails(metadataId);\n\n      return {\n        content: [{ type: \"text\", text: `Relationship Details:\\n${JSON.stringify(relationship, null, 2)}` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting relationship details:\", error);\n      return { content: [{ type: \"text\", text: `Failed to get relationship details: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "create-global-optionset-attribute",
        "code": "server.tool(\n  \"create-global-optionset-attribute\",\n  \"Create a picklist attribute using an existing global option set. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\"),\n    schemaName: z.string().describe(\"Attribute schema name\"),\n    displayName: z.string().describe(\"Attribute display name\"),\n    globalOptionSetName: z.string().describe(\"Global option set name to use\"),\n    description: z.string().optional().describe(\"Attribute description\"),\n    requiredLevel: z.enum([\"None\", \"Recommended\", \"ApplicationRequired\"]).optional().describe(\"Required level (default: None)\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async (params) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      // Look up the global option set to get its MetadataId\n      const globalOptionSet = await service.getGlobalOptionSet(params.globalOptionSetName);\n      const metadataId = globalOptionSet.MetadataId;\n\n      const attributeDefinition = {\n        \"@odata.type\": \"Microsoft.Dynamics.CRM.PicklistAttributeMetadata\",\n        SchemaName: params.schemaName,\n        DisplayName: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.displayName, LanguageCode: 1033 }]\n        },\n        Description: {\n          \"@odata.type\": \"Microsoft.Dynamics.CRM.Label\",\n          LocalizedLabels: [{ \"@odata.type\": \"Microsoft.Dynamics.CRM.LocalizedLabel\", Label: params.description || \"\", LanguageCode: 1033 }]\n        },\n        RequiredLevel: { Value: params.requiredLevel || \"None\", CanBeChanged: true },\n        \"GlobalOptionSet@odata.bind\": `/GlobalOptionSetDefinitions(${metadataId})`\n      };\n\n      const solution = params.solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      const result = await service.createGlobalOptionSetAttribute(params.entityLogicalName, attributeDefinition, solution);\n\n      return {\n        content: [{ type: \"text\", text: `âœ… Successfully created global option set attribute '${params.schemaName}' using '${params.globalOptionSetName}'\\n\\nâš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating global option set attribute:\", error);\n      return { content: [{ type: \"text\", text: `Failed to create global option set attribute: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "get-webresource-dependencies",
        "code": "server.tool(\n  \"get-webresource-dependencies\",\n  \"Get all dependencies for a web resource\",\n  {\n    webResourceId: z.string().describe(\"Web resource ID (GUID)\")\n  },\n  async ({ webResourceId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const dependencies = await service.getWebResourceDependencies(webResourceId);\n\n      return {\n        content: [{ type: \"text\", text: `Web Resource Dependencies:\\n${JSON.stringify(dependencies, null, 2)}` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting web resource dependencies:\", error);\n      return { content: [{ type: \"text\", text: `Failed to get web resource dependencies: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "preview-unpublished-changes",
        "code": "server.tool(\n  \"preview-unpublished-changes\",\n  \"Preview all components with unpublished customizations\",\n  {},\n  async () => {\n    try {\n      const service = getPowerPlatformService();\n      const unpublished = await service.previewUnpublishedChanges();\n\n      return {\n        content: [{ type: \"text\", text: `Unpublished Changes:\\n${JSON.stringify(unpublished, null, 2)}` }]\n      };\n    } catch (error: any) {\n      console.error(\"Error previewing unpublished changes:\", error);\n      return { content: [{ type: \"text\", text: `Failed to preview unpublished changes: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "validate-solution-integrity",
        "code": "server.tool(\n  \"validate-solution-integrity\",\n  \"Validate a solution's integrity and check for missing dependencies\",\n  {\n    solutionUniqueName: z.string().describe(\"Solution unique name\")\n  },\n  async ({ solutionUniqueName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const validation = await service.validateSolutionIntegrity(solutionUniqueName);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Solution Integrity Validation:\\n\\n` +\n                `Valid: ${validation.isValid ? 'âœ… Yes' : 'âŒ No'}\\n` +\n                `Issues: ${validation.issues.length}\\n` +\n                `Warnings: ${validation.warnings.length}\\n\\n` +\n                (validation.issues.length > 0 ? `Issues:\\n${JSON.stringify(validation.issues, null, 2)}\\n\\n` : '') +\n                (validation.warnings.length > 0 ? `Warnings:\\n${JSON.stringify(validation.warnings, null, 2)}` : '')\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error validating solution integrity:\", error);\n      return { content: [{ type: \"text\", text: `Failed to validate solution integrity: ${error.message}` }], isError: true };\n    }\n  }\n);"
      },
      {
        "name": "publish-customizations",
        "code": "server.tool(\n  \"publish-customizations\",\n  \"Publish all pending customizations in Dynamics 365. This makes all unpublished changes active. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {},\n  async () => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.publishAllCustomizations();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Successfully published all customizations. All pending changes are now active.\"\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error publishing customizations:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to publish customizations: ${error.message}`\n          }\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-global-optionset",
        "code": "server.tool(\n  \"update-global-optionset\",\n  \"Update a global option set in Dynamics 365. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    metadataId: z.string().describe(\"The MetadataId of the option set\"),\n    displayName: z.string().optional().describe(\"New display name\"),\n    description: z.string().optional().describe(\"New description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to (optional, uses POWERPLATFORM_DEFAULT_SOLUTION if not provided)\")\n  },\n  async ({ metadataId, displayName, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = { '@odata.type': 'Microsoft.Dynamics.CRM.OptionSetMetadata' };\n\n      if (displayName) {\n        updates.DisplayName = {\n          LocalizedLabels: [{ Label: displayName, LanguageCode: 1033 }]\n        };\n      }\n\n      if (description) {\n        updates.Description = {\n          LocalizedLabels: [{ Label: description, LanguageCode: 1033 }]\n        };\n      }\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.updateGlobalOptionSet(metadataId, updates, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully updated global option set (${metadataId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating global option set:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to update global option set: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "add-optionset-value",
        "code": "server.tool(\n  \"add-optionset-value\",\n  \"Add a new value to a global option set in Dynamics 365. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    optionSetName: z.string().describe(\"The name of the option set\"),\n    value: z.number().describe(\"The numeric value (should start with publisher prefix, e.g., 15743xxxx)\"),\n    label: z.string().describe(\"The display label for the value\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ optionSetName, value, label, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.addOptionSetValue(optionSetName, value, label, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully added value to option set '${optionSetName}'\\n` +\n                  `Value: ${value}\\n` +\n                  `Label: ${label}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error adding option set value:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to add option set value: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-optionset-value",
        "code": "server.tool(\n  \"update-optionset-value\",\n  \"Update an existing value in a global option set. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    optionSetName: z.string().describe(\"The name of the option set\"),\n    value: z.number().describe(\"The numeric value to update\"),\n    label: z.string().describe(\"The new display label\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ optionSetName, value, label, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.updateOptionSetValue(optionSetName, value, label, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully updated value in option set '${optionSetName}'\\n` +\n                  `Value: ${value}\\n` +\n                  `New Label: ${label}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating option set value:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to update option set value: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-optionset-value",
        "code": "server.tool(\n  \"delete-optionset-value\",\n  \"Delete a value from a global option set. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    optionSetName: z.string().describe(\"The name of the option set\"),\n    value: z.number().describe(\"The numeric value to delete\")\n  },\n  async ({ optionSetName, value }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteOptionSetValue(optionSetName, value);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully deleted value ${value} from option set '${optionSetName}'\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting option set value:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to delete option set value: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "reorder-optionset-values",
        "code": "server.tool(\n  \"reorder-optionset-values\",\n  \"Reorder the values in a global option set. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    optionSetName: z.string().describe(\"The name of the option set\"),\n    values: z.array(z.number()).describe(\"Array of values in the desired order\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ optionSetName, values, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.reorderOptionSetValues(optionSetName, values, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully reordered ${values.length} values in option set '${optionSetName}'\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error reordering option set values:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to reorder option set values: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-form",
        "code": "server.tool(\n  \"create-form\",\n  \"Create a new form (Main, QuickCreate, QuickView, Card) for an entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    name: z.string().describe(\"Form name\"),\n    entityLogicalName: z.string().describe(\"Entity logical name\"),\n    formType: z.enum([\"Main\", \"QuickCreate\", \"QuickView\", \"Card\"]).describe(\"Form type\"),\n    formXml: z.string().describe(\"Form XML definition\"),\n    description: z.string().optional().describe(\"Form description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ name, entityLogicalName, formType, formXml, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const typeMap = { Main: 2, QuickCreate: 7, QuickView: 8, Card: 10 };\n      const form = {\n        name,\n        objecttypecode: entityLogicalName,\n        type: typeMap[formType],\n        formxml: formXml,\n        description: description || \"\"\n      };\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      const result = await service.createForm(form, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully created ${formType} form '${name}' for entity '${entityLogicalName}'\\n` +\n                  `Form ID: ${result.formid}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating form:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to create form: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-form",
        "code": "server.tool(\n  \"update-form\",\n  \"Update an existing form. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    formId: z.string().describe(\"Form ID (GUID)\"),\n    name: z.string().optional().describe(\"New form name\"),\n    formXml: z.string().optional().describe(\"New form XML definition\"),\n    description: z.string().optional().describe(\"New description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ formId, name, formXml, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n      if (name) updates.name = name;\n      if (formXml) updates.formxml = formXml;\n      if (description) updates.description = description;\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.updateForm(formId, updates, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully updated form (${formId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating form:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to update form: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-form",
        "code": "server.tool(\n  \"delete-form\",\n  \"Delete a form. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    formId: z.string().describe(\"Form ID (GUID)\")\n  },\n  async ({ formId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteForm(formId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully deleted form (${formId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting form:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to delete form: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "activate-form",
        "code": "server.tool(\n  \"activate-form\",\n  \"Activate a form. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    formId: z.string().describe(\"Form ID (GUID)\")\n  },\n  async ({ formId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.activateForm(formId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully activated form (${formId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error activating form:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to activate form: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "deactivate-form",
        "code": "server.tool(\n  \"deactivate-form\",\n  \"Deactivate a form. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    formId: z.string().describe(\"Form ID (GUID)\")\n  },\n  async ({ formId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deactivateForm(formId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully deactivated form (${formId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error deactivating form:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to deactivate form: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-forms",
        "code": "server.tool(\n  \"get-forms\",\n  \"Get all forms for an entity\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\")\n  },\n  async ({ entityLogicalName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getForms(entityLogicalName);\n\n      const forms = result.value || [];\n      const typeNames: { [key: number]: string } = { 2: \"Main\", 7: \"QuickCreate\", 8: \"QuickView\", 10: \"Card\" };\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${forms.length} form(s) for entity '${entityLogicalName}':\\n\\n` +\n                  forms.map((f: any) =>\n                    `- ${f.name} (${typeNames[f.type] || f.type})\\n  ID: ${f.formid}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting forms:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get forms: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-view",
        "code": "server.tool(\n  \"create-view\",\n  \"Create a new view for an entity using FetchXML. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    name: z.string().describe(\"View name\"),\n    entityLogicalName: z.string().describe(\"Entity logical name\"),\n    fetchXml: z.string().describe(\"FetchXML query\"),\n    layoutXml: z.string().describe(\"Layout XML (column definitions)\"),\n    queryType: z.number().optional().describe(\"Query type (default: 0 for public view)\"),\n    isDefault: z.boolean().optional().describe(\"Set as default view\"),\n    description: z.string().optional().describe(\"View description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ name, entityLogicalName, fetchXml, layoutXml, queryType, isDefault, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const view = {\n        name,\n        returnedtypecode: entityLogicalName,\n        fetchxml: fetchXml,\n        layoutxml: layoutXml,\n        querytype: queryType || 0,\n        isdefault: isDefault || false,\n        description: description || \"\"\n      };\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      const result = await service.createView(view, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully created view '${name}' for entity '${entityLogicalName}'\\n` +\n                  `View ID: ${result.savedqueryid}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating view:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to create view: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-view",
        "code": "server.tool(\n  \"update-view\",\n  \"Update an existing view. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    viewId: z.string().describe(\"View ID (GUID)\"),\n    name: z.string().optional().describe(\"New view name\"),\n    fetchXml: z.string().optional().describe(\"New FetchXML query\"),\n    layoutXml: z.string().optional().describe(\"New layout XML\"),\n    isDefault: z.boolean().optional().describe(\"Set as default view\"),\n    description: z.string().optional().describe(\"New description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ viewId, name, fetchXml, layoutXml, isDefault, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n      if (name) updates.name = name;\n      if (fetchXml) updates.fetchxml = fetchXml;\n      if (layoutXml) updates.layoutxml = layoutXml;\n      if (isDefault !== undefined) updates.isdefault = isDefault;\n      if (description) updates.description = description;\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.updateView(viewId, updates, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully updated view (${viewId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating view:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to update view: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-view",
        "code": "server.tool(\n  \"delete-view\",\n  \"Delete a view. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    viewId: z.string().describe(\"View ID (GUID)\")\n  },\n  async ({ viewId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteView(viewId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully deleted view (${viewId})\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting view:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to delete view: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-views",
        "code": "server.tool(\n  \"get-views\",\n  \"Get all views for an entity\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\")\n  },\n  async ({ entityLogicalName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getViews(entityLogicalName);\n\n      const views = result.value || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${views.length} view(s) for entity '${entityLogicalName}':\\n\\n` +\n                  views.map((v: any) =>\n                    `- ${v.name}${v.isdefault ? ' [DEFAULT]' : ''}\\n  ID: ${v.savedqueryid}\\n  Query Type: ${v.querytype}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting views:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get views: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "set-default-view",
        "code": "server.tool(\n  \"set-default-view\",\n  \"Set a view as the default view for its entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    viewId: z.string().describe(\"View ID (GUID)\")\n  },\n  async ({ viewId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.setDefaultView(viewId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully set view (${viewId}) as default\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error setting default view:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to set default view: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-view-fetchxml",
        "code": "server.tool(\n  \"get-view-fetchxml\",\n  \"Get the FetchXML query from a view\",\n  {\n    viewId: z.string().describe(\"View ID (GUID)\")\n  },\n  async ({ viewId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const view = await service.getViewFetchXml(viewId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `View: ${view.name}\\nEntity: ${view.returnedtypecode}\\nQuery Type: ${view.querytype}\\n\\nFetchXML:\\n${view.fetchxml}`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting view FetchXML:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get view FetchXML: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-web-resource",
        "code": "server.tool(\n  \"create-web-resource\",\n  \"Create a new web resource (JavaScript, CSS, HTML, Image, etc.). Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    name: z.string().describe(\"Web resource name (must include prefix, e.g., 'prefix_/scripts/file.js')\"),\n    displayName: z.string().describe(\"Display name\"),\n    webResourceType: z.number().describe(\"Web resource type: 1=HTML, 2=CSS, 3=JavaScript, 4=XML, 5=PNG, 6=JPG, 7=GIF, 8=XAP, 9=XSL, 10=ICO\"),\n    content: z.string().describe(\"Base64-encoded content\"),\n    description: z.string().optional().describe(\"Description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution to add to\")\n  },\n  async ({ name, displayName, webResourceType, content, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const webResource = {\n        name,\n        displayname: displayName,\n        webresourcetype: webResourceType,\n        content,\n        description: description || \"\"\n      };\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      const result = await service.createWebResource(webResource, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully created web resource '${name}'\\n` +\n                  `Web Resource ID: ${result.webresourceid}\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating web resource:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to create web resource: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-web-resource",
        "code": "server.tool(\n  \"update-web-resource\",\n  \"Update an existing web resource. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    webResourceId: z.string().describe(\"Web resource ID (GUID)\"),\n    displayName: z.string().optional().describe(\"Display name\"),\n    content: z.string().optional().describe(\"Base64-encoded content\"),\n    description: z.string().optional().describe(\"Description\"),\n    solutionUniqueName: z.string().optional().describe(\"Solution context\")\n  },\n  async ({ webResourceId, displayName, content, description, solutionUniqueName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const updates: any = {};\n      if (displayName) updates.displayname = displayName;\n      if (content) updates.content = content;\n      if (description) updates.description = description;\n\n      const solution = solutionUniqueName || POWERPLATFORM_DEFAULT_SOLUTION;\n      await service.updateWebResource(webResourceId, updates, solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully updated web resource '${webResourceId}'\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating web resource:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to update web resource: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-web-resource",
        "code": "server.tool(\n  \"delete-web-resource\",\n  \"Delete a web resource. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    webResourceId: z.string().describe(\"Web resource ID (GUID)\")\n  },\n  async ({ webResourceId }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.deleteWebResource(webResourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully deleted web resource '${webResourceId}'\\n\\n` +\n                  `âš ï¸ IMPORTANT: You must publish this customization using the 'publish-customizations' tool before it becomes active.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting web resource:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to delete web resource: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-web-resource",
        "code": "server.tool(\n  \"get-web-resource\",\n  \"Get a web resource by ID\",\n  {\n    webResourceId: z.string().describe(\"Web resource ID (GUID)\")\n  },\n  async ({ webResourceId }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWebResource(webResourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Web Resource: ${result.name}\\n` +\n                  `Display Name: ${result.displayname}\\n` +\n                  `Type: ${result.webresourcetype}\\n` +\n                  `Description: ${result.description || 'N/A'}\\n` +\n                  `Modified: ${result.modifiedon}`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting web resource:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get web resource: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-web-resources",
        "code": "server.tool(\n  \"get-web-resources\",\n  \"Get web resources by name pattern (optional)\",\n  {\n    nameFilter: z.string().optional().describe(\"Name filter (contains)\")\n  },\n  async ({ nameFilter }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWebResources(nameFilter);\n\n      const webResources = result.value || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${webResources.length} web resource(s):\\n\\n` +\n                  webResources.map((wr: any) =>\n                    `- ${wr.name}\\n  Type: ${wr.webresourcetype}\\n  ID: ${wr.webresourceid}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting web resources:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get web resources: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-publisher",
        "code": "server.tool(\n  \"create-publisher\",\n  \"Create a new solution publisher. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    uniqueName: z.string().describe(\"Publisher unique name\"),\n    friendlyName: z.string().describe(\"Publisher display name\"),\n    customizationPrefix: z.string().describe(\"Customization prefix (e.g., 'new')\"),\n    customizationOptionValuePrefix: z.number().describe(\"Option value prefix (e.g., 10000)\"),\n    description: z.string().optional().describe(\"Publisher description\")\n  },\n  async ({ uniqueName, friendlyName, customizationPrefix, customizationOptionValuePrefix, description }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const publisher = {\n        uniquename: uniqueName,\n        friendlyname: friendlyName,\n        customizationprefix: customizationPrefix,\n        customizationoptionvalueprefix: customizationOptionValuePrefix,\n        description: description || \"\"\n      };\n\n      const result = await service.createPublisher(publisher);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully created publisher '${friendlyName}'\\n` +\n                  `Unique Name: ${uniqueName}\\n` +\n                  `Prefix: ${customizationPrefix}\\n` +\n                  `Option Value Prefix: ${customizationOptionValuePrefix}\\n` +\n                  `Publisher ID: ${result.publisherid}`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating publisher:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to create publisher: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-publishers",
        "code": "server.tool(\n  \"get-publishers\",\n  \"Get all solution publishers (excluding system publishers)\",\n  {},\n  async () => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPublishers();\n\n      const publishers = result.value || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${publishers.length} publisher(s):\\n\\n` +\n                  publishers.map((p: any) =>\n                    `- ${p.friendlyname} (${p.uniquename})\\n  Prefix: ${p.customizationprefix}\\n  ID: ${p.publisherid}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting publishers:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get publishers: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-solution",
        "code": "server.tool(\n  \"create-solution\",\n  \"Create a new solution. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    uniqueName: z.string().describe(\"Solution unique name\"),\n    friendlyName: z.string().describe(\"Solution display name\"),\n    version: z.string().describe(\"Solution version (e.g., '1.0.0.0')\"),\n    publisherId: z.string().describe(\"Publisher ID (GUID)\"),\n    description: z.string().optional().describe(\"Solution description\")\n  },\n  async ({ uniqueName, friendlyName, version, publisherId, description }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const solution = {\n        uniquename: uniqueName,\n        friendlyname: friendlyName,\n        version,\n        \"publisherid@odata.bind\": `/publishers(${publisherId})`,\n        description: description || \"\"\n      };\n\n      const result = await service.createSolution(solution);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully created solution '${friendlyName}'\\n` +\n                  `Unique Name: ${uniqueName}\\n` +\n                  `Version: ${version}\\n` +\n                  `Solution ID: ${result.solutionid}`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating solution:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to create solution: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-solutions",
        "code": "server.tool(\n  \"get-solutions\",\n  \"Get all visible solutions in the environment\",\n  {},\n  async () => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getSolutions();\n\n      const solutions = result.value || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${solutions.length} solution(s):\\n\\n` +\n                  solutions.map((s: any) =>\n                    `- ${s.friendlyname} (${s.uniquename})\\n  Version: ${s.version}\\n  ID: ${s.solutionid}`\n                  ).join('\\n')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting solutions:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get solutions: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "add-solution-component",
        "code": "server.tool(\n  \"add-solution-component\",\n  \"Add a component to a solution. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    solutionUniqueName: z.string().describe(\"Solution unique name\"),\n    componentId: z.string().describe(\"Component ID (GUID or MetadataId)\"),\n    componentType: z.number().describe(\"Component type: 1=Entity, 2=Attribute, 9=OptionSet, 24=Form, 26=SavedQuery, 29=Workflow, 60=SystemForm, 61=WebResource\"),\n    addRequiredComponents: z.boolean().optional().describe(\"Add required components (default: true)\"),\n    includedComponentSettingsValues: z.string().optional().describe(\"Component settings values\")\n  },\n  async ({ solutionUniqueName, componentId, componentType, addRequiredComponents, includedComponentSettingsValues }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.addComponentToSolution(\n        solutionUniqueName,\n        componentId,\n        componentType,\n        addRequiredComponents ?? true,\n        includedComponentSettingsValues\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully added component '${componentId}' (type: ${componentType}) to solution '${solutionUniqueName}'`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error adding component to solution:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to add component to solution: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "remove-solution-component",
        "code": "server.tool(\n  \"remove-solution-component\",\n  \"Remove a component from a solution. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    solutionUniqueName: z.string().describe(\"Solution unique name\"),\n    componentId: z.string().describe(\"Component ID (GUID or MetadataId)\"),\n    componentType: z.number().describe(\"Component type: 1=Entity, 2=Attribute, 9=OptionSet, 24=Form, 26=SavedQuery, 29=Workflow, 60=SystemForm, 61=WebResource\")\n  },\n  async ({ solutionUniqueName, componentId, componentType }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.removeComponentFromSolution(solutionUniqueName, componentId, componentType);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully removed component '${componentId}' (type: ${componentType}) from solution '${solutionUniqueName}'`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error removing component from solution:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to remove component from solution: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "export-solution",
        "code": "server.tool(\n  \"export-solution\",\n  \"Export a solution as a zip file. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    solutionName: z.string().describe(\"Solution unique name\"),\n    managed: z.boolean().optional().describe(\"Export as managed solution (default: false)\")\n  },\n  async ({ solutionName, managed }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const result = await service.exportSolution(solutionName, managed ?? false);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully exported solution '${solutionName}' as ${managed ? 'managed' : 'unmanaged'}\\n\\n` +\n                  `Export File (Base64): ${result.ExportSolutionFile.substring(0, 100)}...`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error exporting solution:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to export solution: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "import-solution",
        "code": "server.tool(\n  \"import-solution\",\n  \"Import a solution from a base64-encoded zip file. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    customizationFile: z.string().describe(\"Base64-encoded solution zip file\"),\n    publishWorkflows: z.boolean().optional().describe(\"Publish workflows after import (default: true)\"),\n    overwriteUnmanagedCustomizations: z.boolean().optional().describe(\"Overwrite unmanaged customizations (default: false)\")\n  },\n  async ({ customizationFile, publishWorkflows, overwriteUnmanagedCustomizations }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      const result = await service.importSolution(\n        customizationFile,\n        publishWorkflows ?? true,\n        overwriteUnmanagedCustomizations ?? false\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully initiated solution import\\n` +\n                  `Import Job ID: ${result.ImportJobId}\\n\\n` +\n                  `âš ï¸ NOTE: Solution import is asynchronous. Monitor the import job for completion status.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error importing solution:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to import solution: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "publish-entity",
        "code": "server.tool(\n  \"publish-entity\",\n  \"Publish all customizations for a specific entity. Requires POWERPLATFORM_ENABLE_CUSTOMIZATION=true.\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name to publish\")\n  },\n  async ({ entityLogicalName }) => {\n    try {\n      checkCustomizationEnabled();\n      const service = getPowerPlatformService();\n\n      await service.publishEntity(entityLogicalName);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `âœ… Successfully published entity '${entityLogicalName}'\\n\\n` +\n                  `All customizations for this entity are now active in the environment.`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error publishing entity:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to publish entity: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "check-dependencies",
        "code": "server.tool(\n  \"check-dependencies\",\n  \"Check dependencies before deleting a component\",\n  {\n    componentId: z.string().describe(\"Component ID (GUID or MetadataId)\"),\n    componentType: z.number().describe(\"Component type: 1=Entity, 2=Attribute, 9=OptionSet, 24=Form, 26=SavedQuery, 29=Workflow, 60=SystemForm, 61=WebResource\")\n  },\n  async ({ componentId, componentType }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.checkDependencies(componentId, componentType);\n\n      const dependencies = result.EntityCollection?.Entities || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${dependencies.length} dependenc${dependencies.length === 1 ? 'y' : 'ies'} for component '${componentId}':\\n\\n` +\n                  (dependencies.length > 0\n                    ? dependencies.map((d: any) =>\n                        `- ${d.Attributes?.dependentcomponentobjectid || 'Unknown'}\\n  Type: ${d.Attributes?.dependentcomponenttype || 'Unknown'}`\n                      ).join('\\n')\n                    : 'No dependencies found - component can be safely deleted')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error checking dependencies:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to check dependencies: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "check-entity-dependencies",
        "code": "server.tool(\n  \"check-entity-dependencies\",\n  \"Check dependencies for a specific entity before deletion\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\")\n  },\n  async ({ entityLogicalName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.checkEntityDependencies(entityLogicalName);\n\n      const dependencies = result.EntityCollection?.Entities || [];\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Found ${dependencies.length} dependenc${dependencies.length === 1 ? 'y' : 'ies'} for entity '${entityLogicalName}':\\n\\n` +\n                  (dependencies.length > 0\n                    ? dependencies.map((d: any) =>\n                        `- ${d.Attributes?.dependentcomponentobjectid || 'Unknown'}\\n  Type: ${d.Attributes?.dependentcomponenttype || 'Unknown'}`\n                      ).join('\\n')\n                    : 'No dependencies found - entity can be safely deleted')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error checking entity dependencies:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to check entity dependencies: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-entity-customization-info",
        "code": "server.tool(\n  \"get-entity-customization-info\",\n  \"Get entity customization information (customizable, managed, custom)\",\n  {\n    entityLogicalName: z.string().describe(\"Entity logical name\")\n  },\n  async ({ entityLogicalName }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getEntityCustomizationInfo(entityLogicalName);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Entity Customization Info for '${entityLogicalName}':\\n\\n` +\n                  `Is Customizable: ${result.IsCustomizable?.Value ?? result.IsCustomizable}\\n` +\n                  `Is Managed: ${result.IsManaged}\\n` +\n                  `Is Custom Entity: ${result.IsCustomEntity}`\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting entity customization info:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to get entity customization info: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "validate-schema-name",
        "code": "server.tool(\n  \"validate-schema-name\",\n  \"Validate a schema name against PowerPlatform naming rules\",\n  {\n    schemaName: z.string().describe(\"Schema name to validate\"),\n    prefix: z.string().describe(\"Required customization prefix\")\n  },\n  async ({ schemaName, prefix }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = service.validateSchemaName(schemaName, prefix);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Schema Name Validation for '${schemaName}':\\n\\n` +\n                  `Valid: ${result.valid ? 'âœ…' : 'âŒ'}\\n\\n` +\n                  (result.errors.length > 0\n                    ? `Errors:\\n${result.errors.map(e => `- ${e}`).join('\\n')}`\n                    : 'No validation errors')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error validating schema name:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to validate schema name: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "check-delete-eligibility",
        "code": "server.tool(\n  \"check-delete-eligibility\",\n  \"Check if a component can be safely deleted\",\n  {\n    componentId: z.string().describe(\"Component ID (GUID or MetadataId)\"),\n    componentType: z.number().describe(\"Component type: 1=Entity, 2=Attribute, 9=OptionSet, 24=Form, 26=SavedQuery, 29=Workflow, 60=SystemForm, 61=WebResource\")\n  },\n  async ({ componentId, componentType }) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.checkDeleteEligibility(componentId, componentType);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Delete Eligibility for component '${componentId}':\\n\\n` +\n                  `Can Delete: ${result.canDelete ? 'âœ… Yes' : 'âŒ No'}\\n` +\n                  `Dependencies: ${result.dependencies.length}\\n\\n` +\n                  (result.dependencies.length > 0\n                    ? `Blocking Dependencies:\\n${result.dependencies.map((d: any) =>\n                        `- ${d.Attributes?.dependentcomponentobjectid || 'Unknown'}`\n                      ).join('\\n')}`\n                    : 'No blocking dependencies - component can be safely deleted')\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(\"Error checking delete eligibility:\", error);\n      return {\n        content: [{ type: \"text\", text: `Failed to check delete eligibility: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "azure-devops": [
      {
        "name": "get-wikis",
        "code": "server.tool(\n  \"get-wikis\",\n  \"Get all wikis in an Azure DevOps project\",\n  {\n    project: z.string().describe(\"The project name\"),\n  },\n  async ({ project }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWikis(project);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wikis in project '${project}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting wikis:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get wikis: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "search-wiki-pages",
        "code": "server.tool(\n  \"search-wiki-pages\",\n  \"Search wiki pages across Azure DevOps projects\",\n  {\n    searchText: z.string().describe(\"The text to search for\"),\n    project: z.string().optional().describe(\"Optional project filter\"),\n    maxResults: z.number().optional().describe(\"Maximum number of results (default: 25)\"),\n  },\n  async ({ searchText, project, maxResults }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.searchWikiPages(searchText, project, maxResults);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wiki search results for '${searchText}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching wiki pages:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to search wiki pages: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-wiki-page",
        "code": "server.tool(\n  \"get-wiki-page\",\n  \"Get a specific wiki page with content from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier (ID or name)\"),\n    pagePath: z.string().describe(\"The path to the page (e.g., '/Setup/Authentication')\"),\n    includeContent: z.boolean().optional().describe(\"Include page content (default: true)\"),\n  },\n  async ({ project, wikiId, pagePath, includeContent }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWikiPage(project, wikiId, pagePath, includeContent ?? true);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get wiki page: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-wiki-page",
        "code": "server.tool(\n  \"create-wiki-page\",\n  \"Create a new wiki page in Azure DevOps (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path for the new page (e.g., '/Setup/NewGuide')\"),\n    content: z.string().describe(\"The markdown content for the page\"),\n  },\n  async ({ project, wikiId, pagePath, content }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.createWikiPage(project, wikiId, pagePath, content);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Created wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create wiki page: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-wiki-page",
        "code": "server.tool(\n  \"update-wiki-page\",\n  \"Update an existing wiki page in Azure DevOps (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path to the page\"),\n    content: z.string().describe(\"The updated markdown content\"),\n    version: z.string().optional().describe(\"The ETag/version for optimistic concurrency\"),\n  },\n  async ({ project, wikiId, pagePath, content, version }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.updateWikiPage(project, wikiId, pagePath, content, version);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Updated wiki page '${pagePath}':\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to update wiki page: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "azuredevops-str-replace-wiki-page",
        "code": "server.tool(\n  \"azuredevops-str-replace-wiki-page\",\n  \"Replace a specific string in an Azure DevOps wiki page without rewriting entire content. More efficient than update-wiki-page for small changes. (requires AZUREDEVOPS_ENABLE_WIKI_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier (ID or name)\"),\n    pagePath: z.string().describe(\"The path to the wiki page (e.g., '/SharePoint-Online/04-DEV-Configuration')\"),\n    old_str: z.string().describe(\"The exact string to replace (must be unique unless replace_all is true)\"),\n    new_str: z.string().describe(\"The replacement string\"),\n    replace_all: z.boolean().optional().describe(\"If true, replace all occurrences. If false (default), old_str must be unique in the page.\"),\n    description: z.string().optional().describe(\"Optional description of the change (for audit logging)\")\n  },\n  async ({ project, wikiId, pagePath, old_str, new_str, replace_all, description }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.strReplaceWikiPage(\n        project,\n        wikiId,\n        pagePath,\n        old_str,\n        new_str,\n        replace_all ?? false,\n        description\n      );\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Successfully replaced \"${old_str}\" with \"${new_str}\" in wiki page '${pagePath}' (${result.occurrences} occurrence(s)):\\n\\n${resultStr}\\n\\nDiff:\\n${result.diff}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error replacing text in wiki page:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to replace text in wiki page: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-work-item",
        "code": "server.tool(\n  \"get-work-item\",\n  \"Get a work item by ID with full details from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWorkItem(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-work-items",
        "code": "server.tool(\n  \"query-work-items\",\n  \"Query work items using WIQL (Work Item Query Language) in Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wiql: z.string().describe(\"The WIQL query string (e.g., \\\"SELECT [System.Id], [System.Title] FROM WorkItems WHERE [System.State] = 'Active'\\\")\"),\n    maxResults: z.number().optional().describe(\"Maximum number of results (default: 200)\"),\n  },\n  async ({ project, wiql, maxResults }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.queryWorkItems(project, wiql, maxResults);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Work items query results:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error querying work items:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to query work items: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "get-work-item-comments",
        "code": "server.tool(\n  \"get-work-item-comments\",\n  \"Get comments/discussion for a work item in Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.getWorkItemComments(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Comments for work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting work item comments:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get work item comments: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "add-work-item-comment",
        "code": "server.tool(\n  \"add-work-item-comment\",\n  \"Add a comment to a work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n    commentText: z.string().describe(\"The comment text (supports markdown)\"),\n  },\n  async ({ project, workItemId, commentText }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.addWorkItemComment(project, workItemId, commentText);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Added comment to work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error adding work item comment:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to add work item comment: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "update-work-item",
        "code": "server.tool(\n  \"update-work-item\",\n  \"Update a work item in Azure DevOps using JSON Patch operations (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n    patchOperations: z.array(z.object({\n      op: z.string().describe(\"The operation type (e.g., 'add', 'replace', 'remove')\"),\n      path: z.string().describe(\"The field path (e.g., '/fields/System.State')\"),\n      value: z.any().optional().describe(\"The value to set (not required for 'remove' operation)\")\n    })).describe(\"Array of JSON Patch operations\"),\n  },\n  async ({ project, workItemId, patchOperations }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.updateWorkItem(project, workItemId, patchOperations);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Updated work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error updating work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to update work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "create-work-item",
        "code": "server.tool(\n  \"create-work-item\",\n  \"Create a new work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_WRITE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemType: z.string().describe(\"The work item type (e.g., 'Bug', 'Task', 'User Story')\"),\n    fields: z.record(z.any()).describe(\"Object with field values (e.g., {\\\"System.Title\\\": \\\"Bug title\\\", \\\"System.Description\\\": \\\"Details\\\"})\"),\n  },\n  async ({ project, workItemType, fields }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.createWorkItem(project, workItemType, fields);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Created work item:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error creating work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to create work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "delete-work-item",
        "code": "server.tool(\n  \"delete-work-item\",\n  \"Delete a work item in Azure DevOps (requires AZUREDEVOPS_ENABLE_WORK_ITEM_DELETE=true)\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.number().describe(\"The work item ID\"),\n  },\n  async ({ project, workItemId }) => {\n    try {\n      const service = getAzureDevOpsService();\n      const result = await service.deleteWorkItem(project, workItemId);\n\n      const resultStr = JSON.stringify(result, null, 2);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Deleted work item ${workItemId}:\\n\\n${resultStr}`,\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error deleting work item:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to delete work item: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "figma": [
      {
        "name": "get-figma-data",
        "code": "server.tool(\n  \"get-figma-data\",\n  \"Get comprehensive Figma design data including layout, text, styles, and components. \" +\n  \"Fetches from Figma API and transforms into simplified, AI-friendly format. \" +\n  \"Can fetch entire files or specific nodes. Automatically deduplicates styles.\",\n  {\n    fileKey: z.string().describe(\n      \"Figma file key (alphanumeric string from URL). \" +\n      \"Example: From 'https://figma.com/file/ABC123/MyFile', use 'ABC123'\"\n    ),\n    nodeId: z.string().optional().describe(\n      \"Optional specific node ID(s) to fetch. Format: '1234:5678' or multiple '1:10;2:20'. \" +\n      \"If omitted, fetches entire file.\"\n    ),\n    depth: z.number().optional().describe(\n      \"Optional tree traversal depth limit. Useful for large files. \" +\n      \"Example: depth=3 stops after 3 levels of children.\"\n    ),\n  },\n  async ({ fileKey, nodeId, depth }) => {\n    try {\n      const service = getFigmaService();\n      const result = await service.getFigmaData(fileKey, nodeId, depth);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2)\n        }],\n        isError: false,\n      };\n    } catch (error: any) {\n      console.error(\"Error fetching Figma data:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to fetch Figma data: ${error.message}\\n\\n` +\n                `Troubleshooting:\\n` +\n                `1. Verify FIGMA_API_KEY or FIGMA_OAUTH_TOKEN is set\\n` +\n                `2. Check file key is correct (from Figma URL)\\n` +\n                `3. Ensure you have access to the file in Figma\\n` +\n                `4. For OAuth, check token hasn't expired`\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "download-figma-images",
        "code": "server.tool(\n  \"download-figma-images\",\n  \"Download and process images from Figma designs (Coming in v2)\",\n  {\n    fileKey: z.string().describe(\"Figma file key\"),\n    localPath: z.string().describe(\"Local path to save images\"),\n  },\n  async ({ fileKey, localPath }) => {\n    return {\n      content: [{\n        type: \"text\",\n        text: \"Image download functionality is planned for v2. \" +\n              \"This will include:\\n\" +\n              \"- Download PNG/SVG exports\\n\" +\n              \"- Crop images with Figma transforms\\n\" +\n              \"- Generate CSS dimension variables\\n\" +\n              \"- Support for image fills and rendered nodes\\n\\n\" +\n              \"For now, use get-figma-data to retrieve design metadata.\"\n      }],\n      isError: false,\n    };\n  }\n);"
      }
    ],
    "application-insights": [
      {
        "name": "appinsights-list-resources",
        "code": "server.tool(\n  \"appinsights-list-resources\",\n  \"List all configured Application Insights resources (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getApplicationInsightsService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(resources, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Application Insights resources:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to list Application Insights resources: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-metadata",
        "code": "server.tool(\n  \"appinsights-get-metadata\",\n  \"Get schema metadata (tables and columns) for an Application Insights resource\",\n  {\n    resourceId: z.string().describe(\"Resource ID (use appinsights-list-resources to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const metadata = await service.getMetadata(resourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(metadata, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Application Insights metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get metadata: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-execute-query",
        "code": "server.tool(\n  \"appinsights-execute-query\",\n  \"Execute a KQL (Kusto Query Language) query against Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    query: z.string().describe(\"KQL query string\"),\n    timespan: z.string().optional().describe(\"Time range (e.g., 'PT1H' for 1 hour, 'P1D' for 1 day, 'PT12H' for 12 hours)\"),\n  },\n  async ({ resourceId, query, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.executeQuery(resourceId, query, timespan);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error executing Application Insights query:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to execute query: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-exceptions",
        "code": "server.tool(\n  \"appinsights-get-exceptions\",\n  \"Get recent exceptions from Application Insights with timestamps, types, and messages\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getRecentExceptions(\n        resourceId,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Application Insights exceptions:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get exceptions: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-slow-requests",
        "code": "server.tool(\n  \"appinsights-get-slow-requests\",\n  \"Get slow HTTP requests (above duration threshold) from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    durationThresholdMs: z.number().optional().describe(\"Duration threshold in milliseconds (default: 5000)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, durationThresholdMs, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getSlowRequests(\n        resourceId,\n        durationThresholdMs || 5000,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting slow requests:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get slow requests: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-operation-performance",
        "code": "server.tool(\n  \"appinsights-get-operation-performance\",\n  \"Get performance summary by operation (request count, avg duration, percentiles)\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getOperationPerformance(\n        resourceId,\n        timespan || 'PT1H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting operation performance:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get operation performance: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-failed-dependencies",
        "code": "server.tool(\n  \"appinsights-get-failed-dependencies\",\n  \"Get failed dependency calls (external APIs, databases, etc.) from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 50)\"),\n  },\n  async ({ resourceId, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getFailedDependencies(\n        resourceId,\n        timespan || 'PT1H',\n        limit || 50\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting failed dependencies:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get failed dependencies: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-traces",
        "code": "server.tool(\n  \"appinsights-get-traces\",\n  \"Get diagnostic traces/logs from Application Insights filtered by severity level\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    severityLevel: z.number().optional().describe(\"Minimum severity level (0=Verbose, 1=Info, 2=Warning, 3=Error, 4=Critical) (default: 2)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, severityLevel, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getTracesBySeverity(\n        resourceId,\n        severityLevel ?? 2,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting traces:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get traces: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-availability",
        "code": "server.tool(\n  \"appinsights-get-availability\",\n  \"Get availability test results and uptime statistics from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT24H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getAvailabilityResults(\n        resourceId,\n        timespan || 'PT24H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting availability results:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get availability results: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-get-custom-events",
        "code": "server.tool(\n  \"appinsights-get-custom-events\",\n  \"Get custom application events from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    eventName: z.string().optional().describe(\"Filter by specific event name\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, eventName, timespan, limit }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const result = await service.getCustomEvents(\n        resourceId,\n        eventName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting custom events:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get custom events: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "log-analytics": [
      {
        "name": "loganalytics-list-workspaces",
        "code": "server.tool(\n  \"loganalytics-list-workspaces\",\n  \"List all configured Log Analytics workspaces (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getLogAnalyticsService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(resources, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Log Analytics workspaces:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to list workspaces: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-metadata",
        "code": "server.tool(\n  \"loganalytics-get-metadata\",\n  \"Get schema metadata (tables and columns) for a Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID (use loganalytics-list-workspaces to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const metadata = await service.getMetadata(resourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(metadata, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting Log Analytics metadata:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get metadata: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-execute-query",
        "code": "server.tool(\n  \"loganalytics-execute-query\",\n  \"Execute a custom KQL query against Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    query: z.string().describe(\"KQL query string\"),\n    timespan: z.string().optional().describe(\"Time range (e.g., 'PT1H', 'P1D')\"),\n  },\n  async ({ resourceId, query, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.executeQuery(resourceId, query, timespan);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error executing Log Analytics query:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to execute query: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-test-workspace-access",
        "code": "server.tool(\n  \"loganalytics-test-workspace-access\",\n  \"Test access to a Log Analytics workspace by executing a simple query\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.testWorkspaceAccess(resourceId);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error testing workspace access:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to test workspace access: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-recent-events",
        "code": "server.tool(\n  \"loganalytics-get-recent-events\",\n  \"Get recent events from a specific Log Analytics table\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    tableName: z.string().describe(\"Table name (e.g., 'FunctionAppLogs', 'traces', 'requests')\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getRecentEvents(\n        resourceId,\n        tableName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting recent events:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get recent events: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-search-logs",
        "code": "server.tool(\n  \"loganalytics-search-logs\",\n  \"Search logs by text content across tables or a specific table\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    searchText: z.string().describe(\"Text to search for\"),\n    tableName: z.string().optional().describe(\"Table name to search in (optional, searches all if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, searchText, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.searchLogs(\n        resourceId,\n        searchText,\n        tableName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to search logs: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-logs",
        "code": "server.tool(\n  \"loganalytics-get-function-logs\",\n  \"Get Azure Function logs from FunctionAppLogs table with optional filtering\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    severityLevel: z.number().optional().describe(\"Minimum severity level (0=Verbose, 1=Info, 2=Warning, 3=Error, 4=Critical)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, severityLevel, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionLogs(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        severityLevel,\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function logs:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function logs: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-errors",
        "code": "server.tool(\n  \"loganalytics-get-function-errors\",\n  \"Get Azure Function error logs with exception details\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionErrors(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function errors:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function errors: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-stats",
        "code": "server.tool(\n  \"loganalytics-get-function-stats\",\n  \"Get execution statistics for Azure Functions (count, success rate, errors)\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name (optional, returns stats for all functions if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionStats(\n        resourceId,\n        functionName,\n        timespan || 'PT1H'\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function stats:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function stats: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-get-function-invocations",
        "code": "server.tool(\n  \"loganalytics-get-function-invocations\",\n  \"Get Azure Function invocation history from requests/traces tables\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name to filter by (optional)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.number().optional().describe(\"Maximum number of results (default: 100)\"),\n  },\n  async ({ resourceId, functionName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const result = await service.getFunctionInvocations(\n        resourceId,\n        functionName,\n        timespan || 'PT1H',\n        limit || 100\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting function invocations:\", error);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to get function invocations: ${error.message}`,\n          },\n        ],\n        isError: true\n      };\n    }\n  }\n);"
      }
    ],
    "azure-sql": [
      {
        "name": "sql-list-servers",
        "code": "server.tool(\n  \"sql-list-servers\",\n  \"List all configured SQL servers with active/inactive status\",\n  {},\n  async () => {\n    try {\n      const sqlService = getAzureSqlService();\n      const servers = await sqlService.listServers();\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(servers, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing servers: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-databases",
        "code": "server.tool(\n  \"sql-list-databases\",\n  \"List databases on a SQL server (configured or discovered)\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n  },\n  async ({ serverId }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const databases = await sqlService.listDatabases(serverId);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(databases, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing databases: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-test-connection",
        "code": "server.tool(\n  \"sql-test-connection\",\n  \"Test SQL Server connectivity and return connection information\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const result = await sqlService.testConnection(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error testing connection: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-tables",
        "code": "server.tool(\n  \"sql-list-tables\",\n  \"List all user tables in the database with row counts and sizes\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const tables = await sqlService.listTables(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(tables, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing tables: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-views",
        "code": "server.tool(\n  \"sql-list-views\",\n  \"List all views in the database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const views = await sqlService.listViews(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(views, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing views: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-stored-procedures",
        "code": "server.tool(\n  \"sql-list-stored-procedures\",\n  \"List all stored procedures in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const procedures = await sqlService.listStoredProcedures(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(procedures, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing stored procedures: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-triggers",
        "code": "server.tool(\n  \"sql-list-triggers\",\n  \"List all database triggers in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const triggers = await sqlService.listTriggers(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(triggers, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing triggers: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-list-functions",
        "code": "server.tool(\n  \"sql-list-functions\",\n  \"List all user-defined functions in the Azure SQL Database\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const functions = await sqlService.listFunctions(serverId, database);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(functions, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error listing functions: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-get-table-schema",
        "code": "server.tool(\n  \"sql-get-table-schema\",\n  \"Get detailed schema information for a table including columns, indexes, and foreign keys\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    tableName: z.string().describe(\"Table name (e.g., 'Users')\"),\n  },\n  async ({ serverId, database, schemaName, tableName }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const schema = await sqlService.getTableSchema(serverId, database, schemaName, tableName);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(schema, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error getting table schema: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-get-object-definition",
        "code": "server.tool(\n  \"sql-get-object-definition\",\n  \"Get the SQL definition for a view, stored procedure, function, or trigger\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    objectName: z.string().describe(\"Object name\"),\n    objectType: z.enum(['VIEW', 'PROCEDURE', 'FUNCTION', 'TRIGGER']).describe(\"Object type\"),\n  },\n  async ({ serverId, database, schemaName, objectName, objectType }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const definition = await sqlService.getObjectDefinition(serverId, database, schemaName, objectName, objectType);\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(definition, null, 2),\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error getting object definition: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "sql-execute-query",
        "code": "server.tool(\n  \"sql-execute-query\",\n  \"Execute a SELECT query against the Azure SQL Database (read-only, with result limits)\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    query: z.string().describe(\"SELECT query to execute (e.g., 'SELECT TOP 10 * FROM dbo.Users WHERE IsActive = 1')\"),\n  },\n  async ({ serverId, database, query }) => {\n    try {\n      const sqlService = getAzureSqlService();\n      const result = await sqlService.executeSelectQuery(serverId, database, query);\n\n      let text = JSON.stringify(result, null, 2);\n\n      if (result.truncated) {\n        text += `\\n\\nâš ï¸ WARNING: Results truncated to ${result.rowCount} rows. Add WHERE clause to filter results.`;\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text,\n          },\n        ],\n      };\n    } catch (error: any) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Error executing query: ${error.message}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n);"
      }
    ],
    "github-enterprise": [
      {
        "name": "ghe-list-repos",
        "code": "server.tool(\n  \"ghe-list-repos\",\n  \"List all configured GitHub Enterprise repositories (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const repos = service.getAllRepos();\n\n      const reposWithUrls = repos.map(r => ({\n        ...r,\n        url: `${GHE_CONFIG.baseUrl}/${r.owner}/${r.repo}`\n      }));\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Configured GitHub Enterprise Repositories\\n\\n` +\n            `**Total:** ${repos.length} repositories\\n` +\n            `**Active:** ${repos.filter(r => r.active).length}\\n\\n` +\n            JSON.stringify(reposWithUrls, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing GitHub Enterprise repositories:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list repositories: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Verify GHE_URL is set correctly\\n` +\n            `2. Verify GHE_PAT or GitHub App credentials are set\\n` +\n            `3. Verify GHE_REPOS is configured as JSON array\\n` +\n            `4. Check repository access permissions`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-branches",
        "code": "server.tool(\n  \"ghe-list-branches\",\n  \"List all branches for a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration (e.g., 'plugin-core')\"),\n    protectedOnly: z.boolean().optional().describe(\"Filter by protection status (true for protected branches only)\"),\n  },\n  async ({ repoId, protectedOnly }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const branches = await service.listBranches(repoId, protectedOnly);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branches for Repository: ${repoId}\\n\\n` +\n            `**Total:** ${branches.length} branches\\n\\n` +\n            formatBranchListAsMarkdown(branches)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing branches:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list branches: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-default-branch",
        "code": "server.tool(\n  \"ghe-get-default-branch\",\n  \"Auto-detect the default branch for a repository (handles typos, provides alternatives)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    userSpecified: z.string().optional().describe(\"User-specified branch name (overrides auto-detection)\"),\n  },\n  async ({ repoId, userSpecified }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.getDefaultBranch(repoId, userSpecified);\n\n      let output = `# Default Branch for Repository: ${repoId}\\n\\n`;\n      output += `**Selected Branch:** \\`${result.branch}\\`  \\n`;\n      output += `**Reason:** ${result.reason}  \\n`;\n      output += `**Confidence:** ${result.confidence}  \\n\\n`;\n\n      if (result.alternatives && result.alternatives.length > 0) {\n        output += `**Alternative Branches:**\\n`;\n        result.alternatives.slice(0, 5).forEach(alt => {\n          output += `- \\`${alt}\\`\\n`;\n        });\n        if (result.alternatives.length > 5) {\n          output += `- ... and ${result.alternatives.length - 5} more\\n`;\n        }\n      }\n\n      if (result.message) {\n        output += `\\n**Note:** ${result.message}\\n`;\n      }\n\n      return {\n        content: [{\n          type: \"text\",\n          text: output\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting default branch:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get default branch: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-file",
        "code": "server.tool(\n  \"ghe-get-file\",\n  \"Get file content from a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path (e.g., 'src/Plugins/ContactPlugin.cs')\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n  },\n  async ({ repoId, path, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const file = await service.getFile(repoId, path, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# File: ${path}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${file.branch}\\`  \\n` +\n            `**Size:** ${file.size} bytes  \\n` +\n            `**SHA:** \\`${file.sha}\\`  \\n\\n` +\n            `## Content\\n\\n\\`\\`\\`\\n${file.decodedContent}\\n\\`\\`\\``\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get file: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Verify file path is correct\\n` +\n            `2. Verify branch exists (or let auto-detection find it)\\n` +\n            `3. Check if file size exceeds GHE_MAX_FILE_SIZE (default: 1MB)`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-code",
        "code": "server.tool(\n  \"ghe-search-code\",\n  \"Search code across GitHub Enterprise repositories\",\n  {\n    query: z.string().describe(\"Search query (e.g., 'class ContactPlugin')\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository\"),\n    path: z.string().optional().describe(\"Filter by file path pattern\"),\n    extension: z.string().optional().describe(\"Filter by file extension (e.g., 'cs', 'js')\"),\n  },\n  async ({ query, repoId, path, extension }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchCode(query, repoId, path, extension);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatCodeSearchResultsAsMarkdown(results)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching code:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search code: ${error.message}\\n\\n` +\n            `Troubleshooting:\\n` +\n            `1. Simplify search query if too complex\\n` +\n            `2. Check rate limits if search fails\\n` +\n            `3. Verify repository access permissions`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-files",
        "code": "server.tool(\n  \"ghe-list-files\",\n  \"List files in a directory of a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().optional().describe(\"Directory path (default: root)\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n  },\n  async ({ repoId, path, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.listFiles(repoId, path, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Directory: ${path || '/'}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${result.branch}\\`  \\n\\n` +\n            formatDirectoryContentsAsMarkdown(result.contents)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing files:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list files: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-clear-cache",
        "code": "server.tool(\n  \"ghe-clear-cache\",\n  \"Clear cached GitHub Enterprise API responses (useful after pushing code updates)\",\n  {\n    pattern: z.string().optional().describe(\"Clear only cache entries matching this pattern (e.g., 'ContactPlugin.cs')\"),\n    repoId: z.string().optional().describe(\"Clear cache for specific repository only\"),\n  },\n  async ({ pattern, repoId }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const cleared = service.clearCache(pattern, repoId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… Cleared ${cleared} cache entries` +\n            (pattern ? ` matching pattern '${pattern}'` : '') +\n            (repoId ? ` for repository '${repoId}'` : '')\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error clearing cache:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to clear cache: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commits",
        "code": "server.tool(\n  \"ghe-get-commits\",\n  \"Get commit history for a branch in a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    since: z.string().optional().describe(\"ISO 8601 date (e.g., '2025-01-01T00:00:00Z')\"),\n    until: z.string().optional().describe(\"ISO 8601 date\"),\n    author: z.string().optional().describe(\"Filter by author\"),\n    path: z.string().optional().describe(\"Filter by file path\"),\n    limit: z.number().optional().describe(\"Max commits (default: 50)\"),\n  },\n  async ({ repoId, branch, since, until, author, path, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commits = await service.getCommits(repoId, branch, since, until, author, path, limit || 50);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit History\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Count:** ${commits.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(commits)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commits:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commits: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commit-details",
        "code": "server.tool(\n  \"ghe-get-commit-details\",\n  \"Get detailed information about a specific commit in a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    sha: z.string().describe(\"Commit SHA\"),\n  },\n  async ({ repoId, sha }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commit = await service.getCommitDetails(repoId, sha);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatCommitDetailsAsMarkdown(commit)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commit details:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commit details: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-commits",
        "code": "server.tool(\n  \"ghe-search-commits\",\n  \"Search commits by message or hash (supports work item references like '#1234')\",\n  {\n    query: z.string().describe(\"Search query (e.g., '#1234', 'fix bug')\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository\"),\n    author: z.string().optional().describe(\"Filter by author\"),\n    since: z.string().optional().describe(\"ISO 8601 date\"),\n    until: z.string().optional().describe(\"ISO 8601 date\"),\n  },\n  async ({ query, repoId, author, since, until }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchCommits(query, repoId, author, since, until);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit Search Results\\n\\n` +\n            `**Query:** ${query}  \\n` +\n            `**Total Results:** ${results.total_count}  \\n` +\n            `**Showing:** ${results.items.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(results.items)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching commits:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search commits: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-commit-diff",
        "code": "server.tool(\n  \"ghe-get-commit-diff\",\n  \"Get detailed diff for a commit in unified format\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    sha: z.string().describe(\"Commit SHA\"),\n    format: z.enum(['diff', 'patch']).optional().describe(\"Format: 'diff' or 'patch' (default: 'diff')\"),\n  },\n  async ({ repoId, sha, format }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const diff = await service.getCommitDiff(repoId, sha, format || 'diff');\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Commit Diff: ${sha}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Format:** ${format || 'diff'}  \\n\\n` +\n            `\\`\\`\\`diff\\n${diff}\\n\\`\\`\\``\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting commit diff:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get commit diff: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-compare-branches",
        "code": "server.tool(\n  \"ghe-compare-branches\",\n  \"Compare two branches and show differences\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    base: z.string().describe(\"Base branch name\"),\n    head: z.string().describe(\"Head branch name\"),\n  },\n  async ({ repoId, base, head }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const comparison = await service.compareBranches(repoId, base, head);\n\n      const insights = analyzeBranchComparison(comparison);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branch Comparison: ${base} â† ${head}\\n\\n` +\n            `**Repository:** ${repoId}  \\n\\n` +\n            `## Summary\\n\\n` +\n            insights.join('\\n') + '\\n\\n' +\n            `## Commits (${comparison.commits.length})\\n\\n` +\n            formatCommitHistoryAsMarkdown(comparison.commits.slice(0, 10))\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error comparing branches:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to compare branches: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-branch-details",
        "code": "server.tool(\n  \"ghe-get-branch-details\",\n  \"Get detailed information about a specific branch\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branch: z.string().describe(\"Branch name\"),\n  },\n  async ({ repoId, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const branchInfo = await service.getBranchDetails(repoId, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Branch Details: ${branch}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Protected:** ${branchInfo.protected ? 'ðŸ”’ Yes' : 'No'}  \\n` +\n            `**Last Commit:** \\`${branchInfo.commit.sha.substring(0, 7)}\\`  \\n` +\n            `**Commit Message:** ${branchInfo.commit.commit.message.split('\\n')[0]}  \\n` +\n            `**Author:** ${branchInfo.commit.commit.author.name}  \\n` +\n            `**Date:** ${new Date(branchInfo.commit.commit.author.date).toLocaleString()}  \\n\\n` +\n            JSON.stringify(branchInfo, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting branch details:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get branch details: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-list-pull-requests",
        "code": "server.tool(\n  \"ghe-list-pull-requests\",\n  \"List pull requests for a GitHub Enterprise repository\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    state: z.enum(['open', 'closed', 'all']).optional().describe(\"PR state (default: 'open')\"),\n    base: z.string().optional().describe(\"Filter by base branch\"),\n    head: z.string().optional().describe(\"Filter by head branch\"),\n    sort: z.enum(['created', 'updated', 'popularity']).optional().describe(\"Sort order (default: 'created')\"),\n    limit: z.number().optional().describe(\"Max results (default: 30)\"),\n  },\n  async ({ repoId, state, base, head, sort, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const prs = await service.listPullRequests(repoId, state || 'open', base, head, sort || 'created', limit || 30);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Pull Requests\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**State:** ${state || 'open'}  \\n` +\n            `**Count:** ${prs.length}\\n\\n` +\n            formatPullRequestsAsMarkdown(prs)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error listing pull requests:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list pull requests: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-pull-request",
        "code": "server.tool(\n  \"ghe-get-pull-request\",\n  \"Get detailed information about a specific pull request\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    prNumber: z.number().describe(\"Pull request number\"),\n  },\n  async ({ repoId, prNumber }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const pr = await service.getPullRequest(repoId, prNumber);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: formatPullRequestDetailsAsMarkdown(pr)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting pull request:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get pull request: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-pr-files",
        "code": "server.tool(\n  \"ghe-get-pr-files\",\n  \"Get files changed in a pull request\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    prNumber: z.number().describe(\"Pull request number\"),\n  },\n  async ({ repoId, prNumber }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const files = await service.getPullRequestFiles(repoId, prNumber);\n\n      const header = '| File | Status | +/- | Changes |';\n      const separator = '|------|--------|-----|---------|';\n\n      const rows = files.map(f => {\n        const status = f.status === 'added' ? 'ðŸ†• Added' :\n                       f.status === 'modified' ? 'ðŸ“ Modified' :\n                       f.status === 'removed' ? 'ðŸ—‘ï¸ Removed' :\n                       f.status === 'renamed' ? 'ðŸ“‹ Renamed' : f.status;\n\n        return `| \\`${f.filename}\\` | ${status} | +${f.additions}/-${f.deletions} | ${f.changes} |`;\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Pull Request #${prNumber} - Files Changed\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Total Files:** ${files.length}\\n\\n` +\n            [header, separator, ...rows].join('\\n')\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting PR files:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get PR files: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-directory-structure",
        "code": "server.tool(\n  \"ghe-get-directory-structure\",\n  \"Get recursive directory tree structure\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().optional().describe(\"Directory path (default: root)\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    depth: z.number().optional().describe(\"Recursion depth limit (default: 3)\"),\n  },\n  async ({ repoId, path, branch, depth }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.getDirectoryStructure(repoId, path, branch, depth || 3);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Directory Structure: ${path || '/'}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Branch:** \\`${result.branch}\\`  \\n` +\n            `**Max Depth:** ${depth || 3}\\n\\n` +\n            '```\\n' + formatFileTreeAsMarkdown(result.tree) + '\\n```'\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting directory structure:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get directory structure: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-get-file-history",
        "code": "server.tool(\n  \"ghe-get-file-history\",\n  \"Get commit history for a specific file\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    branch: z.string().optional().describe(\"Branch name (default: auto-detected)\"),\n    limit: z.number().optional().describe(\"Max commits (default: 50)\"),\n  },\n  async ({ repoId, path, branch, limit }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const commits = await service.getFileHistory(repoId, path, branch, limit || 50);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# File History: ${path}\\n\\n` +\n            `**Repository:** ${repoId}  \\n` +\n            `**Commits:** ${commits.length}\\n\\n` +\n            formatCommitHistoryAsMarkdown(commits)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error getting file history:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get file history: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-create-branch",
        "code": "server.tool(\n  \"ghe-create-branch\",\n  \"Create a new branch (requires GHE_ENABLE_CREATE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    branchName: z.string().describe(\"New branch name\"),\n    fromBranch: z.string().optional().describe(\"Source branch (default: auto-detected)\"),\n  },\n  async ({ repoId, branchName, fromBranch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.createBranch(repoId, branchName, fromBranch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… Branch '${branchName}' created successfully\\n\\n` +\n            JSON.stringify(result, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating branch:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to create branch: ${error.message}\\n\\n` +\n            `Note: Branch creation requires GHE_ENABLE_CREATE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-update-file",
        "code": "server.tool(\n  \"ghe-update-file\",\n  \"Update file content (requires GHE_ENABLE_WRITE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    content: z.string().describe(\"New file content\"),\n    message: z.string().describe(\"Commit message\"),\n    branch: z.string().describe(\"Branch name\"),\n    sha: z.string().describe(\"Current file SHA (for conflict detection)\"),\n  },\n  async ({ repoId, path, content, message, branch, sha }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.updateFile(repoId, path, content, message, branch, sha);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… File '${path}' updated successfully\\n\\n` +\n            `**Commit SHA:** \\`${result.commit.sha}\\`  \\n` +\n            `**Branch:** \\`${branch}\\`  \\n` +\n            `**Message:** ${message}`\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error updating file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to update file: ${error.message}\\n\\n` +\n            `Note: File updates require GHE_ENABLE_WRITE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-create-file",
        "code": "server.tool(\n  \"ghe-create-file\",\n  \"Create a new file (requires GHE_ENABLE_CREATE=true)\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    path: z.string().describe(\"File path\"),\n    content: z.string().describe(\"File content\"),\n    message: z.string().describe(\"Commit message\"),\n    branch: z.string().describe(\"Branch name\"),\n  },\n  async ({ repoId, path, content, message, branch }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const result = await service.createFile(repoId, path, content, message, branch);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… File '${path}' created successfully\\n\\n` +\n            `**Commit SHA:** \\`${result.commit.sha}\\`  \\n` +\n            `**Branch:** \\`${branch}\\`  \\n` +\n            `**Message:** ${message}`\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error creating file:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to create file: ${error.message}\\n\\n` +\n            `Note: File creation requires GHE_ENABLE_CREATE=true`\n        }]\n      };\n    }\n  }\n);"
      },
      {
        "name": "ghe-search-repos",
        "code": "server.tool(\n  \"ghe-search-repos\",\n  \"Search repositories by name or description across GitHub Enterprise\",\n  {\n    query: z.string().describe(\"Search query\"),\n    owner: z.string().optional().describe(\"Filter by organization/owner\"),\n  },\n  async ({ query, owner }) => {\n    try {\n      const service = getGitHubEnterpriseService();\n      const results = await service.searchRepositories(query, owner);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `# Repository Search Results\\n\\n` +\n            `**Query:** ${query}  \\n` +\n            `**Total Results:** ${results.total_count}  \\n` +\n            `**Showing:** ${results.items.length}\\n\\n` +\n            JSON.stringify(results.items, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      console.error(\"Error searching repositories:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search repositories: ${error.message}`\n        }]\n      };\n    }\n  }\n);"
      }
    ],
    "service-bus": [
      {
        "name": "servicebus-list-namespaces",
        "code": "server.tool(\n  \"servicebus-list-namespaces\",\n  \"List all configured Service Bus namespaces (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getServiceBusService();\n      const resources = service.getAllResources();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(resources, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Service Bus namespaces:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list namespaces: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-test-connection",
        "code": "server.tool(\n  \"servicebus-test-connection\",\n  \"Test connectivity to a Service Bus namespace and verify permissions (Data Receiver + Reader roles)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID (use servicebus-list-namespaces to find IDs)\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const result = await service.testConnection(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error testing Service Bus connection:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to test connection: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-list-queues",
        "code": "server.tool(\n  \"servicebus-list-queues\",\n  \"List all queues in a Service Bus namespace with message counts and session info (cached for 5 minutes)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const queues = await service.listQueues(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(queues, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing Service Bus queues:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list queues: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-peek-messages",
        "code": "server.tool(\n  \"servicebus-peek-messages\",\n  \"Peek messages in a queue without removing them (read-only, max 100 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to peek (default: 10, max: 100)\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n  },\n  async ({ resourceId, queueName, maxMessages, sessionId }) => {\n    try {\n      const service = getServiceBusService();\n      const messages = await service.peekMessages(resourceId, queueName, maxMessages || 10, sessionId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(messages, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error peeking messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to peek messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-peek-deadletter",
        "code": "server.tool(\n  \"servicebus-peek-deadletter\",\n  \"Peek dead letter queue messages with failure reasons (read-only, max 100 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to peek (default: 10, max: 100)\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n  },\n  async ({ resourceId, queueName, maxMessages, sessionId }) => {\n    try {\n      const service = getServiceBusService();\n      const messages = await service.peekDeadLetterMessages(resourceId, queueName, maxMessages || 10, sessionId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(messages, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error peeking dead letter messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to peek dead letter messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-get-queue-properties",
        "code": "server.tool(\n  \"servicebus-get-queue-properties\",\n  \"Get detailed queue properties, metrics, and configuration including session info\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n  },\n  async ({ resourceId, queueName }) => {\n    try {\n      const service = getServiceBusService();\n      const properties = await service.getQueueProperties(resourceId, queueName);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(properties, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting queue properties:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get queue properties: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-search-messages",
        "code": "server.tool(\n  \"servicebus-search-messages\",\n  \"Search messages by content or properties (loads into memory, max 500 messages)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    bodyContains: z.string().optional().describe(\"Search for text in message body (case-insensitive)\"),\n    correlationId: z.string().optional().describe(\"Filter by correlation ID\"),\n    messageId: z.string().optional().describe(\"Filter by message ID\"),\n    propertyKey: z.string().optional().describe(\"Application property key to filter by\"),\n    propertyValue: z.any().optional().describe(\"Application property value to match\"),\n    sessionId: z.string().optional().describe(\"Session ID for session-enabled queues\"),\n    maxMessages: z.number().optional().describe(\"Maximum messages to search (default: 50, max: 500)\"),\n  },\n  async ({ resourceId, queueName, bodyContains, correlationId, messageId, propertyKey, propertyValue, sessionId, maxMessages }) => {\n    try {\n      const service = getServiceBusService();\n      const result = await service.searchMessages(\n        resourceId,\n        queueName,\n        { bodyContains, correlationId, messageId, propertyKey, propertyValue, sessionId },\n        maxMessages || 50\n      );\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching messages:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search messages: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "servicebus-get-namespace-properties",
        "code": "server.tool(\n  \"servicebus-get-namespace-properties\",\n  \"Get namespace-level properties and quotas (tier, max message size)\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    try {\n      const service = getServiceBusService();\n      const properties = await service.getNamespaceProperties(resourceId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(properties, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting namespace properties:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get namespace properties: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      }
    ],
    "sharepoint": [
      {
        "name": "spo-list-sites",
        "code": "server.tool(\n  \"spo-list-sites\",\n  \"List all configured SharePoint sites (active and inactive)\",\n  {},\n  async () => {\n    try {\n      const service = getSharePointService();\n      const sites = service.getAllSites();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(sites, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing SharePoint sites:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list sites: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-site-info",
        "code": "server.tool(\n  \"spo-get-site-info\",\n  \"Get detailed site information including metadata, created/modified dates, and owner info\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration (use spo-list-sites to find IDs)\"),\n  },\n  async ({ siteId }) => {\n    try {\n      const service = getSharePointService();\n      const siteInfo = await service.getSiteInfo(siteId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(siteInfo, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting SharePoint site info:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get site info: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-test-connection",
        "code": "server.tool(\n  \"spo-test-connection\",\n  \"Test connectivity to a SharePoint site and verify permissions (Sites.Read.All and Files.Read.All required)\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n  },\n  async ({ siteId }) => {\n    try {\n      const service = getSharePointService();\n      const result = await service.testConnection(siteId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error testing SharePoint connection:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to test connection: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-list-drives",
        "code": "server.tool(\n  \"spo-list-drives\",\n  \"List all document libraries (drives) in a SharePoint site with metadata\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n  },\n  async ({ siteId }) => {\n    try {\n      const service = getSharePointService();\n      const drives = await service.listDrives(siteId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(drives, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing SharePoint drives:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list drives: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-drive-info",
        "code": "server.tool(\n  \"spo-get-drive-info\",\n  \"Get detailed document library information including quota, owner, and created/modified dates\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID (use spo-list-drives to find IDs)\"),\n  },\n  async ({ siteId, driveId }) => {\n    try {\n      const service = getSharePointService();\n      const driveInfo = await service.getDriveInfo(siteId, driveId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(driveInfo, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting SharePoint drive info:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get drive info: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-clear-cache",
        "code": "server.tool(\n  \"spo-clear-cache\",\n  \"Clear cached SharePoint responses (useful after site changes or for troubleshooting)\",\n  {\n    siteId: z.string().optional().describe(\"Clear cache for specific site only (optional)\"),\n    pattern: z.string().optional().describe(\"Clear only cache entries matching this pattern (optional)\"),\n  },\n  async ({ siteId, pattern }) => {\n    try {\n      const service = getSharePointService();\n      const clearedCount = service.clearCache(pattern, siteId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({ clearedCount, message: `Cleared ${clearedCount} cache entries` }, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error clearing SharePoint cache:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to clear cache: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-list-items",
        "code": "server.tool(\n  \"spo-list-items\",\n  \"List all files and folders in a document library or folder\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    folderId: z.string().optional().describe(\"Folder ID (optional, defaults to root)\"),\n  },\n  async ({ siteId, driveId, folderId }) => {\n    try {\n      const service = getSharePointService();\n      const items = await service.listItems(siteId, driveId, folderId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(items, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error listing SharePoint items:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to list items: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-item",
        "code": "server.tool(\n  \"spo-get-item\",\n  \"Get detailed file or folder metadata by ID\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    itemId: z.string().describe(\"Item ID\"),\n  },\n  async ({ siteId, driveId, itemId }) => {\n    try {\n      const service = getSharePointService();\n      const item = await service.getItem(siteId, driveId, itemId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(item, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting SharePoint item:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get item: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-item-by-path",
        "code": "server.tool(\n  \"spo-get-item-by-path\",\n  \"Get file or folder metadata by path (relative to drive root)\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    path: z.string().describe(\"Item path (e.g., '/folder/file.docx' or 'folder/subfolder')\"),\n  },\n  async ({ siteId, driveId, path }) => {\n    try {\n      const service = getSharePointService();\n      const item = await service.getItemByPath(siteId, driveId, path);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(item, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting SharePoint item by path:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get item by path: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-search-items",
        "code": "server.tool(\n  \"spo-search-items\",\n  \"Search for files by filename or metadata (filename and metadata search only, not full-text)\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    query: z.string().describe(\"Search query\"),\n    driveId: z.string().optional().describe(\"Limit search to specific drive (optional)\"),\n    limit: z.number().optional().describe(\"Maximum results (default: 100, max configured in SHAREPOINT_MAX_SEARCH_RESULTS)\"),\n  },\n  async ({ siteId, query, driveId, limit }) => {\n    try {\n      const service = getSharePointService();\n      const result = await service.searchItems(siteId, query, driveId, limit);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error searching SharePoint items:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to search items: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-recent-items",
        "code": "server.tool(\n  \"spo-get-recent-items\",\n  \"Get recently modified items in a document library\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    limit: z.number().optional().describe(\"Maximum results (default: 20, max: 100)\"),\n    days: z.number().optional().describe(\"Days back to search (default: 30)\"),\n  },\n  async ({ siteId, driveId, limit, days }) => {\n    try {\n      const service = getSharePointService();\n      const items = await service.getRecentItems(siteId, driveId, limit, days);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(items, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting recent SharePoint items:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get recent items: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-folder-structure",
        "code": "server.tool(\n  \"spo-get-folder-structure\",\n  \"Get recursive folder tree structure (useful for understanding site organization)\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    folderId: z.string().optional().describe(\"Root folder ID (optional, defaults to drive root)\"),\n    depth: z.number().optional().describe(\"Recursion depth (default: 3, max: 10)\"),\n  },\n  async ({ siteId, driveId, folderId, depth }) => {\n    try {\n      const service = getSharePointService();\n      const tree = await service.getFolderStructure(siteId, driveId, folderId, depth);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(tree, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting SharePoint folder structure:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get folder structure: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-get-crm-document-locations",
        "code": "server.tool(\n  \"spo-get-crm-document-locations\",\n  \"Get SharePoint document locations configured in PowerPlatform Dataverse (sharepointdocumentlocation entity)\",\n  {\n    entityName: z.string().optional().describe(\"Filter by entity logical name (e.g., 'account', 'contact')\"),\n    recordId: z.string().optional().describe(\"Filter by specific record ID (GUID)\"),\n  },\n  async ({ entityName, recordId }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      const locations = await spoService.getCrmDocumentLocations(ppService, entityName, recordId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(locations, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error getting CRM document locations:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to get CRM document locations: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-validate-document-location",
        "code": "server.tool(\n  \"spo-validate-document-location\",\n  \"Validate that a PowerPlatform document location configuration matches the actual SharePoint site structure. Checks site accessibility, folder existence, and file counts. Returns validation status (valid/warning/error) with issues and recommendations.\",\n  {\n    documentLocationId: z.string().describe(\"GUID of the sharepointdocumentlocation record in PowerPlatform\"),\n  },\n  async ({ documentLocationId }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      const result = await spoService.validateDocumentLocation(ppService, documentLocationId);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error validating document location:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to validate document location: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      },
      {
        "name": "spo-verify-document-migration",
        "code": "server.tool(\n  \"spo-verify-document-migration\",\n  \"Verify that documents were successfully migrated from source to target SharePoint folder. Compares file counts, sizes, names, and modified dates. Returns migration status (complete/incomplete/failed) with success rate and detailed comparison.\",\n  {\n    sourceSiteId: z.string().describe(\"Source SharePoint site ID\"),\n    sourcePath: z.string().describe(\"Source folder path (e.g., '/Documents/Archive')\"),\n    targetSiteId: z.string().describe(\"Target SharePoint site ID\"),\n    targetPath: z.string().describe(\"Target folder path (e.g., '/NewLibrary/Archive')\"),\n  },\n  async ({ sourceSiteId, sourcePath, targetSiteId, targetPath }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      const result = await spoService.verifyDocumentMigration(\n        ppService,\n        sourceSiteId,\n        sourcePath,\n        targetSiteId,\n        targetPath\n      );\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        }],\n      };\n    } catch (error: any) {\n      console.error(\"Error verifying document migration:\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `Failed to verify document migration: ${error.message}`,\n        }],\n        isError: true,\n      };\n    }\n  }\n);"
      }
    ]
  },
  "prompts": {
    "powerplatform": [
      {
        "name": "entity-overview",
        "code": "server.prompt(\n  \"entity-overview\", \n  \"Get an overview of a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\")\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get entity metadata and key attributes\n      const [metadata, attributes] = await Promise.all([\n        service.getEntityMetadata(entityName),\n        service.getEntityAttributes(entityName)\n      ]);\n      \n      // Format entity details\n      const entityDetails = `- Display Name: ${metadata.DisplayName?.UserLocalizedLabel?.Label || entityName}\\n` +\n        `- Schema Name: ${metadata.SchemaName}\\n` +\n        `- Description: ${metadata.Description?.UserLocalizedLabel?.Label || 'No description'}\\n` +\n        `- Primary Key: ${metadata.PrimaryIdAttribute}\\n` +\n        `- Primary Name: ${metadata.PrimaryNameAttribute}`;\n        \n      // Get key attributes\n      const keyAttributes = attributes.value\n        .map((attr: any) => {\n          const attrType = attr[\"@odata.type\"] || attr.odata?.type || \"Unknown type\";\n          return `- ${attr.LogicalName}: ${attrType}`;\n        })\n        .join('\\n');\n        \n      // Get relationships summary\n      const relationships = await service.getEntityRelationships(entityName);\n      const oneToManyCount = relationships.oneToMany.value.length;\n      const manyToManyCount = relationships.manyToMany.value.length;\n      \n      const relationshipsSummary = `- One-to-Many Relationships: ${oneToManyCount}\\n` +\n                                  `- Many-to-Many Relationships: ${manyToManyCount}`;\n      \n      let promptContent = powerPlatformPrompts.ENTITY_OVERVIEW(entityName);\n      promptContent = promptContent\n        .replace('{{entity_details}}', entityDetails)\n        .replace('{{key_attributes}}', keyAttributes)\n        .replace('{{relationships}}', relationshipsSummary);\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling entity-overview prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "attribute-details",
        "code": "server.prompt(\n  \"attribute-details\",\n  \"Get detailed information about a specific entity attribute/field\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    attributeName: z.string().describe(\"The logical name of the attribute\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const { entityName, attributeName } = args;\n      \n      // Get attribute details\n      const attribute = await service.getEntityAttribute(entityName, attributeName);\n      \n      // Format attribute details\n      const attrDetails = `- Display Name: ${attribute.DisplayName?.UserLocalizedLabel?.Label || attributeName}\\n` +\n        `- Description: ${attribute.Description?.UserLocalizedLabel?.Label || 'No description'}\\n` +\n        `- Type: ${attribute.AttributeType}\\n` +\n        `- Format: ${attribute.Format || 'N/A'}\\n` +\n        `- Is Required: ${attribute.RequiredLevel?.Value || 'No'}\\n` +\n        `- Is Searchable: ${attribute.IsValidForAdvancedFind || false}`;\n        \n      let promptContent = powerPlatformPrompts.ATTRIBUTE_DETAILS(entityName, attributeName);\n      promptContent = promptContent\n        .replace('{{attribute_details}}', attrDetails)\n        .replace('{{data_type}}', attribute.AttributeType)\n        .replace('{{required}}', attribute.RequiredLevel?.Value || 'No')\n        .replace('{{max_length}}', attribute.MaxLength || 'N/A');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling attribute-details prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "query-template",
        "code": "server.prompt(\n  \"query-template\",\n  \"Get a template for querying a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get entity metadata to determine plural name\n      const metadata = await service.getEntityMetadata(entityName);\n      const entityNamePlural = metadata.EntitySetName;\n      \n      // Get a few important fields for the select example\n      const attributes = await service.getEntityAttributes(entityName);\n      const selectFields = attributes.value\n        .filter((attr: any) => attr.IsValidForRead === true && !attr.AttributeOf)\n        .slice(0, 5) // Just take first 5 for example\n        .map((attr: any) => attr.LogicalName)\n        .join(',');\n        \n      let promptContent = powerPlatformPrompts.QUERY_TEMPLATE(entityNamePlural);\n      promptContent = promptContent\n        .replace('{{selected_fields}}', selectFields)\n        .replace('{{filter_conditions}}', `${metadata.PrimaryNameAttribute} eq 'Example'`)\n        .replace('{{order_by}}', `${metadata.PrimaryNameAttribute} asc`)\n        .replace('{{max_records}}', '50');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling query-template prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "relationship-map",
        "code": "server.prompt(\n  \"relationship-map\",\n  \"Get a list of relationships for a Power Platform entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const entityName = args.entityName;\n      \n      // Get relationships\n      const relationships = await service.getEntityRelationships(entityName);\n      \n      // Format one-to-many relationships where this entity is primary\n      const oneToManyPrimary = relationships.oneToMany.value\n        .filter((rel: any) => rel.ReferencingEntity !== entityName)\n        .map((rel: any) => `- ${rel.SchemaName}: ${entityName} (1) â†’ ${rel.ReferencingEntity} (N)`)\n        .join('\\n');\n        \n      // Format one-to-many relationships where this entity is related\n      const oneToManyRelated = relationships.oneToMany.value\n        .filter((rel: any) => rel.ReferencingEntity === entityName)\n        .map((rel: any) => `- ${rel.SchemaName}: ${rel.ReferencedEntity} (1) â†’ ${entityName} (N)`)\n        .join('\\n');\n        \n      // Format many-to-many relationships\n      const manyToMany = relationships.manyToMany.value\n        .map((rel: any) => {\n          const otherEntity = rel.Entity1LogicalName === entityName ? rel.Entity2LogicalName : rel.Entity1LogicalName;\n          return `- ${rel.SchemaName}: ${entityName} (N) â†” ${otherEntity} (N)`;\n        })\n        .join('\\n');\n      \n      let promptContent = powerPlatformPrompts.RELATIONSHIP_MAP(entityName);\n      promptContent = promptContent\n        .replace('{{one_to_many_primary}}', oneToManyPrimary || 'None found')\n        .replace('{{one_to_many_related}}', oneToManyRelated || 'None found')\n        .replace('{{many_to_many}}', manyToMany || 'None found');\n      \n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: promptContent\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error handling relationship-map prompt:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "plugin-deployment-report",
        "code": "server.prompt(\n  \"plugin-deployment-report\",\n  \"Generate a comprehensive deployment report for a plugin assembly\",\n  {\n    assemblyName: z.string().describe(\"The name of the plugin assembly\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getPluginAssemblyComplete(args.assemblyName, false);\n\n      // Build markdown report\n      let report = `# Plugin Deployment Report: ${result.assembly.name}\\n\\n`;\n\n      report += `## Assembly Information\\n`;\n      report += `- **Version**: ${result.assembly.version}\\n`;\n      report += `- **Isolation Mode**: ${result.assembly.isolationmode === 2 ? 'Sandbox' : 'None'}\\n`;\n      report += `- **Source**: ${result.assembly.sourcetype === 0 ? 'Database' : result.assembly.sourcetype === 1 ? 'Disk' : 'GAC'}\\n`;\n      report += `- **Last Modified**: ${result.assembly.modifiedon} by ${result.assembly.modifiedby?.fullname || 'Unknown'}\\n`;\n      report += `- **Managed**: ${result.assembly.ismanaged ? 'Yes' : 'No'}\\n\\n`;\n\n      report += `## Plugin Types (${result.pluginTypes.length} total)\\n`;\n      result.pluginTypes.forEach((type: any, idx: number) => {\n        report += `${idx + 1}. ${type.typename}\\n`;\n      });\n      report += `\\n`;\n\n      report += `## Registered Steps (${result.steps.length} total)\\n\\n`;\n      result.steps.forEach((step: any) => {\n        const stageName = step.stage === 10 ? 'PreValidation' : step.stage === 20 ? 'PreOperation' : 'PostOperation';\n        const modeName = step.mode === 0 ? 'Sync' : 'Async';\n        const status = step.statuscode === 1 ? 'âœ“ Enabled' : 'âœ— Disabled';\n\n        report += `### ${step.sdkmessageid?.name || 'Unknown'} - ${step.sdkmessagefilterid?.primaryobjecttypecode || 'None'} (${stageName}, ${modeName}, Rank ${step.rank})\\n`;\n        report += `- **Plugin**: ${step.plugintypeid?.typename || 'Unknown'}\\n`;\n        report += `- **Status**: ${status}\\n`;\n        report += `- **Filtering Attributes**: ${step.filteringattributes || '(none - runs on all changes)'}\\n`;\n        report += `- **Deployment**: ${step.supporteddeployment === 0 ? 'Server Only' : step.supporteddeployment === 1 ? 'Offline Only' : 'Both'}\\n`;\n\n        if (step.images.length > 0) {\n          report += `- **Images**:\\n`;\n          step.images.forEach((img: any) => {\n            const imageType = img.imagetype === 0 ? 'PreImage' : img.imagetype === 1 ? 'PostImage' : 'Both';\n            report += `  - ${img.name} (${imageType}) â†’ Attributes: ${img.attributes || '(all)'}\\n`;\n          });\n        } else {\n          report += `- **Images**: None\\n`;\n        }\n        report += `\\n`;\n      });\n\n      report += `## Validation Results\\n\\n`;\n      if (result.validation.hasDisabledSteps) {\n        report += `âš  Some steps are disabled\\n`;\n      } else {\n        report += `âœ“ All steps are enabled\\n`;\n      }\n\n      if (result.validation.stepsWithoutFilteringAttributes.length > 0) {\n        report += `âš  Warning: ${result.validation.stepsWithoutFilteringAttributes.length} Update/Delete steps without filtering attributes:\\n`;\n        result.validation.stepsWithoutFilteringAttributes.forEach((name: string) => {\n          report += `  - ${name}\\n`;\n        });\n      } else {\n        report += `âœ“ All Update/Delete steps have filtering attributes\\n`;\n      }\n\n      if (result.validation.stepsWithoutImages.length > 0) {\n        report += `âš  Warning: ${result.validation.stepsWithoutImages.length} Update/Delete steps without images:\\n`;\n        result.validation.stepsWithoutImages.forEach((name: string) => {\n          report += `  - ${name}\\n`;\n        });\n      }\n\n      if (result.validation.potentialIssues.length > 0) {\n        report += `\\n### Potential Issues\\n`;\n        result.validation.potentialIssues.forEach((issue: string) => {\n          report += `- ${issue}\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating plugin deployment report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "entity-plugin-pipeline-report",
        "code": "server.prompt(\n  \"entity-plugin-pipeline-report\",\n  \"Generate a visual execution pipeline showing all plugins for an entity\",\n  {\n    entityName: z.string().describe(\"The logical name of the entity\"),\n    messageFilter: z.string().optional().describe(\"Optional filter by message name\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getEntityPluginPipeline(args.entityName, args.messageFilter, false);\n\n      // Build markdown report\n      let report = `# Plugin Pipeline: ${result.entity} Entity\\n\\n`;\n\n      if (result.steps.length === 0) {\n        report += `No plugins registered for this entity.\\n`;\n      } else {\n        // Group by message\n        result.messages.forEach((msg: any) => {\n          report += `## ${msg.messageName} Message\\n\\n`;\n\n          // PreValidation stage\n          if (msg.stages.preValidation.length > 0) {\n            report += `### Stage 1: PreValidation (Synchronous)\\n`;\n            msg.stages.preValidation.forEach((step: any, idx: number) => {\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          // PreOperation stage\n          if (msg.stages.preOperation.length > 0) {\n            report += `### Stage 2: PreOperation (Synchronous)\\n`;\n            msg.stages.preOperation.forEach((step: any, idx: number) => {\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          // PostOperation stage\n          if (msg.stages.postOperation.length > 0) {\n            report += `### Stage 3: PostOperation\\n`;\n            msg.stages.postOperation.forEach((step: any, idx: number) => {\n              const mode = step.modeName === 'Asynchronous' ? ' (Async)' : ' (Sync)';\n              report += `${idx + 1}. **[Rank ${step.rank}]** ${step.pluginType}${mode}\\n`;\n              report += `   - Assembly: ${step.assemblyName} v${step.assemblyVersion}\\n`;\n              report += `   - Filtering: ${step.filteringAttributes.join(', ') || '(all columns)'}\\n`;\n              if (step.hasPreImage || step.hasPostImage) {\n                const images = [];\n                if (step.hasPreImage) images.push('PreImage');\n                if (step.hasPostImage) images.push('PostImage');\n                report += `   - Images: ${images.join(', ')}\\n`;\n              }\n              report += `\\n`;\n            });\n          }\n\n          report += `---\\n\\n`;\n        });\n\n        report += `## Execution Order\\n\\n`;\n        report += `Plugins execute in this order:\\n`;\n        result.executionOrder.forEach((name: string, idx: number) => {\n          report += `${idx + 1}. ${name}\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating entity plugin pipeline report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "flows-report",
        "code": "server.prompt(\n  \"flows-report\",\n  \"Generate a comprehensive report of all Power Automate flows in the environment\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated flows (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getFlows(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Power Automate Flows Report\\n\\n`;\n      report += `**Total Flows**: ${result.totalCount}\\n\\n`;\n\n      if (result.flows.length === 0) {\n        report += `No flows found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeFlows = result.flows.filter((f: any) => f.state === 'Activated');\n        const draftFlows = result.flows.filter((f: any) => f.state === 'Draft');\n        const suspendedFlows = result.flows.filter((f: any) => f.state === 'Suspended');\n\n        if (activeFlows.length > 0) {\n          report += `## Active Flows (${activeFlows.length})\\n\\n`;\n          activeFlows.forEach((flow: any) => {\n            report += `### ${flow.name}\\n`;\n            report += `- **ID**: ${flow.workflowid}\\n`;\n            report += `- **Description**: ${flow.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${flow.primaryEntity || 'None'}\\n`;\n            report += `- **Owner**: ${flow.owner}\\n`;\n            report += `- **Modified**: ${flow.modifiedOn} by ${flow.modifiedBy}\\n`;\n            report += `- **Managed**: ${flow.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftFlows.length > 0) {\n          report += `## Draft Flows (${draftFlows.length})\\n\\n`;\n          draftFlows.forEach((flow: any) => {\n            report += `- **${flow.name}** (${flow.workflowid})\\n`;\n            report += `  - Owner: ${flow.owner}, Modified: ${flow.modifiedOn}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedFlows.length > 0) {\n          report += `## Suspended Flows (${suspendedFlows.length})\\n\\n`;\n          suspendedFlows.forEach((flow: any) => {\n            report += `- **${flow.name}** (${flow.workflowid})\\n`;\n            report += `  - Owner: ${flow.owner}, Modified: ${flow.modifiedOn}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating flows report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "workflows-report",
        "code": "server.prompt(\n  \"workflows-report\",\n  \"Generate a comprehensive report of all classic Dynamics workflows in the environment\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated workflows (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getWorkflows(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Classic Dynamics Workflows Report\\n\\n`;\n      report += `**Total Workflows**: ${result.totalCount}\\n\\n`;\n\n      if (result.workflows.length === 0) {\n        report += `No classic workflows found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeWorkflows = result.workflows.filter((w: any) => w.state === 'Activated');\n        const draftWorkflows = result.workflows.filter((w: any) => w.state === 'Draft');\n        const suspendedWorkflows = result.workflows.filter((w: any) => w.state === 'Suspended');\n\n        if (activeWorkflows.length > 0) {\n          report += `## Active Workflows (${activeWorkflows.length})\\n\\n`;\n          activeWorkflows.forEach((workflow: any) => {\n            report += `### ${workflow.name}\\n`;\n            report += `- **ID**: ${workflow.workflowid}\\n`;\n            report += `- **Description**: ${workflow.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${workflow.primaryEntity || 'None'}\\n`;\n            report += `- **Mode**: ${workflow.mode}\\n`;\n            report += `- **Triggers**:\\n`;\n            if (workflow.triggerOnCreate) report += `  - Create\\n`;\n            if (workflow.triggerOnDelete) report += `  - Delete\\n`;\n            if (workflow.isOnDemand) report += `  - On Demand\\n`;\n            report += `- **Owner**: ${workflow.owner}\\n`;\n            report += `- **Modified**: ${workflow.modifiedOn} by ${workflow.modifiedBy}\\n`;\n            report += `- **Managed**: ${workflow.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftWorkflows.length > 0) {\n          report += `## Draft Workflows (${draftWorkflows.length})\\n\\n`;\n          draftWorkflows.forEach((workflow: any) => {\n            report += `- **${workflow.name}** (${workflow.workflowid})\\n`;\n            report += `  - Entity: ${workflow.primaryEntity}, Owner: ${workflow.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedWorkflows.length > 0) {\n          report += `## Suspended Workflows (${suspendedWorkflows.length})\\n\\n`;\n          suspendedWorkflows.forEach((workflow: any) => {\n            report += `- **${workflow.name}** (${workflow.workflowid})\\n`;\n            report += `  - Entity: ${workflow.primaryEntity}, Owner: ${workflow.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating workflows report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "business-rules-report",
        "code": "server.prompt(\n  \"business-rules-report\",\n  \"Generate a comprehensive report of all business rules in the environment (read-only for troubleshooting)\",\n  {\n    activeOnly: z.string().optional().describe(\"Set to 'true' to only include activated business rules (default: false)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n      const result = await service.getBusinessRules(args.activeOnly === 'true', 100);\n\n      // Build markdown report\n      let report = `# Business Rules Report\\n\\n`;\n      report += `**Total Business Rules**: ${result.totalCount}\\n\\n`;\n\n      if (result.businessRules.length === 0) {\n        report += `No business rules found in this environment.\\n`;\n      } else {\n        // Group by state\n        const activeRules = result.businessRules.filter((r: any) => r.state === 'Activated');\n        const draftRules = result.businessRules.filter((r: any) => r.state === 'Draft');\n        const suspendedRules = result.businessRules.filter((r: any) => r.state === 'Suspended');\n\n        if (activeRules.length > 0) {\n          report += `## Active Business Rules (${activeRules.length})\\n\\n`;\n          activeRules.forEach((rule: any) => {\n            report += `### ${rule.name}\\n`;\n            report += `- **ID**: ${rule.workflowid}\\n`;\n            report += `- **Description**: ${rule.description || 'No description'}\\n`;\n            report += `- **Primary Entity**: ${rule.primaryEntity || 'None'}\\n`;\n            report += `- **Owner**: ${rule.owner}\\n`;\n            report += `- **Modified**: ${rule.modifiedOn} by ${rule.modifiedBy}\\n`;\n            report += `- **Managed**: ${rule.isManaged ? 'Yes' : 'No'}\\n\\n`;\n          });\n        }\n\n        if (draftRules.length > 0) {\n          report += `## Draft Business Rules (${draftRules.length})\\n\\n`;\n          draftRules.forEach((rule: any) => {\n            report += `- **${rule.name}** (${rule.workflowid})\\n`;\n            report += `  - Entity: ${rule.primaryEntity}, Owner: ${rule.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n\n        if (suspendedRules.length > 0) {\n          report += `## Suspended Business Rules (${suspendedRules.length})\\n\\n`;\n          suspendedRules.forEach((rule: any) => {\n            report += `- **${rule.name}** (${rule.workflowid})\\n`;\n            report += `  - Entity: ${rule.primaryEntity}, Owner: ${rule.owner}\\n`;\n          });\n          report += `\\n`;\n        }\n      }\n\n      report += `\\n---\\n\\n`;\n      report += `*Note: Business rules are read-only in this MCP server. Use the PowerPlatform UI to create or modify business rules.*\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating business rules report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "app-overview",
        "code": "server.prompt(\n  \"app-overview\",\n  \"Generate a comprehensive overview report for a model-driven app including components and configuration\",\n  {\n    appId: z.string().describe(\"The GUID of the app (appmoduleid)\"),\n  },\n  async (args) => {\n    try {\n      const service = getPowerPlatformService();\n\n      // Get app details, components, and sitemap\n      const app = await service.getApp(args.appId);\n      const components = await service.getAppComponents(args.appId);\n      const sitemap = await service.getAppSitemap(args.appId);\n\n      // Build markdown report\n      let report = `# Model-Driven App Overview: ${app.name}\\n\\n`;\n\n      // Basic Information\n      report += `## Basic Information\\n`;\n      report += `- **App ID**: ${app.appmoduleid}\\n`;\n      report += `- **Unique Name**: ${app.uniquename}\\n`;\n      report += `- **Description**: ${app.description || 'No description'}\\n`;\n      report += `- **State**: ${app.state}\\n`;\n      report += `- **Navigation Type**: ${app.navigationtype}\\n`;\n      report += `- **Featured**: ${app.isfeatured ? 'Yes' : 'No'}\\n`;\n      report += `- **Default App**: ${app.isdefault ? 'Yes' : 'No'}\\n`;\n      report += `- **Published On**: ${app.publishedon || 'Not published'}\\n`;\n      report += `- **Created**: ${app.createdon} by ${app.createdBy || 'Unknown'}\\n`;\n      report += `- **Modified**: ${app.modifiedon} by ${app.modifiedBy || 'Unknown'}\\n\\n`;\n\n      // Publisher Information\n      if (app.publisher) {\n        report += `## Publisher\\n`;\n        report += `- **Name**: ${app.publisher.friendlyname}\\n`;\n        report += `- **Unique Name**: ${app.publisher.uniquename}\\n`;\n        report += `- **Prefix**: ${app.publisher.customizationprefix}\\n\\n`;\n      }\n\n      // Components Summary\n      report += `## Components Summary\\n`;\n      report += `**Total Components**: ${components.totalCount}\\n\\n`;\n\n      if (components.totalCount > 0) {\n        // Group by type\n        Object.keys(components.groupedByType).forEach((typeName: string) => {\n          const typeComponents = components.groupedByType[typeName];\n          report += `- **${typeName}**: ${typeComponents.length}\\n`;\n        });\n        report += `\\n`;\n\n        // Detailed component list by type\n        report += `## Detailed Components\\n\\n`;\n        Object.keys(components.groupedByType).forEach((typeName: string) => {\n          const typeComponents = components.groupedByType[typeName];\n          report += `### ${typeName} (${typeComponents.length})\\n`;\n          typeComponents.forEach((comp: any, idx: number) => {\n            report += `${idx + 1}. ID: ${comp.objectid}\\n`;\n          });\n          report += `\\n`;\n        });\n      }\n\n      // Sitemap Information\n      if (sitemap.hasSitemap) {\n        report += `## Navigation (Sitemap)\\n`;\n        report += `- **Sitemap Name**: ${sitemap.sitemapname}\\n`;\n        report += `- **App Aware**: ${sitemap.isappaware ? 'Yes' : 'No'}\\n`;\n        report += `- **Collapsible Groups**: ${sitemap.enablecollapsiblegroups ? 'Yes' : 'No'}\\n`;\n        report += `- **Show Home**: ${sitemap.showhome ? 'Yes' : 'No'}\\n`;\n        report += `- **Show Pinned**: ${sitemap.showpinned ? 'Yes' : 'No'}\\n`;\n        report += `- **Show Recents**: ${sitemap.showrecents ? 'Yes' : 'No'}\\n`;\n        report += `- **Managed**: ${sitemap.ismanaged ? 'Yes' : 'No'}\\n\\n`;\n      } else {\n        report += `## Navigation (Sitemap)\\n`;\n        report += `âš  No sitemap configured for this app\\n\\n`;\n      }\n\n      // Next Steps\n      report += `## Available Actions\\n`;\n      report += `- Add entities: Use \\`add-entities-to-app\\` tool\\n`;\n      report += `- Validate app: Use \\`validate-app\\` tool\\n`;\n      report += `- Publish app: Use \\`publish-app\\` tool\\n`;\n      report += `- View sitemap XML: Use \\`get-app-sitemap\\` tool\\n\\n`;\n\n      report += `---\\n\\n`;\n      report += `*Generated by MCP Consultant Tools*\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating app overview:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      }
    ],
    "azure-devops": [
      {
        "name": "wiki-search-results",
        "code": "server.prompt(\n  \"wiki-search-results\",\n  \"Search Azure DevOps wiki pages and get formatted results with content snippets\",\n  {\n    searchText: z.string().describe(\"The text to search for\"),\n    project: z.string().optional().describe(\"Optional project filter\"),\n    maxResults: z.string().optional().describe(\"Maximum number of results (default: 25)\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { searchText, project, maxResults } = args;\n      const maxResultsNum = maxResults ? parseInt(maxResults, 10) : undefined;\n      const result = await service.searchWikiPages(searchText, project, maxResultsNum);\n\n      let report = `# Wiki Search Results: \"${searchText}\"\\n\\n`;\n      report += `**Project:** ${project || 'All allowed projects'}\\n`;\n      report += `**Total Results:** ${result.totalCount}\\n\\n`;\n\n      if (result.results && result.results.length > 0) {\n        report += `## Results\\n\\n`;\n        result.results.forEach((item: any, index: number) => {\n          report += `### ${index + 1}. ${item.fileName}\\n`;\n          report += `- **Path:** ${item.path}\\n`;\n          report += `- **Wiki:** ${item.wikiName}\\n`;\n          report += `- **Project:** ${item.project}\\n`;\n          if (item.highlights && item.highlights.length > 0) {\n            report += `- **Highlights:**\\n`;\n            item.highlights.forEach((highlight: string) => {\n              // Remove HTML tags for cleaner display\n              const cleanHighlight = highlight.replace(/<[^>]*>/g, '');\n              report += `  - ${cleanHighlight}\\n`;\n            });\n          }\n          report += `\\n`;\n        });\n      } else {\n        report += `No results found for \"${searchText}\".\\n`;\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating wiki search results:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "wiki-page-content",
        "code": "server.prompt(\n  \"wiki-page-content\",\n  \"Get a formatted wiki page with navigation context from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wikiId: z.string().describe(\"The wiki identifier\"),\n    pagePath: z.string().describe(\"The path to the page\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, wikiId, pagePath } = args;\n      const result = await service.getWikiPage(project, wikiId, pagePath, true);\n\n      let report = `# Wiki Page: ${pagePath}\\n\\n`;\n      report += `**Project:** ${project}\\n`;\n      report += `**Wiki:** ${wikiId}\\n`;\n      report += `**Git Path:** ${result.gitItemPath || 'N/A'}\\n\\n`;\n\n      if (result.subPages && result.subPages.length > 0) {\n        report += `## Sub-pages\\n`;\n        result.subPages.forEach((subPage: any) => {\n          report += `- ${subPage.path}\\n`;\n        });\n        report += `\\n`;\n      }\n\n      report += `## Content\\n\\n`;\n      report += result.content || '*No content available*';\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating wiki page content:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "work-item-summary",
        "code": "server.prompt(\n  \"work-item-summary\",\n  \"Get a comprehensive summary of a work item with comments from Azure DevOps\",\n  {\n    project: z.string().describe(\"The project name\"),\n    workItemId: z.string().describe(\"The work item ID\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, workItemId } = args;\n      const workItemIdNum = parseInt(workItemId, 10);\n\n      // Get work item and comments in parallel\n      const [workItem, comments] = await Promise.all([\n        service.getWorkItem(project, workItemIdNum),\n        service.getWorkItemComments(project, workItemIdNum)\n      ]);\n\n      const fields = workItem.fields || {};\n\n      let report = `# Work Item #${workItemId}: ${fields['System.Title'] || 'Untitled'}\\n\\n`;\n\n      report += `## Details\\n`;\n      report += `- **Type:** ${fields['System.WorkItemType'] || 'N/A'}\\n`;\n      report += `- **State:** ${fields['System.State'] || 'N/A'}\\n`;\n      report += `- **Assigned To:** ${fields['System.AssignedTo']?.displayName || 'Unassigned'}\\n`;\n      report += `- **Created By:** ${fields['System.CreatedBy']?.displayName || 'N/A'}\\n`;\n      report += `- **Created Date:** ${fields['System.CreatedDate'] || 'N/A'}\\n`;\n      report += `- **Changed Date:** ${fields['System.ChangedDate'] || 'N/A'}\\n`;\n      report += `- **Area Path:** ${fields['System.AreaPath'] || 'N/A'}\\n`;\n      report += `- **Iteration Path:** ${fields['System.IterationPath'] || 'N/A'}\\n`;\n      if (fields['System.Tags']) {\n        report += `- **Tags:** ${fields['System.Tags']}\\n`;\n      }\n      report += `\\n`;\n\n      if (fields['System.Description']) {\n        report += `## Description\\n${fields['System.Description']}\\n\\n`;\n      }\n\n      if (fields['Microsoft.VSTS.TCM.ReproSteps']) {\n        report += `## Repro Steps\\n${fields['Microsoft.VSTS.TCM.ReproSteps']}\\n\\n`;\n      }\n\n      if (workItem.relations && workItem.relations.length > 0) {\n        report += `## Related Items\\n`;\n        workItem.relations.forEach((relation: any) => {\n          report += `- ${relation.rel}: ${relation.url}\\n`;\n        });\n        report += `\\n`;\n      }\n\n      if (comments.comments && comments.comments.length > 0) {\n        report += `## Comments (${comments.totalCount})\\n\\n`;\n        comments.comments.forEach((comment: any) => {\n          report += `### ${comment.createdBy} - ${new Date(comment.createdDate).toLocaleString()}\\n`;\n          report += `${comment.text}\\n\\n`;\n        });\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating work item summary:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      },
      {
        "name": "work-items-query-report",
        "code": "server.prompt(\n  \"work-items-query-report\",\n  \"Execute a WIQL query and get formatted results grouped by state/type\",\n  {\n    project: z.string().describe(\"The project name\"),\n    wiql: z.string().describe(\"The WIQL query string\"),\n    maxResults: z.string().optional().describe(\"Maximum number of results (default: 200)\"),\n  },\n  async (args) => {\n    try {\n      const service = getAzureDevOpsService();\n      const { project, wiql, maxResults } = args;\n      const maxResultsNum = maxResults ? parseInt(maxResults, 10) : undefined;\n      const result = await service.queryWorkItems(project, wiql, maxResultsNum);\n\n      let report = `# Work Items Query Results\\n\\n`;\n      report += `**Project:** ${project}\\n`;\n      report += `**Total Results:** ${result.totalCount}\\n\\n`;\n\n      if (result.workItems && result.workItems.length > 0) {\n        // Group by state\n        const groupedByState = new Map<string, any[]>();\n        result.workItems.forEach((item: any) => {\n          const state = item.fields['System.State'] || 'Unknown';\n          if (!groupedByState.has(state)) {\n            groupedByState.set(state, []);\n          }\n          groupedByState.get(state)!.push(item);\n        });\n\n        // Sort states: Active, Resolved, Closed, others\n        const stateOrder = ['Active', 'New', 'Resolved', 'Closed'];\n        const sortedStates = Array.from(groupedByState.keys()).sort((a, b) => {\n          const aIndex = stateOrder.indexOf(a);\n          const bIndex = stateOrder.indexOf(b);\n          if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);\n          if (aIndex === -1) return 1;\n          if (bIndex === -1) return -1;\n          return aIndex - bIndex;\n        });\n\n        sortedStates.forEach(state => {\n          const items = groupedByState.get(state)!;\n          report += `## ${state} (${items.length})\\n\\n`;\n          items.forEach((item: any) => {\n            const fields = item.fields;\n            report += `- **#${item.id}**: ${fields['System.Title'] || 'Untitled'}\\n`;\n            report += `  - Type: ${fields['System.WorkItemType'] || 'N/A'}`;\n            report += `, Assigned: ${fields['System.AssignedTo']?.displayName || 'Unassigned'}\\n`;\n          });\n          report += `\\n`;\n        });\n      } else {\n        report += `No work items found matching the query.\\n`;\n      }\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report\n            }\n          }\n        ]\n      };\n    } catch (error: any) {\n      console.error(`Error generating work items query report:`, error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Error: ${error.message}`\n            }\n          }\n        ]\n      };\n    }\n  }\n);"
      }
    ],
    "application-insights": [
      {
        "name": "appinsights-exception-summary",
        "code": "server.prompt(\n  \"appinsights-exception-summary\",\n  \"Generate a comprehensive exception summary report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get recent exceptions\n      const exceptionsResult = await service.getRecentExceptions(resourceId, timespanValue, 50);\n\n      // Get exception type frequency\n      const exceptionTypesResult = await service.executeQuery(\n        resourceId,\n        `\n          exceptions\n          | where timestamp > ago(${timespanValue.replace(/^P(T)?/, '')})\n          | summarize Count=count() by type\n          | order by Count desc\n        `.trim(),\n        timespanValue\n      );\n\n      // Format results\n      const exceptionsList = formatTableAsMarkdown(exceptionsResult.tables[0]);\n      const exceptionTypes = formatTableAsMarkdown(exceptionTypesResult.tables[0]);\n      const insights = analyzeExceptions(exceptionsResult.tables[0]);\n\n      const report = `# Application Insights Exception Summary Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Recent Exceptions\\n\\n${exceptionsList}\\n\\n` +\n        `## Exception Types (Frequency)\\n\\n${exceptionTypes}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Review the most frequent exception types to identify systemic issues\\n` +\n        `- Investigate exceptions in critical operations first\\n` +\n        `- Check for patterns in timestamps (e.g., deployment times, peak traffic)\\n` +\n        `- Use operation_Id to correlate exceptions with requests and dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating exception summary:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate exception summary: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-performance-report",
        "code": "server.prompt(\n  \"appinsights-performance-report\",\n  \"Generate a comprehensive performance analysis report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get operation performance\n      const performanceResult = await service.getOperationPerformance(resourceId, timespanValue);\n\n      // Get slow requests\n      const slowRequestsResult = await service.getSlowRequests(resourceId, 5000, timespanValue, 20);\n\n      // Format results\n      const performanceTable = formatTableAsMarkdown(performanceResult.tables[0]);\n      const slowRequestsTable = formatTableAsMarkdown(slowRequestsResult.tables[0]);\n      const insights = analyzePerformance(performanceResult.tables[0]);\n\n      const report = `# Application Insights Performance Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Operation Performance Summary\\n\\n${performanceTable}\\n\\n` +\n        `## Slowest Requests (>5s)\\n\\n${slowRequestsTable}\\n\\n` +\n        `## Performance Recommendations\\n\\n` +\n        `- Focus optimization efforts on operations with high P95/P99 duration\\n` +\n        `- Investigate operations with high failure counts\\n` +\n        `- Monitor operations with high request counts for scalability issues\\n` +\n        `- Use operation_Id to trace slow requests through dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating performance report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate performance report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-dependency-health",
        "code": "server.prompt(\n  \"appinsights-dependency-health\",\n  \"Generate a dependency health report showing external service issues\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get failed dependencies\n      const failedDepsResult = await service.getFailedDependencies(resourceId, timespanValue, 50);\n\n      // Get dependency success rates\n      const successRatesResult = await service.executeQuery(\n        resourceId,\n        `\n          dependencies\n          | where timestamp > ago(${timespanValue.replace(/^P(T)?/, '')})\n          | summarize Total=count(), Failed=countif(success == false), AvgDuration=avg(duration) by target, type\n          | extend SuccessRate=round(100.0 * (Total - Failed) / Total, 2)\n          | order by SuccessRate asc\n        `.trim(),\n        timespanValue\n      );\n\n      // Format results\n      const failedDepsTable = formatTableAsMarkdown(failedDepsResult.tables[0]);\n      const successRatesTable = formatTableAsMarkdown(successRatesResult.tables[0]);\n      const insights = analyzeDependencies(failedDepsResult.tables[0]);\n\n      const report = `# Application Insights Dependency Health Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Key Insights\\n\\n${insights}\\n\\n` +\n        `## Failed Dependencies\\n\\n${failedDepsTable}\\n\\n` +\n        `## Dependency Success Rates\\n\\n${successRatesTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Investigate dependencies with success rates below 99%\\n` +\n        `- Check if external service degradation matches known incidents\\n` +\n        `- Review timeout configurations for slow dependencies\\n` +\n        `- Consider implementing circuit breakers for unreliable dependencies`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating dependency health report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate dependency health report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-availability-report",
        "code": "server.prompt(\n  \"appinsights-availability-report\",\n  \"Generate an availability and uptime report from Application Insights\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT24H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT24H';\n\n      // Get availability results\n      const availabilityResult = await service.getAvailabilityResults(resourceId, timespanValue);\n\n      // Format results\n      const availabilityTable = formatTableAsMarkdown(availabilityResult.tables[0]);\n\n      const report = `# Application Insights Availability Report\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n\\n` +\n        `## Availability Test Results\\n\\n${availabilityTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Investigate any tests with success rates below 99.9%\\n` +\n        `- Review failed tests for patterns (geographic, time-based)\\n` +\n        `- Consider adding availability tests for critical endpoints if missing\\n` +\n        `- Set up alerts for availability degradation`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating availability report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate availability report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "appinsights-troubleshooting-guide",
        "code": "server.prompt(\n  \"appinsights-troubleshooting-guide\",\n  \"Generate a comprehensive troubleshooting guide combining exceptions, performance, and dependencies\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getApplicationInsightsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get data from multiple sources\n      const exceptionsResult = await service.getRecentExceptions(resourceId, timespanValue, 20);\n      const slowRequestsResult = await service.getSlowRequests(resourceId, 5000, timespanValue, 20);\n      const failedDepsResult = await service.getFailedDependencies(resourceId, timespanValue, 20);\n      const tracesResult = await service.getTracesBySeverity(resourceId, 3, timespanValue, 30); // Error level\n\n      // Format results\n      const exceptionsTable = formatTableAsMarkdown(exceptionsResult.tables[0]);\n      const slowRequestsTable = formatTableAsMarkdown(slowRequestsResult.tables[0]);\n      const failedDepsTable = formatTableAsMarkdown(failedDepsResult.tables[0]);\n      const tracesTable = formatTableAsMarkdown(tracesResult.tables[0]);\n\n      const report = `# Application Insights Troubleshooting Guide\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## 1. Recent Errors and Exceptions\\n\\n${exceptionsTable}\\n\\n` +\n        `## 2. Performance Issues\\n\\n${slowRequestsTable}\\n\\n` +\n        `## 3. Dependency Failures\\n\\n${failedDepsTable}\\n\\n` +\n        `## 4. Diagnostic Logs (Errors)\\n\\n${tracesTable}\\n\\n` +\n        `## 5. Investigation Steps\\n\\n` +\n        `1. **Identify the pattern**: Check if errors are isolated or widespread\\n` +\n        `2. **Correlate events**: Use operation_Id to trace requests across services\\n` +\n        `3. **Check timeline**: Look for correlation with deployments or external events\\n` +\n        `4. **Review dependencies**: Verify external service health\\n` +\n        `5. **Analyze traces**: Review detailed logs for error context\\n\\n` +\n        `## 6. Common Patterns and Root Causes\\n\\n` +\n        `- **High exception rate + dependency failures**: External service degradation\\n` +\n        `- **Slow requests + high dependency duration**: Network or external API latency\\n` +\n        `- **Exceptions in specific operations**: Code defect or invalid input\\n` +\n        `- **Timeouts**: Insufficient resources or inefficient queries`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating troubleshooting guide:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate troubleshooting guide: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "log-analytics": [
      {
        "name": "loganalytics-workspace-summary",
        "code": "server.prompt(\n  \"loganalytics-workspace-summary\",\n  \"Generate a comprehensive health summary for a Log Analytics workspace\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get recent errors from FunctionAppLogs\n      const errorsResult = await service.getFunctionErrors(resourceId, undefined, timespanValue, 50);\n      const statsResult = await service.getFunctionStats(resourceId, undefined, timespanValue);\n\n      // Format results\n      const errorsTable = errorsResult.tables[0] ? formatLATableAsMarkdown(errorsResult.tables[0]) : '*No errors*';\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n\n      // Analyze\n      const errorsAnalysis = analyzeFunctionErrors(errorsResult.tables[0]);\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Log Analytics Workspace Health Summary\\n\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Function Statistics\\n\\n${statsTable}\\n\\n` +\n        `### Key Insights\\n${statsAnalysis}\\n\\n` +\n        `## Recent Errors\\n\\n${errorsTable}\\n\\n` +\n        `### Error Analysis\\n${errorsAnalysis}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        generateRecommendations({\n          errorCount: errorsResult.tables[0]?.rows.length || 0,\n        }).join('\\n');\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating workspace summary:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate workspace summary: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-function-troubleshooting",
        "code": "server.prompt(\n  \"loganalytics-function-troubleshooting\",\n  \"Generate a comprehensive troubleshooting guide for an Azure Function\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().describe(\"Function name to analyze\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get comprehensive data\n      const logsResult = await service.getFunctionLogs(resourceId, functionName, timespanValue, undefined, 100);\n      const errorsResult = await service.getFunctionErrors(resourceId, functionName, timespanValue, 50);\n      const statsResult = await service.getFunctionStats(resourceId, functionName, timespanValue);\n      const invocationsResult = await service.getFunctionInvocations(resourceId, functionName, timespanValue, 50);\n\n      // Format results\n      const logsTable = logsResult.tables[0] ? formatLATableAsMarkdown(logsResult.tables[0]) : '*No logs*';\n      const errorsTable = errorsResult.tables[0] ? formatLATableAsMarkdown(errorsResult.tables[0]) : '*No errors*';\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n      const invocationsTable = invocationsResult.tables[0] ? formatLATableAsMarkdown(invocationsResult.tables[0]) : '*No invocations*';\n\n      // Analyze\n      const logsAnalysis = analyzeFunctionLogs(logsResult.tables[0]);\n      const errorsAnalysis = analyzeFunctionErrors(errorsResult.tables[0]);\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Azure Function Troubleshooting Guide\\n\\n` +\n        `**Function**: ${functionName}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Executive Summary\\n\\n${statsTable}\\n\\n` +\n        `### Statistics Insights\\n${statsAnalysis}\\n\\n` +\n        `## Error Analysis\\n\\n${errorsTable}\\n\\n` +\n        `### Error Insights\\n${errorsAnalysis}\\n\\n` +\n        `## Recent Logs\\n\\n${logsTable}\\n\\n` +\n        `### Log Insights\\n${logsAnalysis}\\n\\n` +\n        `## Recent Invocations\\n\\n${invocationsTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        generateRecommendations({\n          errorCount: errorsResult.tables[0]?.rows.length || 0,\n        }).join('\\n');\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating function troubleshooting guide:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate troubleshooting guide: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-function-performance-report",
        "code": "server.prompt(\n  \"loganalytics-function-performance-report\",\n  \"Generate a performance analysis report for Azure Functions\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    functionName: z.string().optional().describe(\"Function name (optional, analyzes all if not specified)\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n  },\n  async ({ resourceId, functionName, timespan }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n\n      // Get performance data\n      const statsResult = await service.getFunctionStats(resourceId, functionName, timespanValue);\n      const invocationsResult = await service.getFunctionInvocations(resourceId, functionName, timespanValue, 100);\n\n      // Format results\n      const statsTable = statsResult.tables[0] ? formatLATableAsMarkdown(statsResult.tables[0]) : '*No statistics*';\n      const invocationsTable = invocationsResult.tables[0] ? formatLATableAsMarkdown(invocationsResult.tables[0]) : '*No invocations*';\n\n      // Analyze\n      const statsAnalysis = analyzeFunctionStats(statsResult.tables[0]);\n\n      const report = `# Azure Function Performance Report\\n\\n` +\n        `**Function**: ${functionName || 'All Functions'}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Execution Statistics\\n\\n${statsTable}\\n\\n` +\n        `### Performance Insights\\n${statsAnalysis}\\n\\n` +\n        `## Recent Invocations\\n\\n${invocationsTable}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Monitor success rates and investigate functions below 95%\\n` +\n        `- Review invocation patterns for optimization opportunities\\n` +\n        `- Consider implementing retry logic for transient failures\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating performance report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate performance report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      },
      {
        "name": "loganalytics-logs-report",
        "code": "server.prompt(\n  \"loganalytics-logs-report\",\n  \"Generate a formatted logs report with insights and analysis\",\n  {\n    resourceId: z.string().describe(\"Resource ID\"),\n    tableName: z.string().describe(\"Table name to query\"),\n    timespan: z.string().optional().describe(\"Time range (default: PT1H)\"),\n    limit: z.string().optional().describe(\"Maximum number of logs (default: 100)\"),\n  },\n  async ({ resourceId, tableName, timespan, limit }) => {\n    try {\n      const service = getLogAnalyticsService();\n      const timespanValue = timespan || 'PT1H';\n      const limitValue = limit ? parseInt(limit, 10) : 100;\n\n      // Get logs\n      const logsResult = await service.getRecentEvents(resourceId, tableName, timespanValue, limitValue);\n\n      // Format results\n      const logsTable = logsResult.tables[0] ? formatLATableAsMarkdown(logsResult.tables[0]) : '*No logs*';\n\n      // Analyze\n      const analysis = analyzeLogs(logsResult.tables[0], tableName);\n\n      const report = `# Log Analytics Report\\n\\n` +\n        `**Table**: ${tableName}\\n` +\n        `**Resource**: ${resourceId}\\n` +\n        `**Time Range**: ${timespanValue}\\n` +\n        `**Limit**: ${limitValue}\\n` +\n        `**Generated**: ${new Date().toISOString()}\\n\\n` +\n        `## Log Entries\\n\\n${logsTable}\\n\\n` +\n        `### Analysis\\n${analysis}\\n\\n` +\n        `## Recommendations\\n\\n` +\n        `- Review log patterns for anomalies\\n` +\n        `- Investigate any error or warning entries\\n` +\n        `- Consider adjusting log retention policies\\n`;\n\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: report,\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating logs report:\", error);\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Failed to generate logs report: ${error.message}`,\n            },\n          },\n        ],\n      };\n    }\n  }\n);"
      }
    ],
    "azure-sql": [
      {
        "name": "sql-database-overview",
        "code": "server.prompt(\n  \"sql-database-overview\",\n  \"Get a comprehensive overview of the Azure SQL Database schema\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n  },\n  async ({ serverId, database }) => {\n    const sqlService = getAzureSqlService();\n\n    const [tables, views, procedures, triggers, functions] = await Promise.all([\n      sqlService.listTables(serverId, database),\n      sqlService.listViews(serverId, database),\n      sqlService.listStoredProcedures(serverId, database),\n      sqlService.listTriggers(serverId, database),\n      sqlService.listFunctions(serverId, database),\n    ]);\n\n    const formattedOverview = formatDatabaseOverview(tables, views, procedures, triggers, functions);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: formattedOverview,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "sql-table-details",
        "code": "server.prompt(\n  \"sql-table-details\",\n  \"Get detailed report for a specific table with columns, indexes, and relationships\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    schemaName: z.string().describe(\"Schema name (e.g., 'dbo')\"),\n    tableName: z.string().describe(\"Table name\"),\n  },\n  async ({ serverId, database, schemaName, tableName }) => {\n    const sqlService = getAzureSqlService();\n    const schema = await sqlService.getTableSchema(serverId, database, schemaName, tableName);\n\n    let template = formatTableSchemaAsMarkdown(schema);\n    template += `\\n\\n### Sample Query\\n\\n\\`\\`\\`sql\\nSELECT TOP 100 * FROM ${schemaName}.${tableName}\\n\\`\\`\\``;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: template,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "sql-query-results",
        "code": "server.prompt(\n  \"sql-query-results\",\n  \"Execute a query and return formatted results with column headers\",\n  {\n    serverId: z.string().describe(\"Server ID (use sql-list-servers to find IDs)\"),\n    database: z.string().describe(\"Database name (use sql-list-databases to find databases)\"),\n    query: z.string().describe(\"SELECT query to execute\"),\n  },\n  async ({ serverId, database, query }) => {\n    const sqlService = getAzureSqlService();\n    const result = await sqlService.executeSelectQuery(serverId, database, query);\n\n    let template = `## Query Results\\n\\n`;\n    template += `**Query:**\\n\\`\\`\\`sql\\n${query}\\n\\`\\`\\`\\n\\n`;\n    template += `**Results:**\\n${formatSqlResultsAsMarkdown(result)}\\n\\n`;\n    template += `**Row Count:** ${result.rowCount}`;\n\n    if (result.truncated) {\n      template += ` (truncated)`;\n    }\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: template,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ],
    "github-enterprise": [
      {
        "name": "ghe-repo-overview",
        "code": "server.prompt(\n  \"ghe-repo-overview\",\n  \"Get a comprehensive repository overview with branch analysis and recent commits\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n  },\n  async ({ repoId }) => {\n    const service = getGitHubEnterpriseService();\n\n    const repo = service.getRepoById(repoId);\n    const [branches, defaultBranchInfo] = await Promise.all([\n      service.listBranches(repoId),\n      service.getDefaultBranch(repoId),\n    ]);\n\n    const recentCommits = await service.getCommits(repoId, defaultBranchInfo.branch, undefined, undefined, undefined, undefined, 10);\n\n    const output = formatRepositoryOverviewAsMarkdown(\n      {\n        owner: repo.owner,\n        repo: repo.repo,\n        url: `${service['config'].baseUrl}/${repo.owner}/${repo.repo}`,\n        defaultBranch: defaultBranchInfo.branch,\n        description: repo.description,\n        active: repo.active,\n      },\n      branches,\n      recentCommits\n    );\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-code-search-report",
        "code": "server.prompt(\n  \"ghe-code-search-report\",\n  \"Search code across repositories and get formatted results with analysis\",\n  {\n    query: z.string().describe(\"Search query\"),\n    repoId: z.string().optional().describe(\"Limit to specific repository ID\"),\n    extension: z.string().optional().describe(\"Filter by file extension (e.g., 'cs', 'js')\"),\n  },\n  async ({ query, repoId, extension }) => {\n    const service = getGitHubEnterpriseService();\n    const results = await service.searchCode(query, repoId, undefined, extension);\n\n    const output = formatCodeSearchResultsAsMarkdown(results);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-branch-comparison-report",
        "code": "server.prompt(\n  \"ghe-branch-comparison-report\",\n  \"Compare branches and generate deployment-ready summary with checklist\",\n  {\n    repoId: z.string().describe(\"Repository ID from configuration\"),\n    base: z.string().describe(\"Base branch (e.g., 'main')\"),\n    head: z.string().describe(\"Head branch to compare (e.g., 'release/9.0')\"),\n  },\n  async ({ repoId, base, head }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    const comparison = await service.compareBranches(repoId, base, head);\n    const insights = analyzeBranchComparison(comparison);\n    const checklist = generateDeploymentChecklist(comparison);\n\n    let output = `# Branch Comparison: ${base} â† ${head}\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Comparing:** \\`${base}\\` (base) â† \\`${head}\\` (head)\\n\\n`;\n\n    output += `## Summary\\n\\n`;\n    output += insights.join('\\n') + '\\n\\n';\n\n    if (comparison.commits && comparison.commits.length > 0) {\n      output += `## Commits to Deploy\\n\\n`;\n      output += formatCommitHistoryAsMarkdown(comparison.commits) + '\\n\\n';\n    }\n\n    if (comparison.files && comparison.files.length > 0) {\n      output += `## Files Changed (${comparison.files.length})\\n\\n`;\n      const header = '| File | Status | +/- | Changes |';\n      const separator = '|------|--------|-----|---------|';\n      const rows = comparison.files.slice(0, 20).map((f: any) => {\n        const status = f.status === 'added' ? 'ðŸ†• Added' :\n                       f.status === 'modified' ? 'ðŸ“ Modified' :\n                       f.status === 'removed' ? 'ðŸ—‘ï¸ Removed' :\n                       f.status === 'renamed' ? 'ðŸ“‹ Renamed' : f.status;\n        return `| \\`${f.filename}\\` | ${status} | +${f.additions}/-${f.deletions} | ${f.changes} |`;\n      });\n      output += [header, separator, ...rows].join('\\n');\n\n      if (comparison.files.length > 20) {\n        output += `\\n\\n*Showing 20 of ${comparison.files.length} files*`;\n      }\n      output += '\\n\\n';\n    }\n\n    output += `## Deployment Checklist\\n\\n`;\n    output += checklist.join('\\n');\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-troubleshooting-guide",
        "code": "server.prompt(\n  \"ghe-troubleshooting-guide\",\n  \"Generate comprehensive bug troubleshooting report with source code analysis\",\n  {\n    repoId: z.string().describe(\"Repository ID to investigate\"),\n    searchQuery: z.string().describe(\"Search query (e.g., plugin name, entity name, or code pattern)\"),\n    branch: z.string().optional().describe(\"Branch to search (default: auto-detected)\"),\n  },\n  async ({ repoId, searchQuery, branch }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    // Search for code\n    const codeResults = await service.searchCode(searchQuery, repoId);\n\n    // Search commits for references\n    const commitResults = await service.searchCommits(repoId, searchQuery);\n\n    let output = `# Bug Troubleshooting Report\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Search Query:** \\`${searchQuery}\\`\\n\\n`;\n\n    output += `## Source Code Analysis\\n\\n`;\n\n    if (codeResults.total_count > 0) {\n      output += `Found **${codeResults.total_count} code matches** across ${codeResults.items.length} files:\\n\\n`;\n      output += formatCodeSearchResultsAsMarkdown(codeResults) + '\\n\\n';\n    } else {\n      output += `*No code matches found for query: \"${searchQuery}\"*\\n\\n`;\n    }\n\n    output += `## Related Commits\\n\\n`;\n\n    if (commitResults.length > 0) {\n      output += `Found **${commitResults.length} commits** referencing \"${searchQuery}\":\\n\\n`;\n      output += formatCommitHistoryAsMarkdown(commitResults.slice(0, 10)) + '\\n\\n';\n\n      if (commitResults.length > 10) {\n        output += `*Showing 10 of ${commitResults.length} commits*\\n\\n`;\n      }\n    } else {\n      output += `*No commits found referencing \"${searchQuery}\"*\\n\\n`;\n    }\n\n    output += `## Recommendations\\n\\n`;\n    output += `1. **Review Code Matches**: Check the code search results above for relevant implementations\\n`;\n    output += `2. **Analyze Recent Changes**: Review commit history for recent modifications\\n`;\n    output += `3. **Check Branch**: Current search is on branch \\`${branch || 'auto-detected'}\\`\\n`;\n    output += `4. **Cross-Reference**: Use ADO work items or PowerPlatform plugin names to correlate issues\\n`;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "ghe-deployment-report",
        "code": "server.prompt(\n  \"ghe-deployment-report\",\n  \"Generate deployment-ready report with code changes, testing checklist, and rollback plan\",\n  {\n    repoId: z.string().describe(\"Repository ID\"),\n    fromBranch: z.string().optional().describe(\"Source branch (default: main)\"),\n    toBranch: z.string().optional().describe(\"Target branch (default: auto-detected)\"),\n  },\n  async ({ repoId, fromBranch = \"main\", toBranch }) => {\n    const service = getGitHubEnterpriseService();\n    const repo = service.getRepoById(repoId);\n\n    // Auto-detect target branch if not specified\n    const targetBranch = toBranch || (await service.getDefaultBranch(repoId)).branch;\n\n    // Get branch comparison\n    const comparison = await service.compareBranches(repoId, fromBranch, targetBranch);\n    const insights = analyzeBranchComparison(comparison);\n    const checklist = generateDeploymentChecklist(comparison);\n\n    let output = `# Deployment Report: ${targetBranch} â†’ ${fromBranch}\\n\\n`;\n    output += `**Repository:** ${repo.owner}/${repo.repo}\\n`;\n    output += `**Source:** \\`${targetBranch}\\`\\n`;\n    output += `**Target:** \\`${fromBranch}\\` (Production)\\n`;\n    output += `**Date:** ${new Date().toISOString().split('T')[0]}\\n\\n`;\n\n    output += `## Executive Summary\\n\\n`;\n    output += insights.join('\\n') + '\\n\\n';\n\n    output += `## Changes by Component\\n\\n`;\n\n    if (comparison.files && comparison.files.length > 0) {\n      // Group files by directory/component\n      const filesByDir: Record<string, any[]> = {};\n      comparison.files.forEach((f: any) => {\n        const dir = f.filename.split('/')[0] || 'root';\n        if (!filesByDir[dir]) filesByDir[dir] = [];\n        filesByDir[dir].push(f);\n      });\n\n      Object.entries(filesByDir).forEach(([dir, files]) => {\n        output += `### ${dir}/ (${files.length} files)\\n\\n`;\n        const rows = files.slice(0, 10).map((f: any) =>\n          `- \\`${f.filename}\\` (+${f.additions}, -${f.deletions})`\n        );\n        output += rows.join('\\n') + '\\n\\n';\n\n        if (files.length > 10) {\n          output += `*...and ${files.length - 10} more files*\\n\\n`;\n        }\n      });\n    }\n\n    output += `## Deployment Steps\\n\\n`;\n    output += `### 1. Pre-Deployment Verification\\n`;\n    output += `\\`\\`\\`bash\\n# Review changes\\ngit diff ${fromBranch}...${targetBranch}\\n\\n# Run tests\\nnpm test  # or: dotnet test\\n\\`\\`\\`\\n\\n`;\n\n    output += `### 2. Merge to Production\\n`;\n    output += `\\`\\`\\`bash\\ngit checkout ${fromBranch}\\ngit merge ${targetBranch} --no-ff\\ngit push origin ${fromBranch}\\n\\`\\`\\`\\n\\n`;\n\n    output += `### 3. Post-Deployment Verification\\n`;\n    output += `- [ ] Smoke tests passing\\n`;\n    output += `- [ ] No errors in logs (first 15 minutes)\\n`;\n    output += `- [ ] Verify key functionality works\\n\\n`;\n\n    output += `## Rollback Plan\\n\\n`;\n    output += `If issues occur after deployment:\\n\\n`;\n    output += `\\`\\`\\`bash\\n# Option 1: Revert merge commit\\ngit revert -m 1 HEAD\\ngit push origin ${fromBranch}\\n\\n`;\n    output += `# Option 2: Reset to previous commit (if not pushed)\\ngit reset --hard HEAD~1\\n\\`\\`\\`\\n\\n`;\n\n    output += `## Testing Checklist\\n\\n`;\n    output += checklist.join('\\n');\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ],
    "service-bus": [
      {
        "name": "servicebus-namespace-overview",
        "code": "server.prompt(\n  \"servicebus-namespace-overview\",\n  \"Generate comprehensive overview of Service Bus namespace with all queues and health metrics\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n  },\n  async ({ resourceId }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Get namespace properties\n    const namespaceProps = await service.getNamespaceProperties(resourceId);\n\n    // Get all queues\n    const queues = await service.listQueues(resourceId);\n\n    // Format as markdown\n    const output = formatNamespaceOverviewAsMarkdown({\n      namespace: resource.namespace,\n      tier: namespaceProps.tier,\n      queues,\n    });\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-queue-health",
        "code": "server.prompt(\n  \"servicebus-queue-health\",\n  \"Generate detailed health report for a specific queue with recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n  },\n  async ({ resourceId, queueName }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Get queue info (runtime metrics)\n    const queueInfo = await service.getQueueProperties(resourceId, queueName);\n\n    // Get queue config (configuration properties)\n    const queueConfig = await service.getQueueConfigProperties(resourceId, queueName);\n\n    // Get health status\n    const health = getQueueHealthStatus(queueInfo);\n\n    // Peek recent messages\n    const messages = await service.peekMessages(resourceId, queueName, 10);\n\n    // Peek dead letter messages\n    const deadLetterMessages = await service.peekDeadLetterMessages(resourceId, queueName, 10);\n\n    let output = `# Queue Health Report: ${queueName}\\n\\n`;\n    output += `**Namespace:** ${resource.namespace}\\n`;\n    output += `**Date:** ${new Date().toISOString()}\\n\\n`;\n\n    output += `## Health Status\\n\\n`;\n    output += `${health.icon} **${health.status.toUpperCase()}**\\n\\n`;\n    output += `**Reason:** ${health.reason}\\n\\n`;\n\n    output += `## Queue Metrics\\n\\n`;\n    output += `| Metric | Value |\\n`;\n    output += `|--------|-------|\\n`;\n    output += `| Active Messages | ${queueInfo.activeMessageCount || 0} |\\n`;\n    output += `| Dead Letter Messages | ${queueInfo.deadLetterMessageCount || 0} |\\n`;\n    output += `| Scheduled Messages | ${queueInfo.scheduledMessageCount || 0} |\\n`;\n    output += `| Size (bytes) | ${queueInfo.sizeInBytes?.toLocaleString() || 0} |\\n`;\n    output += `| Max Size (MB) | ${queueConfig.maxSizeInMegabytes || 0} |\\n\\n`;\n\n    output += `## Configuration\\n\\n`;\n    output += `| Setting | Value |\\n`;\n    output += `|---------|-------|\\n`;\n    output += `| Lock Duration | ${queueConfig.lockDuration || 'N/A'} |\\n`;\n    output += `| Max Delivery Count | ${queueConfig.maxDeliveryCount || 0} |\\n`;\n    output += `| Duplicate Detection | ${queueConfig.requiresDuplicateDetection ? 'Yes' : 'No'} |\\n`;\n    output += `| Sessions Enabled | ${queueInfo.requiresSession ? 'Yes' : 'No'} |\\n`;\n    output += `| Partitioning Enabled | ${queueConfig.enablePartitioning ? 'Yes' : 'No'} |\\n\\n`;\n\n    output += `## Recommendations\\n\\n`;\n    if (health.status === 'critical') {\n      output += `âš ï¸ **CRITICAL**: Immediate action required\\n`;\n      output += `- Investigate dead letter messages immediately\\n`;\n      output += `- Check consumer health and processing capacity\\n`;\n      output += `- Consider scaling out consumers\\n\\n`;\n    } else if (health.status === 'warning') {\n      output += `âš ï¸ **WARNING**: Monitor closely\\n`;\n      output += `- Review message processing times\\n`;\n      output += `- Check for processing bottlenecks\\n`;\n      output += `- Monitor dead letter queue growth\\n\\n`;\n    } else {\n      output += `âœ… Queue is healthy\\n`;\n      output += `- Continue regular monitoring\\n`;\n      output += `- Maintain current processing capacity\\n\\n`;\n    }\n\n    if (messages.length > 0) {\n      output += `## Recent Messages (${messages.length})\\n\\n`;\n      output += formatMessagesAsMarkdown(messages, false);\n    }\n\n    if (deadLetterMessages.length > 0) {\n      output += `\\n## Dead Letter Messages (${deadLetterMessages.length})\\n\\n`;\n      output += formatMessagesAsMarkdown(deadLetterMessages, false);\n    }\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-deadletter-analysis",
        "code": "server.prompt(\n  \"servicebus-deadletter-analysis\",\n  \"Analyze dead letter queue with pattern detection and actionable recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    maxMessages: z.string().optional().describe(\"Maximum messages to analyze (default: 50)\"),\n  },\n  async ({ resourceId, queueName, maxMessages }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Parse maxMessages to number\n    const maxMsgs = maxMessages ? parseInt(maxMessages, 10) : 50;\n\n    // Peek dead letter messages\n    const deadLetterMessages = await service.peekDeadLetterMessages(\n      resourceId,\n      queueName,\n      maxMsgs\n    );\n\n    if (deadLetterMessages.length === 0) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Dead Letter Queue Analysis: ${queueName}\\n\\nâœ… **No dead letter messages found**\\n\\nThe dead letter queue is empty. This indicates healthy message processing.`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Analyze dead letter messages\n    const { markdown } = formatDeadLetterAnalysisAsMarkdown(deadLetterMessages);\n\n    let output = `# Dead Letter Queue Analysis: ${queueName}\\n\\n`;\n    output += `**Namespace:** ${resource.namespace}\\n`;\n    output += `**Date:** ${new Date().toISOString()}\\n`;\n    output += `**Messages Analyzed:** ${deadLetterMessages.length}\\n\\n`;\n    output += markdown;\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: output,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "servicebus-message-inspection",
        "code": "server.prompt(\n  \"servicebus-message-inspection\",\n  \"Inspect a single message in detail with cross-service troubleshooting recommendations\",\n  {\n    resourceId: z.string().describe(\"Service Bus resource ID\"),\n    queueName: z.string().describe(\"Queue name\"),\n    messageId: z.string().optional().describe(\"Message ID to inspect (if not provided, inspects first message)\"),\n    isDeadLetter: z.string().optional().describe(\"Inspect dead letter queue (default: false)\"),\n  },\n  async ({ resourceId, queueName, messageId, isDeadLetter }) => {\n    const service = getServiceBusService();\n    const resource = service.getResourceById(resourceId);\n\n    // Parse isDeadLetter to boolean\n    const isDLQ = isDeadLetter === 'true';\n\n    // Peek messages\n    const messages = isDLQ\n      ? await service.peekDeadLetterMessages(resourceId, queueName, 100)\n      : await service.peekMessages(resourceId, queueName, 100);\n\n    if (messages.length === 0) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Message Inspection: ${queueName}\\n\\n**No messages found** in ${isDLQ ? 'dead letter queue' : 'queue'}.`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Find specific message or use first\n    const message = messageId\n      ? messages.find((m) => m.messageId === messageId)\n      : messages[0];\n\n    if (!message) {\n      return {\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `# Message Inspection: ${queueName}\\n\\n**Message not found** with ID: ${messageId}\\n\\nAvailable message IDs:\\n${messages.slice(0, 10).map((m) => `- ${m.messageId}`).join('\\n')}`,\n            },\n          },\n        ],\n      };\n    }\n\n    // Format message inspection\n    const output = formatMessageInspectionAsMarkdown(message, isDLQ);\n\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `# Message Inspection: ${queueName}\\n\\n**Namespace:** ${resource.namespace}\\n**Queue:** ${queueName}\\n**Date:** ${new Date().toISOString()}\\n\\n${output}`,\n          },\n        },\n      ],\n    };\n  }\n);"
      }
    ],
    "sharepoint": [
      {
        "name": "spo-site-overview",
        "code": "server.prompt(\n  \"spo-site-overview\",\n  {\n    siteId: z.string().describe(\"Site ID from configuration\"),\n  },\n  async ({ siteId }) => {\n    try {\n      const service = getSharePointService();\n\n      // Get site info\n      const site = await service.getSiteInfo(siteId);\n\n      // Get drives (document libraries)\n      const drives = await service.listDrives(siteId);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push(spoFormatters.formatSiteOverviewAsMarkdown(site));\n      sections.push('');\n      sections.push('## Document Libraries');\n      sections.push(spoFormatters.formatDrivesAsMarkdown(drives));\n\n      return {\n        description: `SharePoint site overview: ${site.displayName}`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Show overview of SharePoint site ${siteId}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating site overview:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-library-details",
        "code": "server.prompt(\n  \"spo-library-details\",\n  {\n    siteId: z.string().describe(\"Site ID\"),\n    driveId: z.string().describe(\"Drive (library) ID\"),\n  },\n  async ({ siteId, driveId }) => {\n    try {\n      const service = getSharePointService();\n\n      // Get drive info\n      const drive = await service.getDriveInfo(siteId, driveId);\n\n      // Get recent items\n      const recentItems = await service.getRecentItems(siteId, driveId, 10, 30);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push(spoFormatters.formatDriveDetailsAsMarkdown(drive));\n      sections.push('');\n      sections.push('## Recent Activity (Last 30 days)');\n      sections.push(spoFormatters.formatItemsAsMarkdown(recentItems));\n\n      return {\n        description: `Document library details: ${drive.name}`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Show details for document library ${driveId} in site ${siteId}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating library details:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-document-search",
        "code": "server.prompt(\n  \"spo-document-search\",\n  {\n    siteId: z.string().describe(\"Site ID\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    query: z.string().describe(\"Search query (filename or keywords)\"),\n  },\n  async ({ siteId, driveId, query }) => {\n    try {\n      const service = getSharePointService();\n\n      // Search items\n      const searchResults = await service.searchItems(siteId, driveId, query);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push(`# ðŸ” Search Results: \"${query}\"`);\n      sections.push('');\n      sections.push(`Found ${searchResults.items.length} result(s)`);\n      sections.push('');\n      sections.push(spoFormatters.formatItemsAsMarkdown(searchResults.items));\n\n      return {\n        description: `Search results for \"${query}\"`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Search for \"${query}\" in drive ${driveId} of site ${siteId}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating search results:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-recent-activity",
        "code": "server.prompt(\n  \"spo-recent-activity\",\n  {\n    siteId: z.string().describe(\"Site ID\"),\n    driveId: z.string().describe(\"Drive ID\"),\n    days: z.string().optional().describe(\"Number of days to look back (default: 7)\"),\n  },\n  async ({ siteId, driveId, days }) => {\n    try {\n      const service = getSharePointService();\n\n      const daysBack = days ? parseInt(days) : 7;\n      const recentItems = await service.getRecentItems(siteId, driveId, 50, daysBack);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push(`# ðŸ“… Recent Activity (Last ${daysBack} days)`);\n      sections.push('');\n      sections.push(`**Document Library:** ${driveId}`);\n      sections.push(`**Total Changes:** ${recentItems.length}`);\n      sections.push('');\n      sections.push(spoFormatters.formatItemsAsMarkdown(recentItems));\n\n      return {\n        description: `Recent activity for last ${daysBack} days`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Show recent activity in drive ${driveId} for last ${daysBack} days`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating recent activity report:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-validate-crm-integration",
        "code": "server.prompt(\n  \"spo-validate-crm-integration\",\n  {\n    documentLocationId: z.string().describe(\"Document location ID from PowerPlatform\"),\n  },\n  async ({ documentLocationId }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      // Validate document location\n      const result = await spoService.validateDocumentLocation(ppService, documentLocationId);\n\n      // Generate analysis\n      const sections: string[] = [];\n\n      sections.push(spoFormatters.formatValidationResultAsMarkdown(result));\n\n      return {\n        description: `Validation result for document location ${documentLocationId}`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Validate PowerPlatform document location ${documentLocationId}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error validating CRM integration:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-document-location-audit",
        "code": "server.prompt(\n  \"spo-document-location-audit\",\n  {\n    entityName: z.string().optional().describe(\"Entity logical name (e.g., 'account')\"),\n    recordId: z.string().optional().describe(\"Record ID (GUID)\"),\n  },\n  async ({ entityName, recordId }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      // Get document locations\n      const locations = await spoService.getCrmDocumentLocations(ppService, entityName, recordId);\n\n      // Analyze\n      const analysis = spoFormatters.analyzeCrmDocumentLocations(locations);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push('# ðŸ“‹ Document Location Audit');\n      sections.push('');\n\n      if (entityName) {\n        sections.push(`**Entity:** ${entityName}`);\n      }\n\n      if (recordId) {\n        sections.push(`**Record ID:** ${recordId}`);\n      }\n\n      sections.push('');\n      sections.push('## Insights');\n      analysis.insights.forEach(insight => {\n        sections.push(insight);\n      });\n\n      sections.push('');\n      sections.push('## Document Locations');\n      sections.push(spoFormatters.formatCrmDocumentLocationsAsMarkdown(locations));\n\n      if (analysis.recommendations.length > 0) {\n        sections.push('');\n        sections.push('## Recommendations');\n        analysis.recommendations.forEach(rec => {\n          sections.push(`- ${rec}`);\n        });\n      }\n\n      return {\n        description: `Document location audit${entityName ? ` for ${entityName}` : ''}`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Audit document locations${entityName ? ` for entity ${entityName}` : ''}${recordId ? ` record ${recordId}` : ''}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating document location audit:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-migration-verification-report",
        "code": "server.prompt(\n  \"spo-migration-verification-report\",\n  {\n    sourceSiteId: z.string().describe(\"Source site ID\"),\n    sourcePath: z.string().describe(\"Source folder path\"),\n    targetSiteId: z.string().describe(\"Target site ID\"),\n    targetPath: z.string().describe(\"Target folder path\"),\n  },\n  async ({ sourceSiteId, sourcePath, targetSiteId, targetPath }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      // Verify migration\n      const result = await spoService.verifyDocumentMigration(\n        ppService,\n        sourceSiteId,\n        sourcePath,\n        targetSiteId,\n        targetPath\n      );\n\n      // Analyze\n      const analysis = spoFormatters.analyzeMigrationVerification(result);\n\n      // Build report\n      const sections: string[] = [];\n\n      sections.push(spoFormatters.formatMigrationReportAsMarkdown(result));\n      sections.push('');\n      sections.push('## Analysis');\n      analysis.insights.forEach(insight => {\n        sections.push(`- ${insight}`);\n      });\n\n      sections.push('');\n      sections.push('## Recommendations');\n      analysis.recommendations.forEach(rec => {\n        sections.push(`- ${rec}`);\n      });\n\n      return {\n        description: `Migration verification: ${result.status} (${result.successRate}% success)`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Verify document migration from ${sourcePath} to ${targetPath}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error generating migration verification report:\", error);\n      throw error;\n    }\n  }\n);"
      },
      {
        "name": "spo-setup-validation-guide",
        "code": "server.prompt(\n  \"spo-setup-validation-guide\",\n  {},\n  async () => {\n    const guide = `# SharePoint Integration Setup Validation Guide\n\n## Prerequisites Checklist\n\n### 1. Azure AD App Registration\n- âœ… App registered in Azure Active Directory\n- âœ… Client ID and Client Secret generated\n- âœ… Tenant ID noted\n\n### 2. API Permissions\nRequired Microsoft Graph API permissions (Application permissions):\n- âœ… Sites.Read.All or Sites.ReadWrite.All\n- âœ… Files.Read.All or Files.ReadWrite.All\n- âœ… Admin consent granted\n\n### 3. SharePoint Site Access\n- âœ… Service principal added to site(s) as Site Collection Admin\n- âœ… Site URLs accessible and correct\n\n### 4. Configuration\nEnvironment variables configured:\n- âœ… SHAREPOINT_TENANT_ID\n- âœ… SHAREPOINT_CLIENT_ID\n- âœ… SHAREPOINT_CLIENT_SECRET\n- âœ… SHAREPOINT_SITES (JSON array) or SHAREPOINT_SITE_URL\n\n## Testing Steps\n\n### Step 1: Test Connection\n\\`\\`\\`\nUse tool: spo-test-connection\nParameters: { siteId: \"your-site-id\" }\nExpected: Site information returned with no errors\n\\`\\`\\`\n\n### Step 2: List Document Libraries\n\\`\\`\\`\nUse tool: spo-list-drives\nParameters: { siteId: \"your-site-id\" }\nExpected: List of document libraries with quota info\n\\`\\`\\`\n\n### Step 3: List Files\n\\`\\`\\`\nUse tool: spo-list-items\nParameters: { siteId: \"your-site-id\", driveId: \"library-id\" }\nExpected: List of files and folders\n\\`\\`\\`\n\n### Step 4: Test PowerPlatform Integration (Optional)\n\\`\\`\\`\nUse tool: spo-get-crm-document-locations\nExpected: List of document locations from Dataverse\n\\`\\`\\`\n\n## Common Issues\n\n### Issue: \"Access denied\" error\n**Solution:**\n1. Verify API permissions are granted\n2. Ensure admin consent is granted\n3. Check service principal is Site Collection Admin\n\n### Issue: \"Site not found\"\n**Solution:**\n1. Verify site URL is correct (use full URL)\n2. Check site exists and is accessible\n3. Ensure site is in SHAREPOINT_SITES configuration\n\n### Issue: \"Authentication failed\"\n**Solution:**\n1. Verify tenant ID, client ID, and client secret\n2. Check client secret hasn't expired\n3. Ensure app registration is active\n\n## Next Steps\n\nOnce setup is validated:\n1. Configure additional sites in SHAREPOINT_SITES\n2. Set up PowerPlatform integration for document location validation\n3. Use validation tools to audit document locations\n4. Set up migration verification workflows\n\nFor more help, refer to SETUP.md documentation.\n`;\n\n    return {\n      description: \"SharePoint integration setup validation guide\",\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: \"Show SharePoint integration setup validation guide\",\n          },\n        },\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: guide,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "spo-troubleshooting-guide",
        "code": "server.prompt(\n  \"spo-troubleshooting-guide\",\n  {\n    errorType: z.string().optional().describe(\"Type of error (e.g., 'access-denied', 'site-not-found')\"),\n  },\n  async ({ errorType }) => {\n    const guide = `# SharePoint Integration Troubleshooting Guide\n\n## Common Error Scenarios\n\n### 1. Access Denied (403 Forbidden)\n\n**Symptoms:**\n- \"Access denied\" errors when accessing sites or files\n- \"Insufficient permissions\" messages\n\n**Causes:**\n- Missing API permissions\n- Admin consent not granted\n- Service principal not added to site\n\n**Solutions:**\n1. Verify Microsoft Graph API permissions:\n   - Sites.Read.All (or Sites.ReadWrite.All)\n   - Files.Read.All (or Files.ReadWrite.All)\n2. Grant admin consent in Azure AD\n3. Add service principal as Site Collection Admin:\n   - Go to site settings â†’ Site permissions\n   - Add app with client ID\n   - Grant Full Control or Read permissions\n\n### 2. Site Not Found (404 Not Found)\n\n**Symptoms:**\n- \"Site not found\" errors\n- \"Resource does not exist\" messages\n\n**Causes:**\n- Incorrect site URL\n- Site not in SHAREPOINT_SITES configuration\n- Site deleted or moved\n\n**Solutions:**\n1. Verify site URL format: https://tenant.sharepoint.com/sites/sitename\n2. Check site exists by visiting in browser\n3. Add site to SHAREPOINT_SITES configuration\n4. Ensure site is not archived or deleted\n\n### 3. Authentication Failed (401 Unauthorized)\n\n**Symptoms:**\n- \"Authentication failed\" errors\n- \"Invalid credentials\" messages\n\n**Causes:**\n- Incorrect tenant ID, client ID, or client secret\n- Client secret expired\n- App registration disabled\n\n**Solutions:**\n1. Verify credentials in environment variables\n2. Check client secret expiration in Azure AD\n3. Generate new client secret if expired\n4. Ensure app registration is active\n\n### 4. Token Acquisition Failed\n\n**Symptoms:**\n- \"Failed to acquire access token\" errors\n- MSAL errors\n\n**Causes:**\n- Network connectivity issues\n- Firewall blocking Azure AD\n- Incorrect tenant ID\n\n**Solutions:**\n1. Verify network connectivity to login.microsoftonline.com\n2. Check firewall rules\n3. Verify tenant ID is correct\n4. Test authentication manually\n\n### 5. Folder Not Found\n\n**Symptoms:**\n- \"Folder not accessible\" in validation results\n- \"Item not found\" errors\n\n**Causes:**\n- Incorrect folder path\n- Folder deleted or moved\n- Permissions issue\n\n**Solutions:**\n1. Verify folder path format: /LibraryName/Folder1/Folder2\n2. Check folder exists in SharePoint\n3. Ensure service principal has access\n4. Use spo-list-items to browse folder structure\n\n### 6. Document Location Validation Fails\n\n**Symptoms:**\n- Validation status: \"error\" or \"warning\"\n- Missing or inaccessible folders\n\n**Causes:**\n- CRM absolute URL incorrect\n- Site not configured\n- Folder path mismatch\n\n**Solutions:**\n1. Verify absolute URL in PowerPlatform\n2. Add site to SHAREPOINT_SITES configuration\n3. Check folder path matches SharePoint structure\n4. Use spo-validate-document-location tool\n\n## Diagnostic Tools\n\n### Test Connection\n\\`\\`\\`\nUse: spo-test-connection\nPurpose: Verify site accessibility and permissions\n\\`\\`\\`\n\n### List Sites\n\\`\\`\\`\nUse: spo-list-sites\nPurpose: Verify configured sites and status\n\\`\\`\\`\n\n### Validate Document Location\n\\`\\`\\`\nUse: spo-validate-document-location\nPurpose: Check PowerPlatform integration\n\\`\\`\\`\n\n## Getting Help\n\nIf issues persist:\n1. Check application logs for detailed error messages\n2. Review audit logs in Azure AD\n3. Test permissions using Microsoft Graph Explorer\n4. Refer to SETUP.md for detailed configuration steps\n\nFor API-specific errors, refer to Microsoft Graph API documentation.\n`;\n\n    return {\n      description: `SharePoint troubleshooting guide${errorType ? ` for ${errorType}` : ''}`,\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Show SharePoint troubleshooting guide${errorType ? ` for ${errorType}` : ''}`,\n          },\n        },\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: guide,\n          },\n        },\n      ],\n    };\n  }\n);"
      },
      {
        "name": "spo-powerplatform-integration-health",
        "code": "server.prompt(\n  \"spo-powerplatform-integration-health\",\n  {\n    entityName: z.string().optional().describe(\"Entity to check (e.g., 'account')\"),\n  },\n  async ({ entityName }) => {\n    try {\n      const spoService = getSharePointService();\n      const ppService = getPowerPlatformService();\n\n      // Get all document locations for entity\n      const locations = await spoService.getCrmDocumentLocations(ppService, entityName);\n\n      // Analyze\n      const analysis = spoFormatters.analyzeCrmDocumentLocations(locations);\n\n      // Build health report\n      const sections: string[] = [];\n\n      sections.push('# ðŸ¥ PowerPlatform-SharePoint Integration Health Check');\n      sections.push('');\n\n      if (entityName) {\n        sections.push(`**Entity:** ${entityName}`);\n        sections.push('');\n      }\n\n      sections.push('## Health Summary');\n      sections.push('');\n      analysis.insights.forEach(insight => {\n        sections.push(insight);\n      });\n\n      sections.push('');\n      sections.push('## Configured Document Locations');\n      sections.push(spoFormatters.formatCrmDocumentLocationsAsMarkdown(locations));\n\n      if (analysis.recommendations.length > 0) {\n        sections.push('');\n        sections.push('## Recommendations');\n        analysis.recommendations.forEach(rec => {\n          sections.push(`- ðŸ’¡ ${rec}`);\n        });\n      }\n\n      sections.push('');\n      sections.push('## Next Steps');\n      sections.push('');\n      sections.push('1. Use `spo-validate-document-location` to validate individual locations');\n      sections.push('2. Check for missing or inaccessible folders');\n      sections.push('3. Verify service principal has access to all sites');\n      sections.push('4. Review empty folders and upload documents');\n\n      return {\n        description: `Integration health check${entityName ? ` for ${entityName}` : ''}`,\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: `Check PowerPlatform-SharePoint integration health${entityName ? ` for ${entityName}` : ''}`,\n            },\n          },\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: sections.join('\\n'),\n            },\n          },\n        ],\n      };\n    } catch (error: any) {\n      console.error(\"Error checking integration health:\", error);\n      throw error;\n    }\n  }\n);"
      }
    ]
  }
}